---
layout: post
title: "Pour les gouverner tous - partie 3/3"
date: 2011-02-24
comments: false
categories:
 - java
 - jmx
 - jgroups
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_XLL8sJPQ97g/TUcoTratqiI/AAAAAAAAAUQ/Gmc1h0rvA2w/s1600/jmx_jgroups01.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em; text-align: justify;"><img border="0" height="173" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/TUcoTratqiI/AAAAAAAAAUQ/Gmc1h0rvA2w/s320/jmx_jgroups01.png" width="320" /></a></div><div style="text-align: justify;">Cet article fait suite à mes précédents posts (<a href="http://jetoile.blogspot.com/2011/01/pour-les-gouverner-tous-partie-13.html">ici</a> et <a href="http://jetoile.blogspot.com/2011/02/pour-les-gouverner-tous-partie-23.html">là</a>) et à pour objectif d'intégrer la partie JMX à mon petit POC JGroups afin d'offrir une solution permettant de rendre complètement scalable la partie supervision/administration par JMX d'une application distribuée (ie. d'aggréger tous les MBeans au sein de tous les serveurs JMX). Pour rappel, le post précédent introduisait JGroups dans une petite application qui permettait à chaque instance d'une application d'obtenir la valeur d'une donnée offerte par les autres instances.</div><br /><br /><!-- more --><span class="Apple-style-span" style="font-size: 32px; font-weight: bold;">Expression du besoin et conception</span><br /><div style="text-align: justify;">Comme je l'ai expliqué <a href="http://jetoile.blogspot.com/2011/01/pour-les-gouverner-tous-partie-13.html">ici</a>, le principe est simple :&nbsp;en démarrant son application qui aura à sa charge d'appeler un petit bout de code de notre toolkit,&nbsp;tous les MBeans se trouvant sur les autres serveurs JMX (modulo que l'application qui les ait démarrés ait démarré en instanciant notre toolkit) doivent être&nbsp;remonter dans notre serveur JMX courant. Réciproquement, tous les MBeanServer devront enregistrer les MBeans offerts par notre instance d'application.</div><br /><div style="text-align: justify;">Pour ce faire, notre toolkit gérera la partie JMX, c'est-à-dire qu'il&nbsp;créera un connecteur JMX serveur (connecteur s'appuyant sur le protocole RMI) permettant d'accéder au MBeanServer courant (ie. il utilisera le MBeanServer s'il en existe un ou, dans le cas échéant, il en créera un) et qu'il l'exposera aux autres instances en fournissant un stub de la partie connecteur JMX cliente. Ce stub permettra aux autres instances d'instancier la couche de communication nécessaire vers le MBeanServer cible.&nbsp;C'est ce stub qui sera transmis par JGroups (et qui remplacera donc la donnée partagée de notre POC JGroups).</div>Ca va? Tout le monde suit? Bon, on va pouvoir accélérer... ;-)<br /><div style="text-align: justify;">Ainsi, lorsqu'une nouvelle instance sera démarrée dans le système, les instances déjà présentes seront notifiées de l'arrivé d'un nouveau membre dans la vue (concepts <a href="http://jetoile.blogspot.com/2010/12/jgroups-tour-d.html">JGroups</a> et&nbsp;cf. <a href="http://jetoile.blogspot.com/2011/02/pour-les-gouverner-tous-partie-23.html">post précédent</a>). Suite à cela, elles récupèreront le stub du JMXConnector du nouveau MBeanServer (toujours cf. <a href="http://jetoile.blogspot.com/2011/02/pour-les-gouverner-tous-partie-23.html">post précédent</a>) qui leur permettra de créer un proxy dynamique correspondant aux MBeans présents dans le MBeanServer cible. Ce proxy dynamique sera instancié et enregistré comme étant un nouveau MBean dans le MBeanServer de l'instance courante.</div><div style="text-align: justify;">Cependant, ce proxy dynamique ne pourra pas être utilisé directement (sinon ça serait trop simple). En effet, la méthode statique <i>JMX.newMBeanProxy()</i> permet de créer un proxy dynamique du MBean standard d'un MBeanServer distant ou local. Cependant, il n'est pas possible de l'enregistrer comme MBean au sein d'un MBeanServer car il ne répond alors pas à la règle : "un MBean doit implémenter une interface de type MBean ou DynamicMBean".&nbsp;Aussi, la solution retenue a été de <em>wrapper</em> ce proxy dynamique dans un MBean dynamique. Ce wrapper fera donc passe-plat (en utilisant la réflexion) avec le proxy dynamique récupéré par la méthode <em>JMX.newMBeanProxy()</em> lors de l'invocation d'opérations dessus (pour ce faire, il s'appuiera sur les normes spécifiées par JMX pour l'accès en lecture/écriture aux variables d'instance).</div><div style="text-align: justify;">En outre, pour le cas spécifique des MXBeans (un certain nombre de MXBean est spécifié par JMX :&nbsp;<a href="http://download.oracle.com/javase/6/docs/api/">http://download.oracle.com/javase/6/docs/api/</a>), un traitement particulier sera effectué. En effet, JMX offre la possibilité de créer directement un proxy de l'interface d'un MXBean donné via la méthode statique <em>ManagementFactory.newPlatformMXBeanProxy()</em>. Aussi, pour les MXBeans, notre wrapper ne sera pas utilisé puisqu'il est possible d'enregistrer directement au sein de notre MBeanServer courant le MXBean distant.</div><div style="text-align: justify;">Bien sûr, encore une fois, cela aurait été trop simple s'il n'y avait pas un mais... ;-) En effet, la spécification JMX précise qu'il est possible d'avoir plusieurs MXBeans de type <strong>MemoryPoolMXBean</strong>, <strong>MemoryManagerMXBean</strong> et <strong>GarbageCollector</strong> (cf. <a href="http://download.oracle.com/javase/6/docs/api/">http://download.oracle.com/javase/6/docs/api/</a>). Dans ces cas précis, ce sont les propriétés de ces MXBeans qui permettent de les différencier : un traitement particulier sera donc effectué dans ces cas précis puisqu'une recherche pour décrouvrir les propritétés du <b>MXBean</b> sera faite.</div><div style="text-align: justify;">En outre, un cas particulier lié à la JRE 6 de Sun (Hostpot) a, ici, été traité (du coup, cela rend le code proposé adhérent à notre jdk...) puisque le MXBean <strong>HotpostDiagnostic</strong> a fait l'objet d'une attention particulière...</div><h1>Mise en oeuvre</h1><h2>Intégration de JMX</h2><div style="text-align: justify;"><span style="text-decoration: underline;">Note</span> : à noter que le code présenté dans cet article comporte quelques raccourcis et n'a pour objectif que de montrer les points clé. Aussi, certaines portions (comme, entre autre, la gestion des threads, des exceptions ou les méthodes <em>equals(),</em>&nbsp;<em>hashCode()&nbsp;</em>ou <em>toString()</em>) ne sont pas présentes par soucis de clarté. Le code complet peut être trouvé&nbsp;sur GitHub :&nbsp;<a href="https://github.com/jetoile/jmanager4all">https://github.com/jetoile/jmanager4all</a>.</div><div style="text-align: justify;">Ici, la donnée, traduite par la classe <strong>Data</strong> dans mon <a href="http://jetoile.blogspot.com/2011/02/pour-les-gouverner-tous-partie-23.html">article précédent</a>, sera remplacée par le stub au <strong>JMXConnector</strong>. Ce stub sera créé par la classe utilisée pour instancier les objets nécessaires à la bonne initalisation du toolkit et il sera encapsulé dans la classe&nbsp;<strong>JManagerConnector</strong> (à noter, bien sûr que la classe <strong>RMIConnector</strong> (implémentation de&nbsp;l'interface <strong>JMXConnector</strong>)&nbsp;utilisée ici est sérialisable) lors de sa transmission entre les différentes instances de l'application.</div><br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class JManagerConnector implements Serializable {<br /> private String location;<br /> private JMXConnector connector;<br /><br /> public JManagerConnector() {<br /> }<br /><br /> public String getLocation() {<br />  return location;<br /> }<br /><br /> public void setLocation(final String location) {<br />  this.location = location;<br /> }<br /><br /> public JMXConnector getConnector() {<br />  return connector;<br /> }<br /><br /> public void setConnector(final JMXConnector connector) {<br />  this.connector = connector;<br /> }<br />}<br /></pre><div style="text-align: justify;">Du point de vue création des objets JMX exposés (ie. le <strong>JMXConnector</strong> et son stub) et de l'initialisation de ces derniers (ie. démarrage du connecteur), cela sera fait, comme dit précédemment, par notre classe qui nous servira de point d'entrée à notre toolkit <strong>JManager4All</strong> :</div><pre class="brush:java; wrap-lines: false; auto-links: false">public class JManager4All {<br /><br />    final static private Logger LOGGER = LoggerFactory.getLogger(JManager4All.class);<br /><br />    private static final String CONNECTOR_PROTOCOL = "rmi";<br /><br />    private JMXConnectorServer jmxConnector;<br />    private JMXServiceURL jmxServiceUrl;<br />    final private JManagerConnector jmanagerConnector = new JManagerConnector();<br />    private final MBeanServer mBeanServer;<br />    final private JMXConnectorStubCache connectorsStub = new JMXConnectorStubCache();<br /><br />    private JGroupsBindingComponent jmanagerBindingComponent;<br />    public JManager4All(final int port) {<br />        try {<br />            this.jmxServiceUrl = new JMXServiceURL(CONNECTOR_PROTOCOL, null, port);<br />        } catch (MalformedURLException e) {<br />            LOGGER.error("unable to create JMXServiceURL: {}", e);<br />        }<br />        this.mBeanServer = ManagementFactory.getPlatformMBeanServer();<br />        init();<br />    }<br /><br />    private void init() {<br />        try {<br />            this.jmxConnector = JMXConnectorServerFactory.newJMXConnectorServer(this.jmxServiceUrl, null, mBeanServer);<br />            this.jmxConnector.start();<br /><br />            final ObjectName objectName = new ObjectName(":type=csserver, name=csserver");<br />            mBeanServer.registerMBean(this.jmxConnector, objectName);<br />            this.jmanagerConnector.setConnector(this.jmxConnector.toJMXConnector(null));<br /><br />            this.jmanagerBindingComponent = new JGroupsBindingComponent(this.jmanagerConnector);<br />            this.jmanagerBindingComponent.setConnectorsStub(this.connectorsStub);<br />        } catch (Exception e) {<br />            LOGGER.error("unable to init: {}", e);<br />        }<br />    }<br /><br />    public void stop() throws IOException {<br />        this.jmxConnector.stop();<br />        this.jmanagerBindingComponent.stop();<br />    }<br /><br />    public void start() {<br />        this.jmanagerBindingComponent.start();<br />    }<br /><br />    public JManagerConnector getStubConnector() {<br />        return this.jmanagerConnector;<br />    }<br />}<br /></pre><div style="text-align: justify;">On remarquera également que cette classe instancie et démarre une instance d'un <strong>JGroupsBindingComponent</strong> qui s'occupe de la couche communication pour récupérer nos stubs du système (ici, ça sera JGroups). Je ne reviendrai pas sur les détails d'implémentation de cette partie puisque cela a déjà été traité <a href="http://jetoile.blogspot.com/2011/02/pour-les-gouverner-tous-partie-23.html">ici</a>.</div><div style="text-align: justify;">A noter également que nos stubs seront conservés dans un cache <strong>JMXConnectorStubCache</strong> qui déclenchera, lorsqu'un élément (ie. un stub d'un <strong>JMXConnector</strong>) sera ajouté ou supprimé, la récupération de nos <b>MBean</b> distant et leur enregistrement au sein du <b>MBeanServer</b> courant (resp. leur suppression).</div><pre class="brush:java; wrap-lines: false; auto-links: false">public class JMXConnectorStubCache implements Serializable {<br /><br /> volatile private Map&lt;JManagerAddress, JMXConnector&gt; connectorsStub = Collections.synchronizedMap(new HashMap&lt;JManagerAddress, JMXConnector&gt;());<br /><br /> synchronized public Map&lt;JManagerAddress, JMXConnector&gt; getValue() {<br />  return this.connectorsStub;<br /> }<br /><br /> synchronized public JMXConnector put(JManagerAddress key, JMXConnector value) {<br />  JMXConnector result = this.connectorsStub.put(key, value);<br />  MBeanHandler mBeanHandler = new MBeanHandler(key, value);<br />  mBeanHandler.handleAdd();<br />  return result;<br /> }<br /><br /> synchronized public JMXConnector remove(JManagerAddress key) {<br />  JMXConnector result = this.connectorsStub.remove(key);<br />  MBeanHandler mBeanHandler = new MBeanHandler(key, result);<br />  mBeanHandler.handleRemove();<br />  return result;<br /> }<br />}<br /></pre><div style="text-align: justify;">Ce dernier point nous amène au paragraphe suivant, à savoir la récupération des MBeans distants et leur enregistrement.</div><h2 style="text-align: justify;">Récupération des MBeans distants et enregistrement</h2><div style="text-align: justify;">La récupération des MBeans distants est globalement simple et suit le schéma suivant (cet algorithme ne s'applique pas aux MXBeans) :</div><ul><li style="text-align: justify;">à partir du <strong>JMXConnector</strong> client, récupération du <strong>MBeanServerConnection</strong>,</li><li style="text-align: justify;">à partir du <strong>MBeanServerConnection</strong>, une recherche est lancée sur le <strong>MBeanServer</strong> distant pour récupérer l'ensemble des <strong>ObjectInstance</strong> présenst sur ce dernier,</li><li style="text-align: justify;">pour chaque <strong>ObjectInstance</strong> qui n'est pas dans le domaine JMX "<em>remote</em>" (qui sera le domaine utilisé pour stocker les proxy des MBeans distants), création d'un proxy dynamique représentant l'objet exposé par le MBean et encapsulation de ce dernier dans la classe <strong>MBeanWrapper</strong> qui est un <strong>DynamicMBean</strong>,</li><li><div style="text-align: justify;">enfin enregistrement&nbsp;de chaque <strong>DynamicMBean</strong> créé dans le <strong>MBeanServer</strong> local via un <strong>ObjectName</strong> défini grâce à :</div><ul><li style="text-align: justify;">ses propriétés,&nbsp;</li><li style="text-align: justify;">son domaine JMX distant sous forme de propriété "<em>subdomain</em>",&nbsp;</li><li style="text-align: justify;">mais également avec une propriété permettant de connaitre la provenance du MBean (propriété qui sera appelée "<em>instance</em>").</li></ul></li></ul><pre class="brush:java; wrap-lines: false; auto-links: false">public class MBeanHandler {<br /> private static final String DOMAIN_REMOTE = "remote";<br /><br /> private static final Logger LOGGER = LoggerFactory.getLogger(MBeanHandler.class);<br /><br /> private final MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();<br /> private final JMXConnector connector;<br /> private final JManagerAddress address;<br /><br /> public MBeanHandler(final JManagerAddress address, final JMXConnector connector) {<br />  this.connector = connector;<br />  this.address = address;<br /> }<br /><br /> void handleAdd() throws Exception {<br />  if (connector != null) {<br />   connector.connect();<br />   ObjectName objectName = new ObjectName("*:*");<br />   final MBeanServerConnection mBeanServerConnection = connector.getMBeanServerConnection();<br /><br />   final Set&lt;ObjectInstance&gt; instances = mBeanServerConnection.queryMBeans(objectName, null);<br /><br />   for (ObjectInstance objectInstance : instances) {<br />    final ObjectName distantObjectName = objectInstance.getObjectName();<br />    if (DOMAIN_REMOTE.equals(distantObjectName.getDomain())) {<br />     continue;<br />    }<br />    final ObjectName newObjectName = new ObjectName(DOMAIN_REMOTE + ":instance=" + address + ", " + "subdomain=" + distantObjectName.getDomain()<br />      + ", " + distantObjectName.getKeyPropertyListString());<br />    final MBeanInfo mBeanInfo = mBeanServerConnection.getMBeanInfo(distantObjectName);<br />    registerRemoteMBean(mBeanServerConnection, distantObjectName, newObjectName, mBeanInfo);<br />   }<br />  }<br /> }<br /><br /> private void registerRemoteMBean(final MBeanServerConnection mBeanServerConnection, final ObjectName distantObjectName, final ObjectName newObjectName,<br />   final MBeanInfo mBeanInfo) throws Exception {<br />  Object mBean = getRemoteMBean(mBeanServerConnection, mBeanInfo, distantObjectName);<br />  if (mBean != null) {<br />   mbeanServer.registerMBean(mBean, newObjectName);<br />  }<br /> }<br /><br /> public Object getRemoteMBean(final MBeanServerConnection mBeanServerConnection, final MBeanInfo mBeanInfo, final ObjectName distantObjectName)<br />   throws Exception {<br />  if (!Boolean.parseBoolean((String) mBeanInfo.getDescriptor().getFieldValue("mxbean"))) {<br />   LOGGER.debug("current mxBeanInfo : {}", mBeanInfo);<br />   final Class&lt;?&gt; clazz = Class.forName(mBeanInfo.getClassName());<br />   final Class&lt;?&gt;[] interfazes = clazz.getInterfaces();<br />   if (interfazes.length == 1) {<br />    LOGGER.debug("current interface : {}", interfazes[0]);<br />    final Object proxy = JMX.newMBeanProxy(mBeanServerConnection, distantObjectName, interfazes[0]);<br />    final MBeanWrapper mBeanWrapper = new MBeanWrapper(mBeanInfo, proxy);<br />    return mBeanWrapper;<br />   }<br />  }<br />  return null;<br /> }<br />}<br /></pre><br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class MBeanWrapper implements DynamicMBean {<br /><br /> static final private Logger LOGGER = LoggerFactory.getLogger(MBeanWrapper.class);<br /><br /> private final MBeanInfo mBeanInfo;<br /> private final Object proxy;<br /><br /> public MBeanWrapper(final MBeanInfo mBeanInfo, final Object proxy) {<br />  this.mBeanInfo = mBeanInfo;<br />  this.proxy = proxy;<br /> }<br /><br /> @Override<br /> public Object getAttribute(String attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {<br />  MBeanAttributeInfo[] mBeanAttributeInfos = mBeanInfo.getAttributes();<br />  for (MBeanAttributeInfo mBeanAttributeInfo : mBeanAttributeInfos) {<br />   if (StringUtils.equals(attribute, mBeanAttributeInfo.getName())) {<br />    if (mBeanAttributeInfo.isReadable()) {<br />     return invokeGetter(attribute, mBeanAttributeInfo);<br />    } else {<br />     return null;<br />    }<br />   }<br />  }<br />  return null;<br /> }<br /><br /> Object invokeGetter(String attribute, MBeanAttributeInfo mBeanAttributeInfo) {<br />  try {<br />   Method method = null;<br />   if (mBeanAttributeInfo.isIs()) {<br />    method = this.proxy.getClass().getMethod("is" + StringUtils.capitalize(attribute), new Class[0]);<br />    return method.invoke(this.proxy, new Object[0]);<br />   } else {<br />    method = this.proxy.getClass().getMethod("get" + StringUtils.capitalize(attribute), new Class[0]);<br />    return method.invoke(this.proxy, new Object[0]);<br />   }<br />  } catch (Exception e) {<br />   LOGGER.error("unable to get remote attribute info {}: {}", attribute, e);<br />  }<br />  return null;<br /> }<br /><br /> @Override<br /> public void setAttribute(Attribute attribute) throws AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException {<br />  MBeanAttributeInfo[] mBeanAttributeInfos = mBeanInfo.getAttributes();<br />  for (MBeanAttributeInfo mBeanAttributeInfo : mBeanAttributeInfos) {<br />   if (StringUtils.equals(attribute.getName(), mBeanAttributeInfo.getName())) {<br />    if (mBeanAttributeInfo.isWritable()) {<br />     invokeSetter(attribute, mBeanAttributeInfo);<br />    } else {<br />     return;<br />    }<br />   }<br />  }<br />  return;<br /> }<br /><br /> void invokeSetter(Attribute attribute, MBeanAttributeInfo mBeanAttributeInfo) {<br />  try {<br />   Method method = null;<br />   if (mBeanAttributeInfo.isIs()) {<br />    method = this.proxy.getClass().getMethod("set" + StringUtils.capitalize(attribute.getName()), boolean.class);<br />    method.invoke(this.proxy, attribute.getValue());<br />   } else {<br />    method = this.proxy.getClass().getMethod("set" + StringUtils.capitalize(attribute.getName()), attribute.getValue().getClass());<br />    method.invoke(this.proxy, attribute.getValue());<br />   }<br />  } catch (Exception e) {<br />   LOGGER.error("unable to set remote attribute info {}: {}", attribute, e);<br />  }<br /> }<br /><br /> @Override<br /> public AttributeList getAttributes(String[] attributes) {<br />  AttributeList result = new AttributeList();<br />  for (String attribute : attributes) {<br />   Attribute currentAttribute;<br />   try {<br />    currentAttribute = new Attribute(attribute, getAttribute(attribute));<br />    result.add(currentAttribute);<br />   } catch (Exception e) {<br />    LOGGER.error("unable to get remote attribute info {}: {}", attribute, e);<br />   }<br />  }<br />  return result;<br /> }<br /><br /> @Override<br /> public AttributeList setAttributes(AttributeList attributes) {<br />  AttributeList result = new AttributeList();<br />  for (int i = 0; i &lt; attributes.size(); i++) {<br />   Attribute attribute = (Attribute) attributes.get(i);<br />   try {<br />    setAttribute(attribute);<br />    result.add(attribute);<br />   } catch (Exception e) {<br />    LOGGER.error("unable to set remote attribute {}: {}", attribute.getName(), e);<br />   }<br />  }<br />  return result;<br /> }<br /><br /> @Override<br /> public Object invoke(String actionName, Object[] params, String[] signature) throws MBeanException, ReflectionException {<br />  Class[] paramTypes = null;<br />  if (signature != null) {<br />   paramTypes = new Class[signature.length];<br />   for (int i = 0; i &lt; signature.length; ++i) {<br />    paramTypes[i] = signature[i].getClass();<br />   }<br />  }<br /><br />  try {<br />   Method method = this.proxy.getClass().getMethod(actionName, paramTypes);<br />   return method.invoke(this.proxy, params);<br />  } catch (Exception e) {<br />   LOGGER.error("unable to invoke {}: {}", actionName, e);<br />  }<br />  return null;<br /> }<br /><br /> @Override<br /> public MBeanInfo getMBeanInfo() {<br />  return this.mBeanInfo;<br /> }<br />}<br /></pre><div style="text-align: justify;">On voit donc que le processus n'est pas&nbsp;vraiment&nbsp;compliqué. Pour le cas des MXBeans, cela est un peu plus sioux... mais globalement pas compliqué non plus ;-)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En effet, plusieurs cas se présentent :</div><ul><li style="text-align: justify;">Pour les <strong>MXBeans</strong> de types (type au sens propriété JMX) <strong><em>Compilation</em></strong>, <strong><em>ClassLoading</em></strong>, <strong><em>Memory</em></strong>, <strong><em>OperationSystem</em></strong>, <strong><em>Runtime</em></strong> et&nbsp;<strong><em>Threading</em></strong>, cela ne pose pas de problèmes puisque la spécification JMX nous dit qu'il n'y a qu'un seul MBean de ce type dans le <strong>MBeanServer</strong> pour domaine <em>java.lang</em>. Dans ce cas, il suffit juste d'instancier un proxy dynamique du MXBean lui-même et de l'enregistrer avec le "bon" <strong>ObjectName</strong>.</li><li style="text-align: justify;">par contre, pour les <strong>MXBeans</strong> de types <em><strong>MemoryPool</strong></em>, <em><strong>GarbageCollector</strong></em> et <em><strong>MemoryManager</strong></em>, vu qu'il peut y en avoir plusieurs, une recherche est effectuée (en limitant la recherche aux <strong>MBeans</strong> voulus bien sûr...) sur le <strong>MBeanServer</strong> distant afin d'obtenir (mais également d'instancier) le bon type de proxy dynamique mais également les bonnes propriétés sous lequel il est enregistré.</li></ul><pre class="brush:java; wrap-lines: false; auto-links: false">final private static Map&lt;String, Class&lt;?&gt;&gt; MXBEAN_MAP = new HashMap&lt;String, Class&lt;?&gt;&gt;();<br /> static {<br />  MXBEAN_MAP.put(ManagementFactory.COMPILATION_MXBEAN_NAME, CompilationMXBean.class);<br />  MXBEAN_MAP.put(ManagementFactory.CLASS_LOADING_MXBEAN_NAME, ClassLoadingMXBean.class);<br />  MXBEAN_MAP.put(ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);<br />  MXBEAN_MAP.put(ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME, OperatingSystemMXBean.class);<br />  MXBEAN_MAP.put(ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);<br />  MXBEAN_MAP.put(ManagementFactory.THREAD_MXBEAN_NAME, ThreadMXBean.class);<br />  MXBEAN_MAP.put("java.util.logging:type=Logging", LoggingMXBean.class);<br /> }<br /><br /> public RemoteMXBeanHandler() {<br /> }<br /><br /> public Object getRemoteMBean(final MBeanServerConnection mBeanServerConnection, final MBeanInfo mBeanInfo, final ObjectName distantObjectName)<br />   throws Exception {<br />  if (Boolean.parseBoolean((String) mBeanInfo.getDescriptor().getFieldValue("mxbean"))) {<br />   LOGGER.debug("current mxBeanInfo : {}", mBeanInfo);<br />   Object proxy = getMxBeanProxy(mBeanServerConnection, mBeanInfo, distantObjectName);<br />   return proxy;<br />  }<br />  return null;<br /> }<br /><br /> private Object getMxBeanProxy(final MBeanServerConnection mBeanServerConnection, final MBeanInfo mBeanInfo, final ObjectName distantObjectName)<br />   throws IOException {<br />  String distantName = distantObjectName.toString();<br />  int index = distantName.indexOf(",");<br />  String substring = distantName.substring(0, (index != -1) ? index : distantName.length());<br />  Class&lt;?&gt; mBeanClass = MXBEAN_MAP.get(substring);<br />  if (mBeanClass != null) {<br />   return ManagementFactory.newPlatformMXBeanProxy(mBeanServerConnection, distantName, mBeanClass);<br />  } else if (!StringUtils.equals(ManagementFactory.MEMORY_POOL_MXBEAN_DOMAIN_TYPE, substring)<br />    &amp;&amp; !StringUtils.equals(ManagementFactory.GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE, substring)<br />    &amp;&amp; !StringUtils.equals(ManagementFactory.MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE, substring)<br />    &amp;&amp; !StringUtils.contains(substring, "com.sun.management")) {<br />   return ManagementFactory.newPlatformMXBeanProxy(mBeanServerConnection, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);<br />  } else {<br />   return null;<br />  }<br /> }<br /><br /> private void handleSpecificMXBean(final MBeanServerConnection mBeanServerConnection) throws Exception {<br />  // cf. http://download.oracle.com/javase/6/docs/api/<br /><br />  // traitement particulier pour les MXBeans de type MemoryPoolMXBean<br />  registerOtherMxBean(mBeanServerConnection, ManagementFactory.MEMORY_POOL_MXBEAN_DOMAIN_TYPE, MemoryPoolMXBean.class);<br />  // traitement particulier pour les MXBeans de type MemoryManagerMXBean<br />  registerOtherMxBean(mBeanServerConnection, ManagementFactory.MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE, MemoryManagerMXBean.class);<br />  // traitement particulier pour les MXBeans de type GarbageCollector<br />  registerOtherMxBean(mBeanServerConnection, ManagementFactory.GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE, GarbageCollectorMXBean.class);<br /><br />  // traitement particulier pour les MXBeans de type Hotspot<br />  registerOtherMxBean(mBeanServerConnection, "com.sun.management:type=HotSpotDiagnostic", HotSpotDiagnosticMXBean.class);<br /> }<br /><br /> private void registerOtherMxBean(final MBeanServerConnection mBeanServerConnection, String type, Class&lt;?&gt; clazz) throws Exception {<br />  final ObjectName requestedObjectName = new ObjectName(type + ",*");<br />  final Set&lt;ObjectName&gt; objectNames = mBeanServerConnection.queryNames(requestedObjectName, null);<br />  for (ObjectName objectName : objectNames) {<br />   final Object proxy = ManagementFactory.newPlatformMXBeanProxy(mBeanServerConnection, objectName.getCanonicalName(), clazz);<br />   final ObjectName newObjectName = new ObjectName("remote:instance=" + address + ", " + "subdomain=" + objectName.getDomain() + ", "<br />     + objectName.getKeyPropertyListString());<br />   mbeanServer.registerMBean(proxy, newObjectName);<br />  }<br /> }<br /></pre><div style="text-align: justify;">Pour le cas particulier du <strong>MXBean</strong> <em><strong>HotspotDiagnostic</strong></em>, je vous laisse le soin de jeter un oeil sur le code... ;-)</div><h2 style="text-align: justify;">Désenregistrement d'une instance (et donc de ses MBeans associés)</h2><div style="text-align: justify;">Bien entendu, si une instance venait à disparaitre, il est nécessaire de désenregistrer ses <strong>MBeans</strong> pour chaque instance de l'application encore présente.</div><div style="text-align: justify;">Là encore, la principe est ultra-simple puisqu'il suffit de récupérer l'ensemble des MBeans qui se trouvent dans le domaine JMX "<em>remote</em>" (qui pour rappel est le domaine utilisé pour enregistrer tous nos proxy) avec la "bonne" propriété (à savoir la propriété "<em>instance</em>" qui doit valoir la valeur de l'adresse de l'instance à supprimer) et de les désenregistrer du <strong>MBeanServer</strong> local.</div><pre class="brush:java; wrap-lines: false; auto-links: false">void handleRemove() throws Exception {<br />  final ObjectName queryObjectName = new ObjectName(DOMAIN_REMOTE + ":instance=" + address + ",*");<br />  final Set&lt;ObjectName&gt; objectNames = mbeanServer.queryNames(queryObjectName, null);<br />  for (ObjectName objectName : objectNames) {<br />   LOGGER.debug("remove from mBeanServer objectName : {}", objectName);<br />   mbeanServer.unregisterMBean(objectName);<br />  }<br /> }<br /></pre><h1>Conclusion</h1><div style="text-align: justify;">On a vu tout au long de cette article comment il était possible d'utiliser JMX coté client (on récupère des <strong>MBeans</strong> distants) mais également coté serveur (on créé des <strong>MBeans</strong>). Bien sûr, la couche JGroups n'est qu'un prétexte mais je trouvais intéressant de pouvoir s'appuyer sur ce dernier pour être notifié de changement dans le système. Si je suis motivé, j'intégrerais peut être une implémentation NoSQL pour stocker et partager les JMXConnector ou un truc du genre... ;-)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Par contre, je n'ai pas testé le comportement dans le cas où des notifications seraient émises... en outre, si un service de <strong>Relation</strong> JMX était utilisé, je pense que cela pourrait poser quelques soucis...</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A noter que je suis tombé tout récemment sur <a href="http://blog.infin-it.fr/2010/08/05/aggregateur-jmx-2/">une autre solution</a> (que je n'ai pas testé) qui permet d'aggréger des informations JMX au sein d'un même serveur <strong>MBeanServer</strong>. La cible n'est pas tout à fait identique mais peut être suffisante pour la plupart des cas... par contre, il faut aimer Spring... ;-)</div><h1 style="text-align: justify;">Pour aller plus loin...</h1><ul><li style="text-align: justify;"><b>Site officiel de JGroups</b> :&nbsp;<a href="http://www.jgroups.org/">http://www.jgroups.org/</a> </li><li style="text-align: justify;"><b>Wiki de JGroups</b> :&nbsp;<a href="http://community.jboss.org/wiki/JGroups">http://community.jboss.org/wiki/JGroups</a></li></ul><div><div style="text-align: justify;"><br /></div></div><ul><li style="text-align: justify;"><b>Site de la JSR 3 -&nbsp;</b><em><b>Java Management Extensions (JMX) Specification</b>&nbsp;</em>:&nbsp;<a href="http://www.jcp.org/en/jsr/detail?id=3">http://www.jcp.org/en/jsr/detail?id=3</a></li><li style="text-align: justify;"><b>Site de la JSR 160 -&nbsp;</b><em><span class="Apple-style-span" style="font-style: normal;"><em><b>Java Management Extensions (JMX) Remote API</b></em></span>&nbsp;</em>:&nbsp;<a href="http://jcp.org/en/jsr/detail?id=160">http://jcp.org/en/jsr/detail?id=160</a></li><li style="text-align: justify;"><b>Site officiel d'Oracle sur JMX</b> :&nbsp;<a href="http://www.oracle.com/technetwork/java/javase/tech/docs-jsp-135989.html">http://www.oracle.com/technetwork/java/javase/tech/docs-jsp-135989.html</a></li></ul></div>
