<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jbi | Jetoile]]></title>
  <link href="https://blog.jetoile.fr/blog/categories/jbi/atom.xml" rel="self"/>
  <link href="https://blog.jetoile.fr/"/>
  <updated>2017-07-17T12:09:03+02:00</updated>
  <id>https://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring Integration vs. Apache Camel]]></title>
    <link href="https://blog.jetoile.fr/2010/03/spring-integration-vs-apache-camel.html"/>
    <updated>2010-03-15T23:29:48+01:00</updated>
    <id>https://blog.jetoile.fr/2010/03/spring-integration-vs-apache-camel</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/S56PashF4SI/AAAAAAAAAJA/OVagPG4D-g0/s320/apache_spring.png" alt="left-small" />
Lors d'un <a href="/2009/12/eip-quest-ce-que-cest.html">post précédent</a>, j'avais parlé des <a href="/blog/2009/12/13/eip-quest-ce-que-cest/">EIPs</a> (<strong>Enterprise Integration Patterns</strong>) en expliquant qu'il s'agissait de Patterns permettant de normaliser les échanges de messages dans un système asynchrone.</p>

<p>Dans cet article, je vais tenter de présenter succinctement deux de ses implémentations : <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> et [Apache Camel](<a href="https://camel.apache.org/.">https://camel.apache.org/.</a></p>

<p>En fait, pour être plus précis, je vais plutôt tenter de présenter la vision que j'en ai ainsi que la façon dont je les ai compris.</p>

<p>Ainsi, ce post n'a pas pour objectif de les détailler de manière exhaustive car ils sont trop complets pour cela et qu'un seul post ne pourrait suffire à les aborder tous les deux (leurs documentations font d'ailleurs, pour Spring Integration, plus de 130 pages, et pour Apache Camel, plus de 580 pages&hellip; cqfd&hellip; ;&ndash;) ) mais juste, comme je l'ai dit précédemment dit, d'aider à comprendre leurs différences (quelles soient conceptuelles ou structurelles).</p>

<p>Je ne reviendrai pas sur les concepts des EIPs ni de JBI que j'utiliserai dans la suite et pour cela, je vous renvoie sur internet ou sur mes posts précédents (<a href="/2009/12/eip-quest-ce-que-cest.html">ici</a> et <a href="/2009/12/jbi-une-solution-enterree.html">là</a>).</p>

<p>Concernant les versions utilisées, cela n'a pas vraiment son importance ici car je m'intéresserai surtout aux principes de ces deux frameworks mais à titre indicatif, il s'agit des versions 2.0 pour Apache Camel et 1.3.0 pour Spring Integration (il me semble qu'il n'y a pas de modifications flagrantes dans les versions courantes qui sont 2.2.0 pour Camel et 2.0.0.M2 pour Spring Integration).</p>

<!-- more -->


<h1>Les concepts</h1>

<h2>Apache Camel</h2>

<p>Apache Camel est un framework open-source qui est une implémentation des EIPs et qui propose pour sa configuration d'utiliser indifféremment :</p>

<ul>
<li>un fichier de configuration Spring (Spring DSL),</li>
<li>un DSL interne (Java DSL),</li>
<li>ou un DSL externe (Scala DSL).</li>
</ul>


<p>Cependant, il définit ses propres concepts qui diffèrent de ceux des EIPs mais qui restent assez similaires.</p>

<p>Ainsi, Apache Camel s'appuie sur la notion de routes (<strong>Route</strong>) qui relient deux points d'accès (<strong>Endpoint</strong>). Sur cette route transite des messages (<strong>Message</strong>) au travers d'échanges (<strong>Exchange</strong>). En fait un Exchange est le conteneur du message durant la phase de routage.</p>

<p>Ces points d'accès peuvent être de différents types et peuvent supporter différentes technologies telles que :</p>

<ul>
<li>une destination (Topic ou Queue) JMS,</li>
<li>un service web,</li>
<li>un fichier se trouvant sur le système de fichier,</li>
<li>un serveur FTP,</li>
<li>une adresse mail,</li>
<li>ou encore un POJO (<em>Plain Old Java Object</em>).</li>
</ul>


<p>Si l'on fait un parallèle avec JBI (<em>Java Business Integration</em>) (cf. <a href="/2009/12/jbi-une-solution-enterree.html">ici</a>), un <strong>Endpoint</strong> peut être vu comme une instance d'un <strong>Binding Component</strong>.</p>

<p>Une <strong>Route</strong> peut, quant à elle, être vue comme le chemin qu'emprunte le message d'un bout à l'autre de la chaîne de médiation. Ce chemin pouvant être entrecoupé par ce qu'on appelle des processeurs (<strong>Processor</strong>).</p>

<p>Apache Camel introduit également la notion de Composants (<strong>Component</strong>) à partir desquels les <strong>Endpoint</strong> sont issus (toujours pour faire un parallèle avec JBI, un <strong>Component</strong> peut être vu comme un <strong>Composant JBI</strong> en mode fournisseur ou consommateur).</p>

<p>Enfin, par composition à un <strong>Endpoint</strong>, Apache Camel utilise également les notions de <strong>Producer</strong> et <strong>Consumer</strong> qui permettent d'émettre (respectivement, recevoir) un message vers (resp. d') une application extérieure et qui peuvent être vu comme des <strong>Binding Component</strong> en mode fournisseur (resp. consommateur).</p>

<h1>Spring Integration</h1>

<p>Spring Integration appartient au portfolio de Spring Framework et étend le modèle de programmation de Spring mais dans le domaine de la messagerie. Il supporte l'architecture basée sur les messages (<em>Message-Driven Architecture</em>) où l'inversion de contrôle est utilisée pour les problématiques d'exécution comme, par exemple, quand doivent être appelés les composants métiers ou encore où doivent être envoyées les réponses. En outre, il offre des mécanismes de routage et de transformation de messages afin de permettre aisément l'utilisation de protocoles de transport et des types de messages hétérogènes. Il propose pour sa configuration d'utiliser soit un fichier de configuration Spring soit le mécanisme d'annotations.</p>

<p>Concernant ses concepts, ils collent parfaitement à ceux des EIPs puisque Spring Integration utilise la notion de :</p>

<ul>
<li><strong>Message</strong> dont la définition est identique à celle des EIPs,</li>
<li><strong>Message Channel</strong> dont la définition est identique à celle des EIPs,</li>
<li>et de <strong>Message Endpoint</strong> qui regroupe :

<ul>
<li>les Message Routing dont la définition est identique à celle de Routing des EIPs</li>
<li>les Message Transformation dont la définition est identique à celle de Transformation des EIPs</li>
<li>et les Message Endpoint dont la définition est identique à celle des EIPs</li>
</ul>
</li>
</ul>


<h1>Mon avis avant utilisation</h1>

<h2>Apache Camel</h2>

<p>Apache Camel est un framework issu de l'implémentation JBI Apache ServiceMix et qui est également utilisé dans OpenESB. Cela peut expliquer pourquoi ses concepts sont si proches de ceux de JBI (ou du moins que les modèles sont si facilement transposables). Cependant, à mon sens, même si ses concepts sont proches de ceux de JBI, les termes utilisés sont différents et, pour ceux qui connaissent JBI, un effort d'apprentissage supplémentaire doit être fait. En outre, la documentation d'Apache Camel est loin d'être aisée à lire et retrouver de l'information dans le wiki qui lui sert de documentation s'achèvent généralement avec des cheveux en moins, une souris torturée ou un écran ébréché&hellip; le tout accompagné par une flopée d'injures&hellip;</p>

<p>Ainsi, à mon avis, pour un produit qui se veut être une implémentation des EIPs, il faut :</p>

<ul>
<li>d'une part, lire ou se familiariser avec les EIPs</li>
<li>et d'autre part, connaitre JBI ou, au moins, se familiarisé avec les concepts d'Apache Camel (comprendre la différence entre un composant, un endpoint qui est lui-même un processeur, les éléments pipeline et multicast qui sont eux-même des processeurs, etc, etc, etc&hellip;). Rien d'insurmontable mais il est quand même nécessaire de se faire quelques nœuds au cerveau&hellip;</li>
</ul>


<p>Par contre, par rapports aux EIPs, Apache Camel masque la notion de Channel, ce qui peut s'avérer plaisant.</p>

<h2>Spring Integration</h2>

<p>Spring Integration est un projet du portfolio Spring donc très propre, avec une documentation très bien faite et pas trop longue&hellip; En outre, pour quelqu'un qui est déjà familiarisé avec les EIPs, la prise en main de Spring Integration est immédiate. Le fait qu'il s'appuie sur Spring (tout comme Apache Camel d'ailleurs) permet une courbe d'apprentissage rapide.</p>

<h1>Mon avis après utilisation</h1>

<h2>Apache Camel</h2>

<p>Apache Camel s'avère ardu à prendre en main malgré un forum actif. Cela en raison de sa documentation un peu (complètement?) fouillis mais également parce qu'il est possible de faire la même chose de multiples manières, ces manières ayant chacunes ses limitations. Si on utilise le framework simplement avec une description XML et des POJOs (qui sont, parfois, fortement couplé au framework Apache Camel au travers de son API (Exchange, Endpoint, &hellip;) &hellip; pas très propre tous ça&hellip; :( ), on peut arriver sans trop de douleur à faire ce que l'on veut. Par contre, si on se lance dans les DSLs internes ou externes (et même si j'aime bien le principe des DSLs&hellip;), cela n'exclue pas l'adhérence des POJOs à l'API d'Apache Camel et il est souvent nécessaire de faire intervenir la notion d'Exchange dans les signatures des méthodes.</p>

<p>En outre, on se rend rapidement compte que la majorité des classes de l'API héritent de l'interface <code>Processor</code>. Pourquoi cela me pose problème? et bien parce que j'estime qu'il est bizarre et peu naturel que certaines classes comme Pipeline ou MulticastProcessor implémente (directement ou indirectement) Processor ou alors il aurait, au moins, été préférable de mettre ce type de classes dans un autre package que celui où se trouvent des classes comme Aggregator, FileProcessor, Resequencer ou encore RecipientList. Bon, je comprends qu'Apache Camel a été pensé dès le départ pour offrir une configuration simple à base de DSL et que, du coup, il a été nécessaire de faire certaines concessions mais lorsque l'on rentre dans le code du framework, ce n'est pas (et cela ne concerne que moi) une impression de propreté qui en ressort&hellip;</p>

<p>Un autre point qui m'interpelle est le fait que lors de l'écriture des règles de médiations, il n'y a pas de différences sémantiques entre les différentes notions qu'offrent les EIPs : les Message Transformation, Message Routing ou Service Activator se représentent tous comme des Processor ou des Bean. Je trouve cela dommage de perdre la classification (qu'on aime ou pas) fournit par les EIPs et qui, à mon sens, permettait justement de clarifier toutes les notions utiles pour gérer les échanges de messages dans un système asynchrone.</p>

<p>Par contre, comme je l'ai dit précédemment, il est vraiment appréciable de ne pas à avoir à déclarer ses propres Channels qui sont masqués par la notion de Route.</p>

<h2>Spring Integration</h2>

<p>Spring Integration est extrèmement simple à prendre en main et son forum est très actif. La documentation est claire et c'est vrai qu'il est appréciable de pouvoir utiliser les notions des EIPs directement.</p>

<p>Les annotations sont parlantes et les éléments (service-activator, splitter, filter, resequencer, aggregator, transformer, router, &hellip;) à utiliser dans le fichier de configuration Spring permettent de classifier rapidement les différents éléments se trouvant dans la chaine de médiations.</p>

<p>En outre, le code interne du framework est propre et permet de masquer la complexité des différents Message Endpoint.</p>

<h1>Conclusion</h1>

<p>Vous l'aurez compris, j'ai une petite préférence pour Spring Integration&hellip;</p>

<p>Cependant, je dirai que le choix dépend aussi grandement de l'utilisation qu'on veut en faire (bon ok, je ne me mouille pas trop&hellip; ;&ndash;) ) :</p>

<ul>
<li>dans un ESB type ServiceMix ou OpenESB, il peut être préférable d'utiliser Apache Camel en raison de sa capacité à être configurée via un DSL qui peut être plus aisé que de manipuler des Channels et des fichiers XML,</li>
<li>par contre, pour les autres cas, je conseillerai plutôt Spring
Integration pour son modèle de programmation et ses concepts plus
simple&hellip;</li>
</ul>


<p>mais là, je conseillerai à chacun de se faire sa propre idée&hellip;</p>

<p>Un petit mot en plus sur les points non abordés ci-dessus :</p>

<ul>
<li>les mécaniques offertes pour manipuler des messages au format XML (XPath, &hellip;),</li>
<li>la gestion des erreurs,</li>
<li>le nombre de connecteurs fournis par ces derniers.</li>
</ul>


<p>Sur ces deux derniers points, l'avantage va indéniablement à Apache Camel même s'il est aisé (modulo la connaissance du protocole utilisé) d'en redéfinir avec Spring Integration en utilisant un Service Activator mais, dans ce cas, il faut le faire à la main.</p>

<p>Pour le premier point, je ne dirai rien car je n'ai pas eu l'occasion de l'utiliser&hellip;</p>

<p>Enfin, il ne faut pas oublier que ces frameworks ont pour but principal d'offrir un moyen de faire de la médiation technique et non de gérer une orchestration de processus métier et que pour cette raison, ils doivent être utilisés à bon escient.</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li><strong>SOA : le guide de l’architecte</strong> de X. Fourner-Morel, P. Grojean, G. Plouin et C. Rognon chez Dunod</li>
<li><strong>Enterprise Integration Patterns</strong> de G. Hohpe et B. Woolf chez Addisson Wesley</li>
<li>Site de Spring Integration : <a href="http://www.springsource.org/spring-integration">http://www.springsource.org/spring-integration</a></li>
<li>API de Spring Integration : <a href="http://static.springframework.org/spring-integration/apidocs/">http://static.springframework.org/spring-integration/apidocs/</a></li>
<li>Manuel de référence de Spring Integration : <a href="http://docs.spring.io/spring-integration/docs/4.0.0.M3/reference/html/">http://docs.spring.io/spring-integration/docs/4.0.0.M3/reference/html/</a></li>
<li>Site d'Apache Camel : <a href="http://camel.apache.org/">http://camel.apache.org/</a></li>
<li>API d'Apache Camel : <a href="http://camel.apache.org/javadoc.html">http://camel.apache.org/javadoc.html</a></li>
<li>Manuel de référence d'Apache Camel : <a href="http://camel.apache.org/manual.html">http://camel.apache.org/manual.html</a></li>
<li>Spécification de JBI : <a href="http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html">http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html</a></li>
<li>Blog de Xebia sur les ESB légers : <a href="http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/">http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/</a></li>
<li>Blog de Xebia sur une revue de presse d'un article sur Spring Integration et Apache Camel : <a href="http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel">http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JBI : Qu'est ce que c'est?]]></title>
    <link href="https://blog.jetoile.fr/2009/12/jbi-une-solution-enterree.html"/>
    <updated>2009-12-07T09:58:58+01:00</updated>
    <id>https://blog.jetoile.fr/2009/12/jbi-une-solution-enterree</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/SyioXBC9u0I/AAAAAAAAAII/DM5NReY1mJ4/s200/jbi.png" alt="left" />
Voilà mon premier article. Il a pour objectif de présenter JBI (<em>Java Business Service</em>) aussi connue sous le doux nom de JSR 208 (<em>Java Specification Release</em>).</p>

<h1>Pourquoi un article sur JBI?</h1>

<p>Vous pouvez vous demander pourquoi un article sur JBI? Les réponses sont simples : j'aime bien cette spécification et je trouve qu'elle a du potentiel et qu'elle est sous exploitée.</p>

<p>Bien sûr, me direz-vous, en tant qu'utilisateur d'un PEtALS ou ServiceMix, pourquoi devrais-je comprendre la technologie sous-jacente? Eh bien, c'est une affaire de goût : si vous préférez utiliser un produit comme une boite noire, passer votre chemin. Par contre, si vous voulez comprendre ce qui se passe à l'intérieur, j'espère que cet article pourra répondre à vos attentes.</p>

<p>Autre interrogation : pourquoi m'embêter à comprendre une technologie qui ne décolle pas (du moins de ma fenêtre) et sur laquelle les éditeurs ne communiquent pas énormément (c'est vrai qu'ils préfèrent communiquer sur ce qu'ils offrent et non comment ils le font) ? Là encore, question de goût et puis qui croyait en l'émergence du téléphone portable ou même de la télé réalité ? (personnellement, je ne croyais ni en l'un ni en l'autre&hellip;) cqfd&hellip; ;&ndash;)</p>

<p>Ce premier article a donc pour objectif de présenter JBI. Seront abordés ses concepts généraux avec une approche telle que celle décrite dans ses spécifications ainsi qu'un succinct retour sur ce que je pense de JBI..</p>

<p>Cependant, ne seront pas abordés, ici, les mécanismes utilisés en son sein ainsi que des notions de SOA (de très bon article abordent déjà SOA) même si, qui dit JBI dit SOA (la réciproque n'est pas foncièrement vrai&hellip;).</p>

<p>Il est à noter que dans cet article j'utiliserai souvent le terme de composant (peut être à mauvais escient) au lieu du terme service. Il s'agit d'un abus de langage lié au fait que j'ai tenté d'être le plus clair possible et que en évitant d'aborder trop de notions afin d'éviter de vous perdre ;&ndash;).</p>

<!-- more -->


<h1>JBI : Qu'est ce que c'est?</h1>

<p>JBI (<em>Java Business Integration</em>) est définie dans sa première version par la JSR (<em>Java Specification Release</em>) 208. Elle a pour objectif de proposer une solution d'intégration de composants métiers et définie une norme pour l'assemblage des moyens d'intégration de composants.</p>

<p>JBI peut être vue comme le conteneur de service des ESB (<em>Enterprise Service Bus</em>)</p>

<blockquote><p>JBI defines what is sometimes termed a “service container” in Enterprise Service Bus (ESB) systems(&hellip;). &ndash; JBI_Spec</p></blockquote>

<p>et aborde l'intégration de composants métiers d'un point de vue infrastructure.</p>

<p>Il s'agit d'une spécification et doit donc être implémentée par ce que je nommerai dans le reste de cet article un JBI Provider.</p>

<p>Elle peut être vue comme une solution concurrente de SCA (<em>Service Component Architecture</em>), cependant, il n'en est rien : alors que SCA aborde l'intégration de composants d'un point de vue applicatif, JBI l'arborde d'un point de vue infrastructure. Cela en fait donc un très bon candidat pour héberger une solution basée sur SCA. Ces deux solutions doivent donc être vue comme complémentaires et non comme concurrentes.</p>

<p>JBI s'appuie sur des technologies web comme les WSDL (<em>Web Service Description Language</em>) pour la description des composants (nous verrons plus tard dans que cette notion de composant se trouve une notion de service) ou le XML (<em>eXtensible Markup Language</em>) pour l'échange des messages.</p>

<p>Si je devais définir JBI en une phrase, je dirais qu'il s'agit d'une spécification visant à définir un conteneur de conteneurs pour offrir une solution normalisée pour l'intégration de composants métiers. Les conteneurs étant des composants qui hébergent les services que nous verront plus tard.</p>

<h1>Concepts</h1>

<p>Cette partie tentera d'expliquer ses concepts qui, je pense, sont nécessaires pour comprendre son fonctionnement et utiliser une solution basée sur JBI.</p>

<h2>Fonctionnement général</h2>

<p>Un environnement JBI expose des services qui interagisent entre eux via un échange asynchrone de message au format XML. Cela permet un couplage faible entre les services. De plus, afin de découpler encore plus l'échange de messages, c'est l'environnement qui est chargé de les router. En fait, les services sont hébergés au sein de composants, mais c'est l'objet des paragraphes suivants&hellip; ;&ndash;)</p>

<h2>Notion de composants JBI</h2>

<p>JBI définit deux types de composants :</p>

<ul>
<li>Les Service Engine (SE) qui sont des composants qui fournissent la logique métier et des services de transformation aux autres composants. Ils peuvent également être consommateur (nous reviendront sur la notion de consommateurs et de producteurs) d’autres SEs.</li>
<li>Les Binding Component (BC) qui sont des composants qui assurent la connectivité pour les services extérieurs à l’environnement JBI. Cela peut impliquer les protocoles de communication ou des services fournis par le SI de l’entreprise.</li>
</ul>


<p>Il est à noter que dans la première version de JBI, la différence entre les SE et les BC est purement conceptuelle puisqu'il n'existe pas de différence de traitement entre l'un ou l'autre</p>

<blockquote><p>Service engines and binding components can function as service providers, consumers, or both. (The distinction between SEs and BCs is purely pragmatic, but is based on sound architectural principles. The separation of business (and processing) logical from communications logic reduces implementation complexity, and increases flexibility.) &ndash; JBI_Spec.</p></blockquote>

<p>Afin de clarifier la notion de composant (SE ou BC), voici une liste de composants (cette liste n'est pas exhaustive et est spécifique au JBI Provider : rien n'est dit à ce propos dans la spécification) :</p>

<ul>
<li><p>exemple de SE :</p>

<ul>
<li>SE XSLT (<em>eXtensible Stylesheet Language Transformations</em>) qui permet d’appliquer une transformation d’un fichier/message XML à partir d’une feuille de style XSL,</li>
<li>SE Validator qui permet de valider un message grâce à son XSD,</li>
<li>SE CSV (<em>Comma-Separated Value</em>) qui permet de transformer un document au format CSV en document au format XML,</li>
<li>SE EIP (<em>Enterprise Integration Pattern</em>) qui permet d’implémenter certains patrons d’intégration d’entreprise,</li>
<li>SE JSR181 (<em>Web Services Metadata for the java Platform</em>) qui permet d’exposer un POJO (Plain Old Java Object) annoté comme un service JBI,</li>
<li>SE POJO (<em>Plain Old Java Object</em>) qui permet de déployer des classes Java comme des services,</li>
<li>SE BPEL (<em>Business Process Execution Language</em>) qui permet d'offrir un moteur d'exécution BPEL,</li>
<li>SE SCA (<em>Service Component Architecture</em>) qui permet d'offrir une implémentation de SCA,</li>
<li>&hellip;</li>
</ul>
</li>
<li><p>exemple de BC :</p>

<ul>
<li>BC FileTransfert qui permet d’envoyer et de recevoir des fichiers,</li>
<li>BC FTP (<em>File Transfert Protocol</em>) qui permet le transfert et le listage de fichiers sur un serveur ftp,</li>
<li>BC JMS (<em>Java Message Service</em>) qui permet de s’interconnecter avec des Destinations (Queue/Topic) extérieures,</li>
<li>BC SMTP qui permet d’émettre et de recevoir des fichiers d’un service de mail extérieur,</li>
<li>BC SOAP (<em>Simple Object Access Protocol</em>) qui permet de s’interconnecter avec un service Web extérieur afin d’exposer des services JBI comme des services Web,</li>
<li>BC XMPP (<em>eXtensible Messaging and Presence Protocol</em>) qui permet de s’interconnecter avec le protocole XMPP qui est un protocole standard de messagerie instantané (Google Talk, Jabber, …),</li>
<li>&hellip;</li>
</ul>
</li>
</ul>


<p>Un composant JBI se présente sous forme de fichier zippé et doit être installé dans l'environnement JBI (en fait, dans ce fichier zip, des informations contenues dans le fichier jbi.xml se trouvant dans le répertoire META-INF spécifie le composant -cycle de vie &amp; co. &ndash;).</p>

<h2>Notion de Service Unit et Service Endpoint</h2>

<p>Les composants JBI (SE ou BC) offrent un comportement général et leur utilisation est spécifique au besoin : par exemple, la réception de Messages JMS ne se fait pas toujours sur la même Destination et cela doit être configurable. De même, un fichier XML est considéré comme valide via son schéma XSD. Aussi il est nécessaire de configurer ces composants. C'est pour cette raison qu'ils peuvent être vus comme des conteneurs. Cette étape où à un composant générique (comme un BC File System) est associé sa spécificité (dire au BC File System qu'il doit scruter un répertoire particulier) est appelée configuration du composant. C'est suite à sa configuration qu'un composant expose un service en tant que tel.</p>

<p>De plus, il ne faut pas oublier que le but premier de JBI est d'offrir des possibilités d'assemblage : l'environnement JBI offre un certain nombre de &ldquo;meta-services&rdquo; au reste du monde qui est un assemblage d'autres services qui sont hébergés en son sein ou non. Pour ce faire, une notion de services fournisseurs (provider) et de services consommateurs (consumer) a été introduite :
* un service provider permet d'intégrer un service dans l’environnement JBI
* un service consumer permetd'exposer un service dans l’environnement JBI
Cette spécificité du service est également faite lors de la phase de configuration du composant.</p>

<p>En fait, la notion de fournisseur et de consommateur doit être vu du point de vue de l'environnement JBI. Par exemple, afin d'offrir un service disponible qui écoute sur la Queue JMS &ldquo;myQueue&rdquo;, il faut donc configurer le composant BC JMS (dans le cas du JBI Provider PEtALS) comme consommateur en lui fournissant le nom de la Queue qu'il écoute. De même, si un service doit être utilisé par un autre service de l'environnement JBI, il doit être défini comme fournisseur (en fait, plus techniquement, un service fournisseur est enregistré dans l'annuaire interne de l'environnement JBI et peut ainsi être utilisable par d'autres services alors qu'un service consommateur n'est pas accessible à d'autres services de l'environnement JBI).</p>

<p>Cette phase de configuration est faite via un <em>Service Unit</em> (SU). Ainsi, pour résumer, un composant JBI dans l'environnement JBI ne fait rien et doit être configuré via un ou des SU pour exposer un ou des services. C'est pour cette raison que j'ai préalablement définie JBI comme un conteneur de conteneurs : un composant JBI peut être vu comme un conteneur de service (un peu comme un conteneur de servlet qui, en soit, ne fait rien mais dans lequel des servlets doivent être déployées afin qu'il offre une réelle utilitée).</p>

<p>Cependant, une autre question peut se poser : comment sont accessibles les composants JBI configurés comme provider&hellip; ? En fait, le SU permet de définir le endpoint (appelé ServiceEndpoint) par lequel le service exposé par le composant sera accessible. Inversement, un composant JBI configuré comme consumer doit préciser avec quel(s) service(s) il interagit (n'oublions pas que les services ont besoin de communiquer entre eux). Cela est fait également via les endpoints.</p>

<p>Plus concrètement, un SU se présente sous forme d'un fichier zippé et doit être déployé sur un composant JBI (en fait, dans ce fichier zip doit se trouver un fichier jbi.xml dans le répertoire META-INF qui précise s'il est fournisseur -et dans ce cas, son endoint- ou s'il est consommateur -et dans ce cas, le ou les endpoint avec le(s)quel il interagit-). Les autres informations nécessaires à la configuration du service doivent également être présentent dans le SU : un SU permet donc de configurer un composant (SE ou BC) afin de lui fournir une logique de fournisseur ou de consommateur ainsi que son ServiceEndpoint associé. Il permet également de fournir d’autres informations au composant comme le répertoire d’écoute (dans le cas d’un BC consommateur) ou d’écriture (dans le cas d’un BC fournisseur) pour le BC transfert de fichiers (BC permettant de scruter un répertoire pour lire les fichiers qui y sont déposés ou permettant d’écrire dans ce répertoire).</p>

<h1>Notion de Service Assembly</h1>

<p>Dans les paragraphes précédents, ont été introduit les notions de componsants JBI, de services (au sens JBI) et de ServiceEndpoint : il a été vu qu'un composant doit être configuré par un SU qui lui offre la notion de service via la déclaration (entre autres) de ses endpoint.</p>

<p>En fait, pour déployer un SU dans l’environnement JBI, il faut utiliser un SA (<em>Service Assembly</em>) dans lequel est indiqué quel(s) SU(s) configure(nt) un composant donné. Ce SA contient également les SU (un SU ne peut être déployé directement et doit l'être au travers d'un SA).</p>

<h1>Notion de Normalized Message Router</h1>

<p>En introduction, il a été dit que c'était l'environnement JBI qui avait à sa charge l'émission des messages transitant entre services. En fait, c'est le routeur de messages normalisés (<em>Normalized Message Router</em>) qui reçoit les messages échangés et qui les redirige vers leurs destinataires respectifs. C'est lui qui permet de découpler les fournisseurs de service et les consommateurs de service.</p>

<p>En outre, il est essentiel de noter que dans les spécifications il est dit que quand un message échangé est routé par le fournisseur de service, il doit toujours être renvoyé au composant initiateur de l’échange :</p>

<blockquote><p>&ldquo;When a message exchange is routed from the service provider, it MUST always be sent to the component that originated the exchange. Subsequent sending of the exchange from the consumer to provider MUST always send the exchange to the provider endpoint selected during the initial send of the exchange&rdquo; &ndash; JBI_Spec</p></blockquote>

<p>Cela implique qu'il n'est pas possible de chainer directement les appels entre les services (en fait, techniquement, cela est possible mais les composants deviendraient alors fortement couplé ce qui est contraire à la philosophie JBI et SOA) : un composant (qui est alors un SE) doit donc être garant de la médiation des messages.</p>

<p>Ce composant JBI chargé d'offrir la notion de médiation entre les messages (cela sort du périmètre des spécifications JBI) est généralement fourni par les JBI Provider et est implémenté de manière spécifique :
* le JBI Provider PEtALS de EBM Websourcing propose son propre composant SE EIP,
* et les JBI Provider OpenESB de Sun et ServiceMix d'apache utilise un SE basé sur apache Camel.</p>

<p>En fait, les SE EIP ou le SE apache Camel s'appuient sur les EIP (<em>Enterprise Integration Patterns</em>) qui sont des designs pattern pour tous ce qui est l'échange de message asynchrone (un article sera fait ultérieurement sur ce point).</p>

<p>De plus, en fonction du type de messages, le Normalized Message Router (NMR) offre une gestion de qualité de service variable :
* stratégie meilleur effort : les messages peuvent être perdus ou délivrés plus d’une fois,
* stratégie au moins un : les messages peuvent être perdus mais ne peuvent pas être délivrés plus d’une fois,
* stratégie un et un seul : les messages sont assurés d’être délivrés une et une seule fois.</p>

<p>Ainsi, pour résumer, on peut dire que le NMR joue le rôle de médiateur dans l'environnement JBI (en fait, dans l’environnement JBI, les messages sont normalisés et encapsulés par les composants dans un MessageExchange (ME) contenant des propriétés (metadata) afin d’être envoyés d’un composant à un autre. Les BCs et SEs interagissent avec le routeur de messages normalisés via un DeliveryChannel qui est bidirectionnel. En outre, il est possible d’associer des pièces jointes aux MEs).</p>

<h2>Message Exchange Patterns (MEP)</h2>

<p>Un JBI Provider permet d'émettre et de recevoir des messages (ME) entre les divers services qu'il héberge au travers de composants. En fait, ces transmissions de messages suivent certains patterns qui sont définis au nombre de 4 (en fait, ce nombre n'est pas imposé et chaque JBI Provider est libre d'un offrir plus) :</p>

<ul>
<li>In-Only</li>
</ul>


<p><img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SxzF-Wzfz_I/AAAAAAAAAEc/2_KfWG0qdqY/s400/Image1.png" alt="center" /></p>

<ul>
<li>In-Out</li>
</ul>


<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/SxzGH7vqLXI/AAAAAAAAAEs/6Hv5OsZS3pI/s400/Image3.png" alt="center" /></p>

<ul>
<li>In-Optional Out</li>
</ul>


<p><img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SxzGO2sFd7I/AAAAAAAAAE0/xjnLA3PIHjY/s400/Image4.png" alt="center" /></p>

<ul>
<li>Robust In-Only</li>
</ul>


<p><img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SxzGDeqLnjI/AAAAAAAAAEk/wRFwV4IanRM/s400/Image2.png" alt="center" /></p>

<p>En fait, ce pattern d'échange (Message Exchange Pattern &ndash; MEP- ) est positionné par le composant émetteur (ou plutôt, pour être plus précis, par sa configuration et donc le SU), et c'est au composant recevant le message de préciser les patterns qu'il supporte et comment il les supporte (par exemple, un BC JMS en mode fournisseur ne fournit pas de réponse s'il ne fait qu'émettre. Aussi, les MEPs qu'il supporte ne peuvent être que In-Only ou Robust In-Only).</p>

<h1>Cycle de vie des composants, SU et SA</h1>

<p>Jusque là, les chapitres précédents ont traité les notions et concepts apportés par les spécifications JBI. Parmi ces notions, nous avons vu qu'il existait réellement trois &ldquo;objets&rdquo; manipulables : les composants JBI, les SUs et les SAs.</p>

<p>En fait, ces trois &ldquo;objets&rdquo; disposent de leur propre cycle de vie :</p>

<ul>
<li>Cycle de vie du composant JBI</li>
</ul>


<p><img src="http://1.bp.blogspot.com/_XLL8sJPQ97g/SxzHqws3v5I/AAAAAAAAAE8/msIKJNQ0FDs/s200/Image6.png" alt="center" /></p>

<ul>
<li>Cycle de vie du SU</li>
</ul>


<p><img src="http://2.bp.blogspot.com/_XLL8sJPQ97g/SxzHy5e8r5I/AAAAAAAAAFE/9TDIzCLqN-U/s200/Image5.png" alt="center" /></p>

<ul>
<li>Cycle de vie du SA</li>
</ul>


<p><img src="http://2.bp.blogspot.com/_XLL8sJPQ97g/SxzHy5e8r5I/AAAAAAAAAFE/9TDIzCLqN-U/s200/Image5.png" alt="center" /></p>

<p>Un composant JBI doit être démarré pour être fonctionnel.</p>

<p>Il en est de même pour SU. Cependant, étant contenu dans un SA, il suit, en fait, le même cycle de vie que ce dernier.</p>

<p>La procédure consistant à installer un composant JBI dans l'environnement s'appelle installation, alors que la procédure consistant à déployer un SU dans un composant (au travers d'un SA) s'appelle déploiement.</p>

<h2>Features</h2>

<p>Dans les précédents paragraphes, nous avons survolé les notions utilisées par JBI. Cependant, les spécifications JBI apportent également des précisions sur les points suivants :
* JMX (<em>Java Management eXtension</em>) : un JBI Provider doit fournir une interface (au sens Java du terme) JMX d'administration
* Ant : un JBI Provider doit offrir des targets Ant pour gérer le cycle de vie des composants (installation/déploiement, démarrage, arrêt, désinstallation/undeployment)
* Shared Library : ce composant non abordé précédemment est une sorte de bundle contenant des librairies accessible de tout l'environnement JBI. Il dispose de son propre cycle de vie (installation, désinstallation) et permet, pour simplifier, un mécanisme de chargement/déchargement dynamique de librairie au sein de l'environnement.</p>

<h1>Avis sur JBI</h1>

<p>Ce paragraphe fait un retour de mon humble avis sur JBI. Je n'aborderai pas ici ses implémentations comme PEtALS, ServiceMix ou OpenESB puisque de très bon articles existent déjà et qu'ils couvrent bien mieux que je ne saurai le faire leurs prises en main et la description de leurs spécificités.</p>

<h2>Points faibles</h2>

<h3>EIP Provider</h3>

<p>Dans les spécifications, une phrase doit vraiment marquer le lecteur :</p>

<blockquote><p>&ldquo;When a message exchange is routed from the service provider, it MUST always be sent to the component that originated the exchange. Subsequent sending of the exchange from the consumer to provider MUST always send the exchange to the provider endpoint selected during the initial send of the exchange&rdquo; &ndash; JBI_Spec</p></blockquote>

<p>Cette simple citation a de grosses conséquences quant à l'utilisation de JBI : en effet, elle impose qu'il est nécessaire de déléguer à un composant tierce la gestion du chaînage d'appels, du routage, du filtrage, &hellip;</p>

<p>En effet, l'une des forces de JBI est d'offrir un environnement où les composants sont faiblement couplés et dialoguent de manière asynchrone grâce au NMR (entre autre) et il est important de ne pas oublier que JBI permet d'intégrer des composants métiers. Ces services métiers sont cependant hétérogènes et peuvent ne pas parler exactement le même dialecte. Aussi, ils ont besoin de médiation (routage, filtrage, transformation, &hellip;) et donc de mécanismes tels que ceux décrits par les EIP (Enterprise Integration Pattern) qui décrivent des patterns pour la gestion des échanges asynchrones. Cependant, ce mécanisme n'est pas directement utilisable (puisque la réponse doit toujours être réémise à l'émetteur du message) et un composant spécifique doit être utilisé.</p>

<p>Il peut s'agir, dans le cas de ServiceMix ou OpenESB, du composant SE Camel ou, dans le cas de PEtALS, du SE EIP. Cela apporte un surcouche supplémentaire et un point de contension au système. En outre, cela peut sembler peu naturel.</p>

<p>En outre, l'implémentation du SE EIP diffère en fonction du JBI Provider et on peut ne pas l'aimer (pour ma part, je n'aime pas du tout Apache Camel&hellip; mais cela fera l'objet d'un article ultérieur&hellip;).</p>

<p>Du coup, j'aurai envie de dire que sur ce point, JBI a oublié son but premier en ne couvrant pas ce point essentiel.</p>

<p>En outre, les solutions offertes par les JBI Provider peuvent manquer de maturité (question de point de vue) et surtout, pour l'instant, d'une norme pour les utiliser de manière plus <em>user-friendly</em>.</p>

<p>Bien sûr, un moteur SCA, BPEL ou BPMN pourrait répondre à ce besoin mais ils ne couvrent pas le même besoin (qui sont plus applicatifs que techniques) et cela sort du scope de JBI et donc de cet article.</p>

<h3>Qui fait quoi?</h3>

<p>Les composants JBI sont tous spécifiques et doivent être compris par l'utilisateur. Cela peut, du coup, être un peu repoussant et demander une recherche de la documentation.</p>

<h3>Portage des composants JBI d'un JBI Provider à l'autre</h3>

<p>Sur le papier les composants JBI doivent pouvoir être installés sur n'importe quel JBI Provider. En fait, cela n'est pas tout à fait exacte et pour en porter un, il faut parfois s'arracher les cheveux. En outre, il ne faut pas oublier qu'un composant JBI doit être configuré (via un SU) pour être utilisable, et généralement, le déploiement d'un SU sur un composant qu'on a réussi à installer (c'est déjà pas mal&hellip;) sur un JBI Provider tierce s'avère être également peu aisé&hellip;</p>

<h2>Points forts</h2>

<p>Le point fort de JBI est, de mon point de vue, qu'il offre un conteneur de conteneurs.</p>

<p>En outre, il existe un grand nombre de ces conteneurs (au sens composants JBI du terme) offerts par les différents JBI Provider et généralement, ils peuvent suffire à répondre au besoin.</p>

<p>Si tel est le cas, une utilisation d'un JBI Provider s'avère simple (il suffit de copier/coller le composant JBI, de le configurer via l'écriture d'un SU et de le déployer en copiant/collant le SA qui contient le SU).</p>

<p>En fait, dans ce cas, le plus gros du travail est la configuration des composants JBI et donc l'écriture d'un fichier XML.</p>

<h1>Conclusion</h1>

<p>Suite à cet article, la question qui peut se poser est : Ai-je vraiment besoin de JBI ? En fait, j'aurai envie de dire que cela dépend du besoin. Si le besoin est la mise en place d'une grosse infrastructure qui doit être déployée sur plusieurs sites/noeuds, une implémentation JBI peut être un bon choix. Par contre, si les besoins sont plus des problématiques de médiation au sein d'un controlleur, alors un simple EIP Provider (tel que Apache Camel, Spring Integration ou Mule iBeans) suffit.</p>

<p>En conclusion, je pense que pour pouvoir utiliser pleinement un ESB basé sur JBI, il est important d'avoir un minimum de connaissance de JBI et cela, même si les JBI Provider préfèrent communiquer plus sur ce que peut apporter leur produit que sur le comment (mais cela est normal au final&hellip; ).</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li><strong>SOA : le guide de l’architecte</strong> de X. Fourner-Morel, P. Grojean, G. Plouin et C. Rognon chez Dunod</li>
<li><strong>Enterprise Integration Patterns</strong> de G. Hohpe et B. Woolf chez Addisson Wesley</li>
<li>Spécification de JBI : <a href="http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html">http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html</a></li>
<li>Site de PEtALS : <a href="http://petals.objectweb.org/">http://petals.objectweb.org/</a></li>
<li>Site de ServiceMix : <a href="http://servicemix.apache.org">http://servicemix.apache.org</a></li>
<li>Article du site InfoQ sur la problématique de médiation/orchestration avec JBI : <a href="http://www.infoq.com/articles/louis-dutoo-esb-routing">http://www.infoq.com/articles/louis-dutoo-esb-routing</a></li>
<li>Article du site JDJ sur JBI et ServiceMix : <a href="http://java.sys-con.com/node/117740">http://java.sys-con.com/node/117740</a></li>
<li>Article du site JavaWorld sur ServiceMix : <a href="http://www.javaworld.com/javaworld/jw-12-2005/jw-1212-esb.html">http://www.javaworld.com/javaworld/jw-12-2005/jw-1212-esb.html</a></li>
<li>Article du blog de Chip Overclock sur JBI : <a href="http://coverclock.blogspot.com/2007/01/fun-facts-to-known-and-tell-java.html">http://coverclock.blogspot.com/2007/01/fun-facts-to-known-and-tell-java.html</a></li>
<li>Article du site de Architect zone sur ServiceMix : <a href="http://architects.dzone.com/articles/pattern-based-development-with-0">http://architects.dzone.com/articles/pattern-based-development-with-0</a></li>
<li>Article du site Java World sur une étude de cas avec ServiceMix : <a href="http://www.javaworld.com/javaworld/jw-09-2006/jw-0904-jbi.html">http://www.javaworld.com/javaworld/jw-09-2006/jw-0904-jbi.html</a>
<a href="http://opensourceesb.blogspot.com/2007/10/using-petals-jbi-components-in.html">http://opensourceesb.blogspot.com/2007/10/using-petals-jbi-components-in.html</a></li>
<li>Site de OSOA (Open Service Oriented Architecture) : <a href="http://www.osoa.org/display/Main/Service+Component+Architecture+Home">http://www.osoa.org/display/Main/Service+Component+Architecture+Home</a></li>
<li>Blog de The Server Labs sur JBI et SCA : <a href="http://www.theserverlabs.com/blog/2009/07/07/developing-apps-with-sca-and-jbi/  ">http://www.theserverlabs.com/blog/2009/07/07/developing-apps-with-sca-and-jbi/  </a>
<a href="http://blogs.sun.com/tombarrett/entry/sca_raining_on_the_jbi">http://blogs.sun.com/tombarrett/entry/sca_raining_on_the_jbi</a></li>
<li>Blog de Bruce Snyder comparant JBI et SCA : <a href="http://www.jroller.com/bsnyder/entry/jbi_and_sca_are_complimentary">http://www.jroller.com/bsnyder/entry/jbi_and_sca_are_complimentary</a></li>
<li>Blog de Frank Wolgang comparant JBI et SCA : <a href="http://apps.itemis.de/roller/wfrank/entry/jbi_2_0_jbi_vs">http://apps.itemis.de/roller/wfrank/entry/jbi_2_0_jbi_vs</a></li>
<li>Article du site Le Monde Informatique sur SCA : <a href="http://blog1.lemondeinformatique.fr/ingenierie_logicielle/2006/01/sca_raction_de_.html">http://blog1.lemondeinformatique.fr/ingenierie_logicielle/2006/01/sca_raction_de_.html</a></li>
<li>Blog de Xebia sur les ESB légers : <a href="http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/">http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
