---
layout: post
title: "Devoxx 2011 - What's probably coming in Java Message Service 2.0"
date: 2011-11-20
comments: false
categories:
 - java
 - devoxx
 - avis
 - jms
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-FB-AoRLfOOs/Tsk-J2XdFUI/AAAAAAAAAgE/CpRpQXHqH5M/s1600/devoxx1.jpg" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="123" src="http://4.bp.blogspot.com/-FB-AoRLfOOs/Tsk-J2XdFUI/AAAAAAAAAgE/CpRpQXHqH5M/s320/devoxx1.jpg" width="320" /></a></div><div style="text-align: justify;">La semaine dernière, j'ai eu la chance d'aller à Devoxx en Belgique à Anvers.</div><div style="text-align: justify;">Pour ceux, qui ne connaissent pas, je vous invite à aller directement à la&nbsp;pêche&nbsp;aux informations sur le site :&nbsp;<a href="http://www.devoxx.com/display/DV11/Home">http://www.devoxx.com/</a>&nbsp;et même à vous y inscrire l'année prochaine et/ou même mieux... d'aller assister à <b><a href="http://devoxx.fr/">Devoxx France</a></b>!!</div><br /><iframe allowfullscreen="" frameborder="0" height="315" src="http://www.youtube.com/embed/II6XiGGlJX0" width="420"></iframe> <br /><div style="text-align: justify;">Bon, sinon, pour revenir à nos moutons, cet article est un petit retour de la session de <a href="http://www.devoxx.com/display/DV11/Nigel+Deakin">Nigel Deakin</a> présentée à&nbsp;<a href="http://www.devoxx.com/display/DV11/Home">Devoxx&nbsp;2011</a>&nbsp;et à laquelle j'ai assisté.&nbsp;</div><div style="text-align: justify;">Elle avait pour objectif de montrer l'avancée des travaux sur JMS 2.0 (<em>Java Message Service</em>) aussi connu sous le doux nom de <a href="http://jcp.org/en/jsr/detail?id=343">JSR 343</a>. A ce jour, en version <em>early draft,</em> elle devrait être intégrée à JEE7.</div><div style="text-align: justify;">Cet article a donc pour vocation de tenter de retranscrire ce que nous a présenté Nigel.</div><!-- more --><div style="text-align: justify;">Pour la repositionner dans son contexte, la JSR343 fait suite à JMS 1.1 (<a href="http://www.jcp.org/en/jsr/detail?id=914">JSR 914</a>) et a pour but de : </div><ul><li>Simplifier l'API de JMS :<ul><li>En utilisant CDI (<em>Context Dependency Injection</em>).</li><li>En clarifiant certaines&nbsp;ambiguïtés présentes dans les spécifications.</li></ul></li><li>Améliorer l'intégration de JMS avec les serveurs d'application :<ul><li>En intégrant plus facilement les problématiques de PaaS (Platform As A Service).</li><li>En permettant le&nbsp;<em><a href="http://en.wikipedia.org/wiki/Multitenancy">multi-tenancy</a></em>.</li><li>En clarifiant ses relations avec les autres spécifications de JEE7 (ou même ultérieure) : cela est notamment vrai avec la partie MDB (<em>Message-Driven Beans</em>) de la spécifications des EJB.</li></ul></li><li>Ajouter des nouvelles fonctionnalités à l'API.</li></ul>Je ne reviendrai pas sur ce qu'est JMS (<em style="text-align: justify;">Java Message Service</em><span class="Apple-style-span" style="text-align: justify;">) si ce n'est que sa version actuelle est la 1.1 et qu'elle date de 2003, mais le fait que la spécification JMS n'ait pas évoluée depuis 2003, montre bien qu'elle était solide et qu'elle répondait bien à ce pour quoi elle avait été écrite.</span><br /><div style="text-align: justify;">Cependant, autant il n'y a rien à redire quant à la réception d'un message, autant la partie émission était souvent verbeuse puisqu'il était nécessaire&nbsp;pour émettre un message, dans le cas des EJB, de :</div><ul><li style="text-align: justify;">injecter les factory (<em>ConnectionFactory</em> et <em>Destination</em>) à l'aide de l'annotation <em>@Resource</em>,</li><li style="text-align: justify;">créer la <em>Connection</em> à l'aide de la <em>ConnectionFactory</em>,</li><li style="text-align: justify;">créer la <em>Session</em> à l'aide de la <em>Connection</em>,</li><li style="text-align: justify;">créer le <em>MessageProducer</em> à l'aide de la <em>Session</em>.</li></ul><div style="text-align: justify;">C'est seulement suite à toutes ces actions que l'émission d'un message était possible via la méthode <em>send()</em>.</div><div style="text-align: justify;">En outre, à cela, il fallait, bien sûr, gérer les exceptions <em>checkées</em> (<em>JMSException</em> pour ceux à qui cela parle ;-)) mais également la fermeture de la <em>Session</em> et de la <em>Connection</em>...</div><div style="text-align: justify;">Enfin, lors de l'utilisation conjointe de JMS et des EJB, certains paramètres de méthodes (notamment lors de la création de la <em>Session</em>) étaient redondants car gérés par le conteneur EJB (<em>createSession(boolean transacted, int acknowledgeMode)</em>).</div><div style="text-align: justify;">Un des prérequis principals de cette nouvelle version de la spécification est donc la simplification... simplification mais pas à n'importe quel prix puisqu'il était nécessaire de conserver la rétro compatibilité avec les versions ultérieures de la spécification.</div><div style="text-align: justify;">Nigel nous a donc présenté certaines des pistes qu'ils avaient (pistes encore ouvertes à discussion).</div><div style="text-align: justify;">Ce sont ces dernières que je vais essayer de retranscrire ci-dessous dans l'ordre dans lesquelles il les a énoncé. </div><h1>   Simplification sur la création de Sessions</h1><div style="text-align: justify;">Afin de simplifier l'API de JMS pour créer une Session, Nigel nous a présenté deux pistes :</div><ul><li style="text-align: justify;">Ajout d'une méthode <em>createSession(SessionMode sessionMode)</em> pour JavaSE où la classe SessionMode pourrait être une classe ayant comme variable d'instance le mode de transaction et le type d'acknowledge.</li><li style="text-align: justify;">Ajout d'une méthode <em>createSession()</em> qui serait utilisée et présente seulement pour JEE.</li></ul><h1>   Supprimer la lourdeur des close()</h1><div style="text-align: justify;">Afin de rendre moins verbeuse l'utilisation des <em>Connection</em> et des <em>Session</em>, une proposition plausible pourrait être de leur faire implémenter l'interface <em>java.lang.AutoCloseable</em>.</div><div style="text-align: justify;">Ainsi, il serait alors possible d'avoir les résultats suivants (pour rappel, il ne s'agit que de propositions car cela est toujours à l'étude) : </div><ul><li style="text-align: justify;">avec Java 7 dans un contexte JEE :</li></ul><pre class="brush:java; wrap-lines: false; auto-links: false">@Resource(mappedName="...")<br />ContextFactory contextFactory;<br /><br />@Resource(mappepdName="...")<br />Queue orderQueue;<br /><br />public void sendMessage(String payload) {<br />  try (messagingContext mCtx = contextFactory.createContext() ;) {<br />    TextMessage textMessage = mCtx.createTextMessage(payload);<br />    mCtx.send(orderQueue, textMessage);<br />  }<br />}<br /></pre><ul><li>avec CDI dans un contexte JEE :</li></ul><pre class="brush:java; wrap-lines: false; auto-links: false">@Resource(mappedName="...")<br />Queue orderQueue;<br /><br />@Inject<br />@MessagingContext(lookup="...")<br />MessagingContext mCtx;<br /><br />@Inject<br />TextMessage textMessage;<br /><br />public void sendMessage(String payload) {<br />  textMesage.setText(payload);<br />  mCtx.send(orderQueue, textMessage);<br />}<br /></pre><ul><li>toujours avec Java 7 dans un contexte JEE :</li></ul><pre class="brush:java; wrap-lines: false; auto-links: false">@Inject<br />@JMSConnection(lookup="...")<br />@JMSDestination(lookup="...")<br />MessageProducer producer;<br /><br />@Inject<br />TextMessage textMessage;<br /><br />public void sendMessage(String payload) {<br />  try {<br />    textMessage.setText(payload);<br />    producer.send(textMessage);<br />  } catch (JMSException e) {<br />    //todo<br />  }<br />}<br /></pre><h1>   Autres simplifications</h1><div style="text-align: justify;">Les autres&nbsp;simplifications&nbsp;d'API envisageables pourraient être : </div><ul><li style="text-align: justify;">de ne pas à créer préalablement un objet de type <i>Message</i> (ce qui pourrait permettrait de faire directement : <em>producer.send(String/Serializable);</em> ). Cependant, ce type d'API ne permettrait pas de positionner des propriétés sur le message et ne serait pas adapter pour des messages de types <em>BytesMessage</em> ou <em>StreamMessage</em>. A ajouter à cela la question de son pendant pour la réception</li><li style="text-align: justify;">de simplifier la gestion des <em>DurableSubscriber </em>(<a href="http://download.oracle.com/javaee/1.4/api/javax/jms/Session.html#createDurableSubscriber(javax.jms.Topic, java.lang.String)">http://download.oracle.com/javaee/1.4/api/javax/jms/Session.html#createDurableSubscriber(javax.jms.Topic, java.lang.String)</a>), qui, au jour d'aujourd'hui, doivent obligatoirement&nbsp;posséder un identifiant client et un nom de&nbsp;souscription. Ces deux paramètres pourraient être rendus optionnels dans le cadre d'une utilisation conjointe avec les EJB 3.2</li></ul><h1>   Vers le futur...</h1><div style="text-align: justify;">Autre que la simplification des APIs, Nigel nous a présenté ce que pourrait apporter JMS 2.0 dans nos besoins de demain.</div><div style="text-align: justify;">Ainsi, JMS 2.0 devra, pour répondre aux besoins des problématiques de type SaaS (<em>Software As A Service</em>), permettre de déclarer ses ressources créées dans un serveur d'applications et de les&nbsp;enregistrer dans un annuaire JNDI (comme c'est actuellement le cas pour les  DataSource).</div><div style="text-align: justify;">Pour ce faire, de nouvelles annotations pourraient voir le jour (par exemple : <em>@JMSConnectionFactoryDefinition</em> et <em>@JMSDestinationDefinition</em>) mais également un <a href="http://thecodersbreakfast.net/index.php?post/2008/12/26/Java-%3A-pr%C3%A9sentation-du-Service-Provider-API">SPI</a> (<em>Service Provider Interface</em>) pour le faire de manière programmatique.</div><div style="text-align: justify;">Concernant une meilleure intégration avec les serveurs d'applications (ce qui permettrait d'utiliser n'importe quel JMS Provider dans n'importe quel serveur d'application JEE), Nigel propose la solution de JCA (<em>Java Connector Architecture</em>), un peu comme ce qui existe avec le drivers de bases de données. </div><h1>   Nouvelles features</h1><div style="text-align: justify;">Concernant les nouvelles <em>features</em> de l'API, Nigel nous a ensuite présenté ce qui pourrait arriver, à savoir (en vrac) : </div><ul><li style="text-align: justify;">l'émission de messages avec un&nbsp;acquittement&nbsp;asynchrone du serveur,</li><li style="text-align: justify;">la possibilité pour un client JMS d'utiliser des <em>Future</em>,</li><li style="text-align: justify;">la possibilité d'émettre un message et de ne pas à avoir à attendre la réception d'un acquittement pour savoir si le message a bien été émis.</li></ul><div style="text-align: justify;">Il se pourrait également que la propriété <em>JMSXDeliveryCount</em> ne soit plus optionnelle, ce qui permettrait aux serveurs d'applications de mieux gérer le <em>flood.&nbsp;</em></div><div style="text-align: justify;">De même, la gestion des <em>Topics</em> hiérarchiques pourraient être rendue obligatoire.</div><div style="text-align: justify;">Enfin, une meilleure gestion des batch pourrait être possible via de nouvelles API comme par exemple l'introduction de la méthode <em>receive(Message[])</em>. </div><h1>   Conclusion</h1><div style="text-align: justify;">En conclusion, je suis assez mitigé par cette session.</div><div style="text-align: justify;">En effet, autant, je trouve que certaines propositions permettraient de rendre moins verbeuses l'utilisation de JMS, autant, je ne suis pas convaincu que pouvoir faire la même chose de différentes manières soit une bonne chose (et, cela, même si ça simplifie le travail du développeur...).</div><div style="text-align: justify;">En outre, je trouve que, pour la majorité des propositions (même si elles sont totalement viables), l'axe de JEE est trop important.</div><div style="text-align: justify;">Enfin, intégrer fortement CDI avec JMS m'embête un peu car cela nécessite de disposer d'un conteneur CDI, chose qui n'est pas toujours le cas dans un contexte Java SE et, même si je trouve CDI sexy, je ne pense pas que la majorité des développeurs ou que nos clients soient prêts à franchir le pas en raison de la complexité intrinsèque à CDI (bien sûr, JMS 2.0 se devait de se tourner vers le futur et CDI se devait d'être pris en compte)... enfin, il ne s'agit que d'un avis personnel... l'avenir nous dira ce qu'il en est... ;-)</div><div style="text-align: justify;">Dernier point (mais là encore, c'est totalement personnel), j'aurais aimé voir une intégration des notions d'EIP (<i>Enterprise Integration Pattern</i>) même si la notion de <i>filter</i> (au sens EIP du terme) sort un peu du scope de JMS mais bon... ;-) </div><div style="text-align: justify;">Pour conclure, Nigel a bien présenté la direction que pourrait prendre JMS dans un futur proche mais, comme il nous l'a fréquemment fait remarquer, il ne s'agit que de pistes et, d'ailleurs, <a href="http://java.net/projects/jms-spec/pages/Home">toutes les contributions sont les bienvenues</a>.</div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
En fait, pour ma part, j&#39;ai toujours eu un penchant pour les standards mais j&#39;avoue que la direction que prend la spec ne m&#39;enchante pas des masses...<br /> <br />Concernant AMQP, je ne connais pas (j&#39;avais commencé à regarder la spec mais j&#39;ai arrêté... elle n&#39;était pas drôle ;-) )... mais c&#39;est vrai que son avantage est que le protocole est interopérable.<br /><br />A voir ce que l&#39;expert group nous proposera... Charge aussi aux providers d&#39;être imaginatif et de proposer quelque chose qui puisse concurrencer/égaler ce que propose AMQP tout en gardant la simplicité offerte par JMS mais au vu du planning, c&#39;est mal barré... :&#39;(<br /><br />Merci pour les retours!</div>
</div>
<div class='comment'>
<div class='author'>Emmanuel</div>
<div class='content'>
Idem, j&#39;espère que JMS 2.0 s&#39;inspirera des bonne idées introduites par AMQP, notamment la possibilité d&#39;attacher plusieurs topics à une seule queue.</div>
</div>
<div class='comment'>
<div class='author'>Brice</div>
<div class='content'>
Honnetement je pense que AMQP a potentiellement plus d&#39;avenir. Notamment parceque ce n&#39;est pas lié à JEE ou même à Java, il s&#39;intègre très bien avec tout un enssemble d&#39;autres écosystèmes. A mon vi aussi AMQP offre plus d&#39;opportunités pour créer différentes infrastructures de messaging.</div>
</div>
</div>
