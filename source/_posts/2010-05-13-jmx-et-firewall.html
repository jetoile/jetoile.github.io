---
layout: post
title: "JMX et Firewall"
date: 2010-05-13
comments: false
categories:
 - java
 - jmx
---

<div class='post'>
<div style="text-align: justify;"><a href="http://1.bp.blogspot.com/_XLL8sJPQ97g/S-HXgq4HI7I/AAAAAAAAAJ4/LzJKs3wTNZM/s1600/jmx4.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5467888378869916594" src="http://1.bp.blogspot.com/_XLL8sJPQ97g/S-HXgq4HI7I/AAAAAAAAAJ4/LzJKs3wTNZM/s200/jmx4.png" style="float: left; height: 57px; margin: 0pt 10px 10px 0pt; width: 200px;" /></a>Cet article fait suite à mon post précédent qui, je le rappelle, pour ceux qui auraient eux le courage de le lire jusqu'à la fin ;-), avait pour objectif de rappeler en quoi JMX (Java Management eXtension) pouvait être une bonne réponse aux problématiques de supervision et d'administration dans une application (au sens large du terme). Cet article portera sur le sujet que je voulais initialement traiter, à savoir, comment accéder à un serveur JMX se trouvant derrière un Firewall. Cette problématique est indiquée sur le site de Sun/Oracle mais je vais, ici, faire un résumer de la méthode à suivre.</div><!-- more --><br /><div style="text-align: justify;">En effet, supposions que nous ayons l'architecture suivante (image sous licence Creative Commons Attribution-Share Alike) :</div><div style="text-align: justify;"><a href="http://4.bp.blogspot.com/_XLL8sJPQ97g/S-vg1m-cF6I/AAAAAAAAAKI/glTWe7EakaA/s1600/Firewall2.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5470713383971723170" src="http://4.bp.blogspot.com/_XLL8sJPQ97g/S-vg1m-cF6I/AAAAAAAAAKI/glTWe7EakaA/s320/Firewall2.png" style="cursor: pointer; display: block; height: 176px; margin: 0px auto 10px; text-align: center; width: 320px;" /></a><a href="http://4.bp.blogspot.com/_XLL8sJPQ97g/S-vghDSieLI/AAAAAAAAAKA/4fqvMIpfd64/s1600/Firewall2.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><br /></a></div><div style="text-align: justify;">En fait, dans ce cas, le client sur lequel la jConsole, jVisualVM ou autre est lancée, ne verra pas le serveur JMX, et cela, même en précisant le port.</div><div style="text-align: justify;">En effet, le connecteur JMX RMI ouvre deux ports :</div><ul style="text-align: justify;"><li>un pour le RMI Registry (et qui est configurable avec l'option <i>com.sun.management.jmxremote.port</i>)<br /></li><li>et un autre utilisé pour exporter les objets utilisés par la connexion JMX RMI.<br /></li></ul><div style="text-align: justify;">Cependant, ce dernier port est, par défaut, alloué de manière dynamique et aléatoirement (puisqu'il n'est pas nécessaire de connaitre ce port pour se connecter à l'agent JMX).</div><div style="text-align: justify;">C'est cela qui pose problème lorsque l'on tente de se connecter à un serveur JMX se trouvant derrière un firewall puisqu'il n'est, alors, pas possible de demander l'ouverture d'un port que l'on ne connait pas...</div><div style="text-align: justify;">Aussi, la seule possibilité pour résoudre ce problème est de passer par la déclaration de son <i>JMXServiceURL</i> pour spécifier le port permettant d'exporter les objets utilisés par le connexion JMX RMI. Cependant, ce <i>JMXServiceURL</i> ne peut pas être modifié dans l'agent JMX utilisé par défaut...</div><div style="text-align: justify;">Heureusement, il est possible de définir programmatiquement son propre agent JMX.</div><div style="text-align: justify;">En fonction de l'usage, deux choix sont possibles :</div><ul style="text-align: justify;"><li>définir son agent JMX au sein de l'application</li><li>utiliser un agent JVM pour définir son propre agent JMX</li></ul><div style="text-align: justify;">Il est à noter que l'implémentation présentée ici ne prend pas en compte la problématique de sécurité (et en particulier SSL) où deux ports différents doivent être utilisés. En outre, il sera supposé que le RMI Registry sera démarré dans l'application.</div><h1>1ère méthode</h1><div style="text-align: justify;">Ainsi, si vous avez la main sur la méthode <i>main</i> sur l'application, il suffit de rajouter le code qui va bien, à savoir :</div><pre class="brush:java; wrap-lines: false; auto-links: false">package example;<br /><br />import java.lang.management.ManagementFactory;<br />import java.rmi.registry.LocateRegistry;<br />import java.util.HashMap;<br /><br />import javax.management.MBeanServer;<br />import javax.management.remote.JMXConnectorServer;<br />import javax.management.remote.JMXConnectorServerFactory;<br />import javax.management.remote.JMXServiceURL;<br /><br />public class MyApp {<br /><br /> public static void main(String[] args) throws Exception {<br />  final int port1 = Integer.parseInt(System.getProperty("example.rmi.agent.port", "3000"));<br />  System.out.println("Create RMI registry on port "+port1);<br />  LocateRegistry.createRegistry(port1);<br /><br />  // Retrieve the PlatformMBeanServer.<br />  System.out.println("Get the platform's MBean server");<br />  MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();<br /><br />  // Environment map.<br />  System.out.println("Initialize the environment map");<br />  HashMap env = new HashMap();<br /><br />  // Create an RMI connector server.<br />  //<br />  // As specified in the JMXServiceURL the RMIServer stub will<br />  // be registered in the RMI registry running in the local<br />  // host on port 3000 with the name "jmxrmi". This is the same<br />  // name the out-of-the-box management agent uses to register <br />  // the RMIServer stub too.<br />  System.out.println("Create an RMI connector server");<br />  JMXServiceURL url = new JMXServiceURL("service:jmx:rmi://localhost:" + port1 + "/jndi/rmi://localhost:" + port1 + "/jmxrmi");<br />  JMXConnectorServer cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);<br /><br />  // Start the RMI connector server.<br />  System.out.println("Start the RMI connector server");<br />  cs.start();<br />}</pre><div style="text-align: justify;">Pour tester ce code, exécuter le code suivant :</div><pre class="brush:bash; wrap-lines: false; auto-links: false">java -Dexample.rmi.agent.port=3010 -classpath . example.MyApp</pre><div style="text-align: justify;">puis lancer une jconsole et renseigner le champ "Remote Process" :</div><div style="text-align: justify;"><pre class="brush:bash; wrap-lines: false; auto-links: false">service:jmx:rmi://localhost:3010/jndi/rmi://localhost:3010/jmxrmi</pre></div><h1>2ième méthode</h1><div style="text-align: justify;">Par contre, la solution précédente n'est parfois pas applicable car le code de l'application à exécuter peut ne pas être disponible ou car récupérer ses sources, les modifiés et recompiler la dite application (par exemple, si c'est un conteneur de Servlet que vous voulez administrer...) peut être un peu problématique (je ne suis pas sûr que l'équipe de production soit enchantée d'utiliser une version modifiée d'Apache Tomcat...).</div><div style="text-align: justify;">Aussi, dans ce cas, il est possible de déclarer son propre agent à enregistrer dans la JVM (en définissant la méthode <i>premain</i> et en renseignant l'attribut <i>Premain-Class</i> du fichier <i>MANIFEST.MF</i>) qui se chargera de définir et de lancer l'agent JMX (une sorte de wrapper). Cependant, dans ce cas, l'agent JMX lancé par l'agent java ne sera pas arrêté par l'envoie du signal de fin de l'application. Il convient alors de lancer un Thread chargé de scrupter le processus de l'agentJMX.</div><div style="text-align: justify;">Ci-dessous un exemple de l'agent JVM :</div><div style="text-align: justify;"><pre class="brush:java; wrap-lines: false; auto-links: false">/*<br />* CustomAgent.java<br />*<br />* Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.<br />*<br />* Redistribution and use in source and binary forms, with or<br />* without modification, are permitted provided that the<br />* following conditions are met:<br />*<br />* - Redistributions of source code must retain the above <br />*   copyright notice, this list of conditions and the <br />*   following disclaimer.<br />*<br />* - Redistributions in binary form must reproduce the above <br />*   copyright notice, this list of conditions and the following<br />*   disclaimer in the documentation and/or other materials<br />*   provided with the distribution.<br />*<br />* - Neither the name of Sun Microsystems nor the names of its<br />*   contributors may be used to endorse or promote products <br />*   derived from this software without specific prior written<br />*   permission.<br />*<br />* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND <br />* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, <br />* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF <br />* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE <br />* DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR<br />* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,<br />* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, <br />* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR <br />* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS <br />* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF<br />* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT<br />* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT<br />* OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE <br />* POSSIBILITY OF SUCH DAMAGE.<br />*<br />* Created on Jul 25, 2007, 11:42:49 AM<br />*<br />*/<br /><br />package example.rmi.agent;<br /><br />import java.io.IOException;<br />import java.lang.management.ManagementFactory;<br />import java.net.InetAddress;<br />import java.rmi.registry.LocateRegistry;<br />import java.util.HashMap;<br />import javax.management.MBeanServer;<br />import javax.management.remote.*;<br />import javax.management.remote.rmi.*;<br /><br />/**<br />* This CustomAgent will start an RMI COnnector Server using <br />* only port "example.rmi.agent.port".<br />*<br />* @author dfuchs<br />*/<br />public class CustomAgent {<br /> public static class CleanThread extends Thread {<br />  private final JMXConnectorServer cs;<br />  public CleanThread(JMXConnectorServer cs) {<br />   super("JMX Agent Cleaner");<br />   this.cs = cs;<br />   setDaemon(true);<br />  }<br />  public void run() {<br />   boolean loop = true;<br />   try {<br />    while (loop) {<br />     final Thread[] all = new Thread[Thread.activeCount()+100];<br />     final int count = Thread.enumerate(all);<br />     loop = false;<br />     for (int i=0; i &lt; count; i++) {<br />      final Thread t = all[i];<br />      // daemon: skip it.<br />      if (t.isDaemon()) continue;<br />      // RMI Reaper: skip it.<br />      if (t.getName().startsWith("RMI Reaper")) continue;<br />      if (t.getName().startsWith("DestroyJavaVM")) continue;<br />      // Non daemon, non RMI Reaper: join it, break the for<br />      // loop, continue in the while loop (loop=true)<br />      loop = true;<br />      try {<br />       System.out.println("Waiting on "+t.getName()+<br />         " [id="+t.getId()+"]");<br />       t.join();<br />      } catch (Exception ex) {<br />       ex.printStackTrace();<br />      }<br />      break;<br />     }<br />    }<br />    // We went through a whole for-loop without finding any <br />    // thread to join. We can close cs.<br />   } catch (Exception ex) {<br />    ex.printStackTrace();<br />   } finally {<br />    try {<br />     // if we reach here it means the only non-daemon threads<br />     // that remain are reaper threads - or that we got an<br />     // unexpected exception/error.<br />     cs.stop();<br />    } catch (Exception ex) {<br />     ex.printStackTrace();<br />    }<br />   }<br />  }<br /> }<br /><br /><br /> private CustomAgent() { }<br /><br /> public static void premain(String agentArgs) <br /> throws IOException {<br />  // Start an RMI registry on port specified by <br />  // example.rmi.agent.port (default 3000).<br />  final int port= Integer.parseInt(System.getProperty("example.rmi.agent.port","3000"));<br />  System.out.println("Create RMI registry on port "+port);<br />  LocateRegistry.createRegistry(port);<br /><br />  // Retrieve the PlatformMBeanServer.<br />  System.out.println("Get the platform's MBean server");<br />  MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();<br /><br />  // Environment map.<br />  System.out.println("Initialize the environment map");<br />  HashMap env = new HashMap();<br /><br />  // Create an RMI connector server.<br />  //<br />  // As specified in the JMXServiceURL the RMIServer stub will <br />  // be registered in the RMI registry running in the local <br />  // host on port 3000 with the name "jmxrmi". This is the <br />  // same name the out-of-the-box management agent uses to <br />  // register the RMIServer stub too.<br />  //<br />  // The port specified in "service:jmx:rmi://"+hostname+":"+port<br />  // is the second port, where RMI connection objects will be <br />  // exported. Here we use the same port as that we choose   <br />  // for the RMI registry. The port for the RMI registry is  <br />  // specifiedin the second part of the URL, in <br />  // "rmi://"+hostname+":"+port<br />  System.out.println("Create an RMI connector server");<br />  final String hostname = InetAddress.getLocalHost().getHostName();<br />  JMXServiceURL url =<br />   new JMXServiceURL("service:jmx:rmi://"+hostname+":"+(port)+"/jndi/rmi://"+hostname+":"+port+"/jmxrmi");<br /><br />  // Now create the server from the JMXServiceURL<br />  JMXConnectorServer cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);<br /><br />  // Start the RMI connector server.<br />  System.out.println("Start the RMI connector server on port "+port);<br />  cs.start();<br />  System.out.println("Server started at: "+cs.getAddress());<br /><br />  // Start the CleanThread.<br />  final Thread clean = new CleanThread(cs);<br />  clean.start();<br /> }<br />}</pre></div><div style="text-align: justify;"></div><div style="text-align: justify;">Pour créer l'agent, il est possible d'utiliser le script <i>ant</i> suivant qui renseigne de manière adéquate le fichier <i>MANIFEST</i> :</div><pre class="brush:xml; wrap-lines: false; auto-links: false"><project basedir="." <br />    default="build-agent-jar" name="customAgent"><br /><br />  <property location="src" name="src"></property><br />  <property location="build" name="build"></property><br />  <property location="dist" name="dist"></property><br />  <property name="dist.agent.jar" value="customAgent.jar"></property><br /><br />  <target name="init"><br />    <mkdir dir="${build}"></mkdir><br />    <mkdir dir="${dist}"></mkdir><br />  </target><br /><br />  <target description="clean" name="clean"><br />    <delete dir="${build}"></delete><br />    <delete dir="${dist}"></delete><br />  </target><br /><br />  <target depends="init" name="compile"><br />    <javac destdir="${build}" srcdir="${src}"></javac><br />  </target><br />      <br />  <target depends="clean,compile" name="build-agent-jar"><br />    <jar basedir="${build}" destfile="${dist}/${dist.agent.jar}"><br />      <manifest><br />        <attribute name="Premain-Class" value="example.rmi.agent.CustomAgent"></attribute><br />      </manifest><br />    </jar><br />  </target><br /></project><br /></pre><div style="text-align: justify;">Pour tester ce code, ajouter le jar <i>customAgent.jar</i> au classpath de l'application et exécuter la commande suivante :</div><div style="text-align: justify;"><pre class="brush:bash; wrap-lines: false; auto-links: false">java -Dexample.rmi.agent.port=3010 -javaagent:customAgent.jar -classpath customAgent.jar example.MyApp2</pre></div><div style="text-align: justify;"><i> </i>Le dernier point à prendre en compte est le fait que pour rendre visible le serveur RMI, il peut être nécessaire de préciser le nom du serveur avec l'option<i> java.rmi.server.hostname</i>. Aussi, si le serveur RMI utilisé est embarqué dans votre conteneur de servlet ou autre, il peut s'avérer utile de le préciser lors du lancement de la JVM.</div><div style="text-align: justify;">Par exemple, dans le cas d'Apache Tomcat, il est possible d'ajouter l'option Java suivante :</div><div style="text-align: justify;"><pre class="brush:bash; wrap-lines: false; auto-links: false">export JAVA_OPTS="$JAVA_OPTS -javaagent:${CATALINA_HOME}/lib/customAgent.jar -Djava.rmi.server.hostname=192.168.1.105"</pre></div><div style="text-align: justify;">Enfin, il est à noter que je ne suis pas expert JMX (je m'excuse donc pour les quelques petites approximations qu'il pourrait y avoir)...</div>Pour plus d'informations, je conseillerai, en vrac, les liens suivants : <br /><div style="text-align: justify;"><ul><li>Blogs de Daniel Fuchs : <a href="http://blogs.sun.com/jmxetc/entry/troubleshooting_connection_problems_in_jconsole">http://blogs.sun.com/jmxetc/entry/troubleshooting_connection_problems_in_jconsole</a></li><li>Blogs de Daniel Fuchs : <a href="http://blogs.sun.com/jmxetc/entry/connecting_through_firewall_using_jmx">http://blogs.sun.com/jmxetc/entry/connecting_through_firewall_using_jmx</a></li><li>Page d'Oracle de documentation sur JMX : <a href="http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html">http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html</a></li><li>Blog de Oleg Zhurakousky : <a href="http://olegz.wordpress.com/2009/03/23/jmx-connectivity-through-the-firewall/">http://olegz.wordpress.com/2009/03/23/jmx-connectivity-through-the-firewall/</a></li><li>Documentation sur MX4J : <a href="http://mx4j.sourceforge.net/docs/ch03.html#N10324">http://mx4j.sourceforge.net/docs/ch03.html#N10324</a></li></ul></div></div>
