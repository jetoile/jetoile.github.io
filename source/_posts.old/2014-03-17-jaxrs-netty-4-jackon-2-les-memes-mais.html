---
layout: post
title: "JAXRS, Netty 4, Jackon 2... les mêmes mais en mieux..."
date: 2014-03-17
comments: false
categories:
 - netty
 - java
 - jmx
 - REST
 - perfomance
 - jolokia
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-Vzol1CndcjY/Uxib17Rlf2I/AAAAAAAABQI/Qi4u0DWe2s4/s1600/resteasy_jolokia_metrics.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-Vzol1CndcjY/Uxib17Rlf2I/AAAAAAAABQI/Qi4u0DWe2s4/s1600/resteasy_jolokia_metrics.png" height="211" width="320" /></a></div><div style="text-align: justify;">Pour faire suite à mon <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">article précédent</a> qui montrait comment il était possible de construire une <i>stack</i> légère basée sur Resteasy-Netty3, Jackson, <a href="http://www.jolokia.org/">Jolokia</a> et <a href="https://helloreverb.com/developers/swagger">Swagger</a>, cet article montrera comment il est possible de faire la même chose avec Resteasy-Netty4 et Jackson 2.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Même si les changements ne sont pas énormes, il y a quand même quelques variantes, et, histoire d'être exhaustif, cela permet de faire le tour complet... ;-)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En fait, les seuls points qui diffèrent, par rapport au code précédent, touchent : </div><ul style="text-align: justify;"><li>les dépendances,</li><li>l'intégration de Resteasy-netty4,</li><li>l'intégration du JacksonConfig (changement d'API coté Jackson),</li><li>le support de JodaTime dans Jackson 2,</li><li>et le support du CORS dans Resteasy-Netty4.</li></ul><div style="text-align: justify;">C'est donc ces différents points qui seront abordés dans cet article.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Le code se trouve sur github sur la <a href="https://github.com/jetoile/resteasy-netty-sample/tree/netty4">branche netty4</a>.  </div><!-- more --><h1>Les Dépendances</h1><div style="text-align: justify;">Les dépendances utilisées sont les suivantes (au format gradle) : </div><pre class="brush:text; wrap-lines: false; auto-links: false">compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'<br />compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'<br />compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'<br />compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'<br />compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'<br />compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'<br />compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'<br />compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'<br />compile group: 'org.jboss.resteasy', name: 'resteasy-jackson2-provider', version:'3.0.6.Final'<br />compile group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-joda', version:'2.3.2'<br />compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'<br />compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'<br />compile group: 'commons-io', name: 'commons-io', version:'2.4'<br />compile group: 'joda-time', name: 'joda-time', version:'2.3'<br />compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}<br /></pre><br /><div style="text-align: justify;">On peut y constater depuis la version précédente que netty est passé en version <b>4.0.17.Final</b> mais également c'est maintenant l'artefact <b>resteasy-netty4</b> qui est utilisé plutôt que <b>resteasy-netty</b>. De la même manière, c'est maintenant l'artefact <b>resteasy-jackson2-provider</b> plutôt que <b>resteasy-jackson-provider</b>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En outre l'artefact <b>jackson-datatype-joda</b> a été ajouté (nous y reviendrons ultérieurement).</div><h1>Intégration de Resteasy-netty4</h1><div style="text-align: justify;">Afin de remplacer Resteasy-netty 3 par Resteasy-Netty4, il suffit de modifier les dépendances et de supprimer le hack fait précédemment concernant le CORS (ie. la classe <b>RequestHandler</b>) qui est incompatible avec cette nouvelle version.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Une fois cela fait, le programme devrait être de nouveau fonctionnel sans avoir à modifier quoique ce soit (modulo Swagger-UI mais nous y reviendrons ultérieurement.)</div><h1>Intégration de Jackson 2</h1><div style="text-align: justify;">Comme il a été vu précédemment, c'est maintenant la version de Jackson 2 qui est utilisé plutôt que la 1.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Aussi, il est nécessaire de modifier les packages de Jackson importés : cela n'est à faire que dans la classe <b>JacksonConfig</b>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Certaines des API ayant également évoluées, la classe <b>JacksonConfig</b> devient : </div><pre class="brush:java; wrap-lines: false; auto-links: false">public class JacksonConfig implements ContextResolver&lt;ObjectMapper&gt; {<br />    private final ObjectMapper objectMapper;<br /><br />    public JacksonConfig() {<br />        objectMapper = new ObjectMapper();<br />        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);<br />        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);<br />    }<br /><br />    @Override<br />    public ObjectMapper getContext(Class&lt;?&gt; objectType) {<br />        return objectMapper;<br />    }<br />}<br /></pre><br /><h1>Support de JodaTime dans Jackson 2</h1><div style="text-align: justify;">On a vu dans le paragraphe précédent comment il fallait modifier notre code pour utiliser Jackson 2 à la place de Jackson 1.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cependant, lors d'un :  </div><pre class="brush:bash; wrap-lines: false; auto-links: false">curl -XGET http://localhost:8081/sample/say/hello<br /></pre><br />On obtient : <br /><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "message": "hello",<br />    "time": {<br />        "era": 1,<br />        "dayOfMonth": 6,<br />        "dayOfWeek": 4,<br />        "dayOfYear": 65,<br />        "weekyear": 2014,<br />        "weekOfWeekyear": 10,<br />        "monthOfYear": 3,<br />        "yearOfEra": 2014,<br />        "yearOfCentury": 14,<br />        "centuryOfEra": 20,<br />        "millisOfSecond": 173,<br />        "millisOfDay": 53370173,<br />        "secondOfMinute": 30,<br />        "secondOfDay": 53370,<br />        "minuteOfHour": 49,<br />        "minuteOfDay": 889,<br />        "hourOfDay": 14,<br />        "year": 2014,<br />        "zone": {<br />            "fixed": false,<br />            "uncachedZone": {<br />                "cachable": true,<br />                "fixed": false,<br />                "id": "Europe/Paris"<br />            },<br />            "id": "Europe/Paris"<br />        },<br />        "millis": 1394113770173,<br />        "chronology": {<br />            "zone": {<br />                "fixed": false,<br />                "uncachedZone": {<br />                    "cachable": true,<br />                    "fixed": false,<br />                    "id": "Europe/Paris"<br />                },<br />                "id": "Europe/Paris"<br />            }<br />        },<br />        "afterNow": false,<br />        "beforeNow": false,<br />        "equalNow": true<br />    }<br />}<br /></pre><br /><div style="text-align: justify;">Pour corriger cela, il suffit d'importer la dépendance <b>'com.fasterxml.jackson.datatype', name: 'jackson-datatype-joda'</b> et d'ajouter à l'<b>objectMapper</b> le module <b>JodaModule</b> : </div><pre class="brush:java; wrap-lines: false; auto-links: false">objectMapper = new ObjectMapper();<br />objectMapper.registerModule(new JodaModule());<br />objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  <br /></pre><br /><div style="text-align: justify;">Ainsi, on obtient bien : </div><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "message": "hello",<br />    "time": "2014-03-06T13:53:38.714Z"<br />}<br /></pre><br /><h1>Support du CORS dans Resteasy-Netty4</h1><div style="text-align: justify;">Précédemment, avec Resteast-netty 3, nous avions remarqué un problème de CORS avec Swagger-UI. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour en venir à bout, un <i>hack</i> avait été fait mais ce n'était pas très propre...</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Malheureusement, Resteasy-netty4 n'offre pas, non plus, de manière simple pour surmonter ce problème.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En fouillant un peu sur internet, un <a href="http://stackoverflow.com/questions/18857546/implement-cross-origin-resource-sharing-cors-on-resteasy-netty-server">article</a> propose de rajouter un <b>ChannelInboundHandler</b> au <i>pipeline</i> Netty.</div><div style="text-align: justify;">Cependant, je n'ai pas trouvé de moyen simple de le faire mis à part la surcharge de la méthode...</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Le code obtenu est donc le suivant :</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">La classe <b>ChannedInboundHandler</b> : </div><pre class="brush:java; wrap-lines: false; auto-links: false">public class CorsHeadersChannelHandler extends SimpleChannelInboundHandler&lt;NettyHttpRequest&gt; {<br />    protected void channelRead0(ChannelHandlerContext ctx, NettyHttpRequest request) throws Exception {<br />        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");<br />        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");<br />        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");<br /><br />        ctx.fireChannelRead(request);<br />    }<br />}<br /></pre><br /><div style="text-align: justify;">La surcharge de la méthode <i>start()</i> pour ajouter le <i>handler</i> au pipeline Netty (désolé pour le nom...) : </div><pre class="brush:java; wrap-lines: false; auto-links: false">public class MyNettyJaxrsServer extends NettyJaxrsServer {<br />    private EventLoopGroup eventLoopGroup;<br />    private EventLoopGroup eventExecutor;<br />    private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;<br />    private int executorThreadCount = 16;<br />    private SSLContext sslContext;<br />    private int maxRequestSize = 1024 * 1024 * 10;<br />    private int backlog = 128;<br /><br />    @Override<br />    public void setSSLContext(SSLContext sslContext) { this.sslContext = sslContext; }<br /><br />    @Override<br />    public void setIoWorkerCount(int ioWorkerCount) { this.ioWorkerCount = ioWorkerCount; }<br /><br />    @Override<br />    public void setExecutorThreadCount(int executorThreadCount) { this.executorThreadCount =  executorThreadCount; }<br /><br />    @Override<br />    public void setMaxRequestSize(int maxRequestSize) { this.maxRequestSize  = maxRequestSize; }<br /><br />    public void setBacklog(int backlog) { this.backlog = backlog; }<br /><br />    @Override<br />    public void start() {<br />        eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);<br />        eventExecutor = new NioEventLoopGroup(executorThreadCount);<br />        deployment.start();<br />        final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);<br />        // Configure the server.<br />        if (sslContext == null) {<br />            bootstrap.group(eventLoopGroup)<br />                    .channel(NioServerSocketChannel.class)<br />                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {<br />                        @Override<br />                        public void initChannel(SocketChannel ch) throws Exception {<br />                            ch.pipeline().addLast(new HttpRequestDecoder());<br />                            ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));<br />                            ch.pipeline().addLast(new HttpResponseEncoder());<br />                            ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTP));<br />                            ch.pipeline().addLast(new CorsHeadersChannelHandler());<br />                            ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));<br />                            ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));<br />                        }<br />                    })<br />                    .option(ChannelOption.SO_BACKLOG, backlog)<br />                    .childOption(ChannelOption.SO_KEEPALIVE, true);<br />        } else {<br />            final SSLEngine engine = sslContext.createSSLEngine();<br />            engine.setUseClientMode(false);<br />            bootstrap.group(eventLoopGroup)<br />                    .channel(NioServerSocketChannel.class)<br />                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {<br />                        @Override<br />                        public void initChannel(SocketChannel ch) throws Exception {<br />                            ch.pipeline().addFirst(new SslHandler(engine));<br />                            ch.pipeline().addLast(new HttpRequestDecoder());<br />                            ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));<br />                            ch.pipeline().addLast(new HttpResponseEncoder());<br />                            ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTPS));<br />                            ch.pipeline().addLast(new CorsHeadersChannelHandler());<br />                            ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));<br />                            ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));<br />                        }<br />                    })<br />                    .option(ChannelOption.SO_BACKLOG, backlog)<br />                    .childOption(ChannelOption.SO_KEEPALIVE, true);<br />        }<br />        bootstrap.bind(port).syncUninterruptibly();<br />    }<br />}<br /></pre><br />On y observe le rajout du <i>handler</i> :  <br /><pre class="brush:java; wrap-lines: false; auto-links: false">ch.pipeline().addLast(new CorsHeadersChannelHandler());<br /></pre><br />Enfin, l'initialisation du serveur Resteasy-netty : <br /><pre class="brush:java; wrap-lines: false; auto-links: false">MyNettyJaxrsServer netty = new MyNettyJaxrsServer();<br /></pre><br /><h1>Conclusion</h1><div style="text-align: justify;">On a vu, dans cet article, comment il était possible d'intégrer JAX-RS avec Netty 4 à l'aide de Resteasy tout en ayant une intégration de Jackson 2. <br /><br /></div><div style="text-align: justify;">On a également montré qu'il était possible d'y intégrer très simplement Swagger et Jolokia.</div></div>
