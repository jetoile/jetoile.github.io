---
layout: post
title: "FluentLenium et Cucumber JVM... complément et precision"
date: 2013-04-11
comments: false
categories:
 - java
 - intégration continue
 - fluentLenium
 - test
 - selenium
 - maven
---

<div class='post'>
<a href="http://4.bp.blogspot.com/-R3ORi15Ei3Y/UTmwoq5A2II/AAAAAAAAA3o/uaIMSSZlq38/s1600/logo.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="209" src="http://4.bp.blogspot.com/-R3ORi15Ei3Y/UTmwoq5A2II/AAAAAAAAA3o/uaIMSSZlq38/s320/logo.png" width="320" /></a><br /><div style="text-align: justify;">Dans mon article précédent, j'avais tenté d'expliquer comment il était possible d'intégrer les frameworks <a href="https://github.com/cucumber/cucumber-jvm">Cucumber JVM</a> et <a href="http://docs.seleniumhq.org/">Selenium</a> au travers de <a href="https://github.com/FluentLenium/FluentLenium">FluentLenium</a>.</div><br /><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En effet, pour rappel, FluentLenium permettait d'abstraire Selenium en lui offrant une API plus <i>fluent</i> mais également en lui apportant nativement ce qu'il préconise, à savoir le <a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a>. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, j'avais proposé d'utiliser la délégation de l'initialisation de FluentLenium à une classe tierce injectée via le mécanisme d'injection de Cucumber JVM.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cependant, suite à discussion avec la créatrice de FluentLenium (à savoir <a href="https://twitter.com/mathildelemee">Mathilde</a>), on s'est rendu compte que l'axe utilisé était légèrement biaisé (même s'il fonctionnait...).  </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cet article revient donc sur ce point en proposant une solution plus simple mais présentera également comment il est possible de tester le scénario Cucumber avec différents navigateurs et il y aura un petit mot sur l'utilisation de navigateurs déportés (via les RemoteWebDriver de Selenium 2).  </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, il sera découpé en 3 parties qui couvriront des usecases différents se traduisant donc par des implémentations différentes : </div><ul><li style="text-align: justify;">cas de tests pour un site simple,</li><li style="text-align: justify;">cas de tests pour un site complet,</li><li style="text-align: justify;">cas de tests multi-navigateurs pour un site complet.</li></ul><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A noter que je ne reviendrai pas sur les principes des différents frameworks/concepts mais juste sur comment il est possible d'implémenter ces différents usecases. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A noter également que l'article précédent aurait pu être modifié mais qu'en raison du nombre important de changements, il était plus simple d'en initier un autre...</div><!-- more --><br /><h1>Cas de tests pour un site simple</h1><h2>Présentation et proposition d'implémentation</h2><div style="text-align: justify;">Ce premier cas d'usage couvre le cas : "j'ai un site que je veux tester avec Cucumber JVM et l'ensemble des steps peut être réuni dans une seule et même classe." </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Bon je vois déjà la levée de bouclier : pourquoi réunir toutes les steps dans une seule et même classe. En fait, la raison du pourquoi sera expliquée un peu plus tard dans le paragraphe <i>Limites</i> de ce chapitre donc patience... ;-) </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Contrairement à la façon que j'avais présentée dans mon article précédent, il n'est pas obligatoire de déléguer la déclaration des pages <b>FluentPage</b> à une autre classe étendant <b>FluentTest</b>. En fait, il suffit juste de faire étendre la classe contenant les steps cucumber de <b>FluentAdapter</b>, d'y déclarer les pages et d'appeler dans la méthode annotée par @Before (celui de Cucumber JVM bien sûr) les méthode d'initialisation du contexte de FluentLenium. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour rappel, cette initialisation instancie le WebDriver utilisé par Selenium 2 mais également les pages (annotées par l'annotation @Page) présentes dans la classe courante (ou ses parentes) qui doit, au minimum, étendre de <b>FluentAdapter</b>. Cela se fait au travers des méthodes <b>initFluent()&nbsp;</b>et <b>initTest()</b>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Le code est donc&nbsp;extrêmement&nbsp;simple puisqu'il suffit de faire quelque chose du style : </div><pre class="brush:java; wrap-lines: false; auto-links: false">import cucumber.api.java.After;<br />import cucumber.api.java.Before;<br />import cucumber.api.java.en.Given;<br />import cucumber.api.java.en.Then;<br />import cucumber.api.java.en.When;<br />import org.fluentlenium.core.FluentAdapter;<br />import org.fluentlenium.core.annotation.Page;<br />import org.openqa.selenium.htmlunit.HtmlUnitDriver;<br /><br />import static org.fest.assertions.api.Assertions.assertThat;<br /><br />public class SimpleStep extends FluentAdapter {<br /><br /> @Page<br /> BingPage page;<br /><br /> @Before<br /> public void before() {<br />  this.initFluent(new HtmlUnitDriver());<br />  this.initTest();<br /> }<br /><br /> @Given(value = "j accede a bing")<br /> public void step1() {<br />  goTo(page);<br /> }<br /><br /> @When(value = "je recherche ([^ ]*) ")<br /> public void step2(String keyword) {<br />  fill("#sb_form_q").with(keyword);<br />  submit("#sb_form_go");<br /> }<br /><br /> @Then(value = "le titre est ([^ ]*) ")<br /> public void step3(String keyword) {<br />  assertThat(title()).contains(keyword);<br /> }<br /><br /> @After<br /> public void after(){<br />  this.quit();<br /> }<br />}<br /></pre><br /><div style="text-align: justify;">où BingPage est : </div><br /><pre class="brush:java; wrap-lines: false; auto-links: false">import org.fluentlenium.core.FluentPage;<br /><br />public class BingPage extends FluentPage {<br /><br /> @Override<br /> public String getUrl() {<br />  return "http://www.bing.com";<br /> }<br />}<br /></pre><div style="text-align: justify;">et la feature, la suivante : </div><pre class="brush:text; wrap-lines: false; auto-links: false">Feature: basic<br /><br />  Scenario: scenar1<br />    Given j accede a bing<br />    When je recherche toto<br />    Then le titre est toto <br /></pre><br /><div style="text-align: justify;">Il est intéressant de remarquer la simplicité de la chose (et rien à voir avec l'implémentation que j'avais proposé précédemment!).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A part cela, peu de choses à ajouter : le code parle de lui même...</div><br /><h2>Limites</h2><div style="text-align: justify;">On vient de voir comme il était simple de faire cohabiter FluentLenium et Cucumber JVM.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Bien sûr, il y a un mais... (ça serait trop simple sinon) : comme on peut le constater, actuellement, toutes les steps se trouvent être dans la même classe. Cependant, dans le cas d'un site web un peu plus complexe, il est courant et même encouragé de séparer les steps dans différentes classes.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Dans l'implémentation précédente, l'annotation @Before a été utilisée pour initialiser le contexte (et plus particulièrement le webDriver et les pages pour ensuite injecter le webDriver dans ces dernières).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cependant, dans le cas où les steps se trouvent être dans plusieurs classes, cela pose potentiellement un problème.  </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En effet, Cucumber JVM instancie la classe qui contient la définition de la step dès qu'il en a besoin et appelle la méthode annotée par @Before à l'instanciation de cette classe. Ainsi, dans notre cas, si les steps s'étaient trouvées dans deux classes, chacune étendant <b>FluentAdapter</b> et appelant <i>initFluent()</i> et <i>initTest()</i> dans la méthode annotée par @Before, alors cette instanciation aurait été faite deux fois et non une seule fois comme on aurait pu s'y attendre pour un même scénario donné... </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pire, les pages déclarées dans les classes n'auraient pas eu la même instance du webDriver et elles ne se seraient pas vu l'une l'autre... </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pas glop tout ça... :'( </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, l'implémentation précédente fonctionne pour des cas "simples" mais si la partie test d’acceptante/intégration avait été plus complexe, alors cela aurait empêché la réutilisation et le découplage. </div><br /><h1>Cas de tests pour un site complet</h1><h2>Présentation et proposition d'implémentation</h2><div style="text-align: justify;">Il a été vu dans le paragraphe précédent qu'il pouvait être utile de disposer de plusieurs classes disposant des implémentations des <i>fixtures</i>.</div><div style="text-align: justify;">Cependant, la question principale est de trouver comment il est possible de n'instancier qu'une seule fois par scénario le webDriver et de l'injecter dans des instances de pages propres au scénario. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">La proposition présentée dans l'article précédent (modulo qu'il ne faut pas étendre de <b>FluentTest</b> mais de <b>FluentAdapter</b>) reste viable, mais il y a plus simple. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En effet, dans la proposition faite précédemment, la classe <b>FluentTestDelegator</b> avai,t à sa charge, à la fois la déclaration des pages, et l'instanciation et l'initialisation du contexte de FluentLenium. Pour rappel, cette instanciation/initialisation était réalisée par <b><a href="http://picocontainer.codehaus.org/">Pico Container</a></b> lors de l'injection de l'instance de cette classe dans la classe contenant les fixtures. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En fait, il est plus propre, d'un point de vue séparation des concepts, de laisser à cette classe le soin de proposer les fixtures d'initialisation du webDriver tout en séparant la déclaration des pages. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cela peut être réalisé en créant une classe (<b>FluentPageInjector</b>) étendant de <b>FluentAdapter</b> qui définit les pages et de la faire étendre d'une classe (<b>FluentLeniumStepInitilizer</b>) qui définit les fixtures d'instanciation du webDriver.  </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cela offre deux avantages : les classes qui définissent les steps de navigation n'ont qu'à étendre de <b>FluentPageInjector</b> pour avoir une visibilité sur les pages (tout en continuant d'injecter via pico l'instance de <b>FluentLeniumStepInitilizer</b>) et il devient alors possible de variabiliser le webDriver à utiliser. </div><br /><pre class="brush:text; wrap-lines: false; auto-links: false">Feature: browser<br /><br />  Scenario: navigation version firefox<br />    Given I connect on url http://localhost:8080 with firefox<br />    Given j accede a la homePage<br />    And je suis sur homePage<br />    When je submit<br />    Then je suis sur la page result<br />    And driver is closed<br /><br /><br />  Scenario: navigation version chrome<br />    Given I connect on url http://localhost:8080 with chrome with parameters webdriver.chrome.driver:/opt/chromedriver/chromedriver<br />    Given j accede a la homePage<br />    And je suis sur homePage<br />    When je submit<br />    Then je suis sur la page result<br />    And driver is closed<br /><br /><br />  Scenario: navigation version phantomjs<br />    Given I connect on url http://localhost:8080 with phantomjs with parameters phantomjs.binary.path:/opt/phantomjs-1.9.0-linux-x86_64/bin/phantomjs <br />    Given j accede a la homePage<br />    And je suis sur homePage<br />    When je submit<br />    Then je suis sur la page result<br />    And driver is closed<br /></pre><pre class="brush:java; wrap-lines: false; auto-links: false">package step;<br /><br />import org.fluentlenium.core.FluentAdapter;<br />import org.fluentlenium.core.annotation.Page;<br />import page.HomePage;<br />import page.ResultPage;<br /><br />public class FluentPageInjector extends FluentAdapter {<br />    @Page<br />    protected HomePage homePage;<br /><br />    @Page<br />    protected ResultPage resultPage;<br />} <br /></pre><br /><div style="text-align: justify;">On remarque, comme dit plus haut, que cette classe n'a qu'un seul rôle qui est de déclarer les pages tout en étendant de <b>FluentAdapter</b>.  </div><div style="text-align: justify;"><br /></div><pre class="brush:java; wrap-lines: false; auto-links: false">public class HomePageStep extends FluentPageInjector {<br /><br />     public HomePageStep(FluentLeniumStepInitilizer delegator) {<br />      this.homePage = delegator.homePage;<br />      this.resultPage = delegator.resultPage;<br />     }<br /><br /><br />     @Given("^j accede a la homePage$")<br />     public void j_accede_a_homePage() {<br />      goTo(homePage);<br />     }<br /><br />     @Given("^je suis sur homePage$")<br />     public void je_suis_sur_homePage() {<br />      homePage.isAt();<br />     }<br /><br />     @When("^je submit$")<br />     public void je_submit() throws Throwable {<br />      homePage.submit();<br />     }<br />}<br /></pre><br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class ResultPageStep extends FluentPageInjector {<br /><br />    public ResultPageStep(FluentLeniumStepInitilizer delegator) {<br />        this.resultPage = delegator.resultPage;<br />    }<br /><br />    @When("^je suis sur la page result$")<br />    public void je_suis_sur_la_page_result() throws Throwable {<br />        resultPage.isAt();<br />    }<br /><br />} <br /></pre><br /><div style="text-align: justify;">Ces classes correspondent aux classes qui définissent les fixtures. Elles étendent de <b>FluentPageInjector</b> de façon à pouvoir bénéficier de la visibilité sur les pages. Par contre, il est intéressant de constater que, dans son constructeur, la classe <b>FluentLeniumStepInitializer</b> est injecté via Pico Container. Cela permet d'affecter la valeur des pages.</div><br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class FluentLeniumStepInitilizer extends FluentPageInjector {<br /><br />    @Given("^I connect on url ([^ ]*) with ([^ ]*) with parameters ([^ ]*)$")<br />    public void browser_connect(String host, String browser, String parameters) {<br />        init(host, browser, parameters);<br />    }<br /><br />    @Then("^drivers are closed")<br />    public void close() {<br />        this.quit();<br />    }<br /><br />    @After<br />    public void afterClose() {<br />        this.quit();<br />    }<br /><br />    private void init(String host, String browserName, String parametersLine) {<br />        Browser browser = null;<br /><br />        DesiredCapabilities capabilities = new DesiredCapabilities();<br /><br />        String[] parameters = parametersLine.slip(";");<br />        for (String parameter : parameters) {<br />            if (!parameter.isEmpty()) {<br />                String[] key_value = parameter.split(":");<br />                capabilities.setCapability(key_value[0], key_value[1]);<br />            }<br />        }<br /><br />        browser = Browser.getBrowser(browserLine.get(0));<br />        capabilities.setBrowserName(browser.getName());<br /><br />        initWebDriver(host, browserHost, browser, capabilities);<br />    }<br /><br />    private void initWebDriver(String host, String browserHost, Browser browser, DesiredCapabilities capabilities) {<br />        Fluent fluent = null;<br />        WebDriver driver = null;<br />        if (browser != null) {<br />            driver = BrowserMapper.getDriver(browser, capabilities);<br />            fluent = this.initFluent(driver);<br />        }<br /><br />        fluent.withDefaultUrl(host);<br />        this.initTest();<br />    }<br />}<br /></pre><br /><div style="text-align: justify;">Cette classe étend par transitivité <b>FluentAdapter</b> et dispose donc de la visibilité sur les méthodes d'initialisation de <b>FluentLenium</b>. En outre, en étendant <b>FluentPageInjector</b> (qui étend de <b>FluentAdapter</b>), cela lui permet, à l'appel de <i>initTest(),</i>&nbsp;d'initialiser les pages.</div><div style="text-align: justify;">Concernant l'initialisation des webDriver, cela est fait au niveau de la classe <b>BrowserMapper</b>.  </div><br /><pre class="brush:java; wrap-lines: false; auto-links: false">public enum Browser {<br />    HTMLUNIT("default"),<br />    FIREFOX("firefox"),<br />    CHROME("chrome"),<br />    PHANTOMJS("phantomjs");<br /><br />    private String name;<br /><br />    Browser(String name) {<br />        this.name = name;<br />    }<br /><br />    public String getName() {<br />        return this.name;<br />    }<br /><br />    public static Browser getBrowser(String name) {<br />        for (Browser browser : values()) {<br />            if (browser.getName().equalsIgnoreCase(name)) {<br />                return browser;<br />            }<br />        }<br />        return HTMLUNIT;<br />    }<br />}<br /></pre><pre class="brush:java; wrap-lines: false; auto-links: false">import org.openqa.selenium.Capabilities;<br />import org.openqa.selenium.WebDriver;<br />import org.openqa.selenium.chrome.ChromeDriver;<br />import org.openqa.selenium.firefox.FirefoxDriver;<br />import org.openqa.selenium.htmlunit.HtmlUnitDriver;<br />import org.openqa.selenium.phantomjs.PhantomJSDriver;<br /><br />import java.util.HashMap;<br />import java.util.Map;<br /><br />public class BrowserMapper {<br /> private String name;<br /><br /> private static Map&lt;Browser, WebDriverLazyLoader&gt; browserMapper = new HashMap&lt;Browser, WebDriverLazyLoader&gt;();<br /><br /> static {<br />  browserMapper.put(Browser.CHROME, new WebDriverLazyLoader(ChromeDriver.class));<br />  browserMapper.put(Browser.FIREFOX, new WebDriverLazyLoader(FirefoxDriver.class));<br />  browserMapper.put(Browser.HTMLUNIT, new WebDriverLazyLoader(HtmlUnitDriver.class));<br />  browserMapper.put(Browser.PHANTOMJS, new WebDriverLazyLoader(PhantomJSDriver.class));<br /> }<br /><br /> public static WebDriver getDriver(Browser browser, Capabilities capabilities) {<br />  WebDriverLazyLoader webDriverLazyLoader = browserMapper.get(browser);<br />  if (webDriverLazyLoader != null) {<br />            if (browser == Browser.PHANTOMJS) {<br />                return webDriverLazyLoader.getWebDriverClass(capabilities);<br /><br />            } else if (browser == Browser.CHROME) {<br />                System.setProperty("webdriver.chrome.driver", (String) capabilities.getCapability("webdriver.chrome.driver"));<br />                return webDriverLazyLoader.getWebDriverClass(capabilities);<br /><br />            } else {<br />                return webDriverLazyLoader.getWebDriverClass();<br />            }<br />  }<br />  return browserMapper.get(Browser.HTMLUNIT).getWebDriverClass();<br /> }<br />} <br /></pre><br /><div style="text-align: justify;">Cette classe permet de faire le pont avec les webDriver qu'il est possible d'utiliser. Cependant, la petite astuce consiste à instancier de manière "Lazy" ces derniers.</div><div style="text-align: justify;">En effet, appeler le constructeur d'un webDriver l'instancie mais le démarre également (ie. que la fenêtre du navigateur s'ouvre réellement). Du coup, la petite classe présentée ci-dessous a été utilisée.  </div><br /><pre class="brush:java; wrap-lines: false; auto-links: false">import org.openqa.selenium.Capabilities;<br />import org.openqa.selenium.WebDriver;<br /><br />class WebDriverLazyLoader {<br />    private Class webDriverClass;<br /><br /><br />    public WebDriverLazyLoader(Class webDriverClass) {<br />        this.webDriverClass = webDriverClass;<br />    }<br /><br />    public WebDriver getWebDriverClass() {<br />        try {<br />            return (WebDriver)this.webDriverClass.newInstance();<br />        } catch (ReflectiveOperationException e) {<br />            e.printStackTrace();<br />        }<br />        return null;<br />    }<br /><br />    public WebDriver getWebDriverClass(Capabilities capabilities) {<br />        try {<br />            return (WebDriver)this.webDriverClass.getConstructor(Capabilities.class).newInstance(capabilities);<br />        } catch (ReflectiveOperationException e) {<br />            e.printStackTrace();<br />        }<br />        return null;<br />    }<br />} <br /></pre><br /><h2>Limites</h2><div style="text-align: justify;">Comme on a pu le voir dans ce chapitre, il est aisé de partager les fixtures Cucumber JVM dans des classes différentes tout en bénéficiant de FluentLenium.  </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cependant, pour certains besoins, il peut être utile de vouloir lancer les tests d'acceptance/intégration sur différents navigateurs. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Bien sûr, chaque step pourrait boucler sur l'ensemble des navigateurs sur lesquels les tests doivent être exécutés, mais cela induirait des problématiques d'entrelacement des actions et donc soulèverait des problématiques comme la gestion d'un contexte par webDriver, l'accès à un rapport "illisible" ou un manque de contrôle sur les préconditions du test qui sont, généralement, lié au scénario et non à une Step. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Le chapitre suivant tentera de répondre à cette problématique en proposant un moyen de "boucler" sur le scénario avec différents navigateurs. </div><br /><h1>Cas de tests multi-navigateurs pour un site complet</h1><h2>Présentation et proposition d'implémentation</h2><div style="text-align: justify;">Il a été vu dans le chapitre précédent comment il était possible d'exécuter des tests d'acceptances/intégration sur un navigateur donné.  </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ce chapitre présentera, pour sa part, une façon de les lancer sur différents navigateurs sans avoir à faire de copier/coller ;-). </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En fait, Cucumber JVM permet nativement de boucler sur un scénario en utilisant différents paramètres. Cela se fait par le mécanisme de <b>scénario outline</b>. </div><br /><pre class="brush:text; wrap-lines: false; auto-links: false">Feature: multibrowser<br /><br />  Scenario Outline: multi browser navigation version 1:<br />    Given I connect on url http://localhost:8080 with &lt;browser&gt; with parameters &lt;parameters&gt;<br />    Given j accede a la homePage<br />    And je suis sur homePage<br />    When je submit<br />    Then je suis sur la page result<br />    And driver is closed<br />  Examples:<br />    | browser | parameters                                             | <br />    | firefox |                                                        | <br />    | default |                                                        | <br />    | chrome  | webdriver.chrome.driver:/opt/chromedriver/chromedriver | <br /></pre><br /><div style="text-align: justify;">Et... c'est tout!</div><div style="text-align: justify;">Le code n'a pas à être modifié : Cucumber JVM s'occupe de tout! ;-) </div><br /><h2>Limites</h2><div style="text-align: justify;">On a vu dans le paragraphe précédent comment il était possible d'exécuter facilement des tests d'acceptance/intégration en s'appuyant sur la notion de scénario outline offerte nativement par Cucumber JVM. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Coté limitation, je n'en vois pas trop...</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Peut être le fait de ne pas instancier le webDriver pour chaque scénario (opération assez coûteuse en temps) mais cela est aisément résolvable en utilisant une sorte de cache de webDriver fonctionnant sur le principe de singleton qui serait réinialisé lors de l'appel à la step <i>drivers are closed</i> qui serait isolée dans son propre scénario outline : </div><br /><pre class="brush:text; wrap-lines: false; auto-links: false">  Scenario Outline: browsers are closed:<br />    Then driver is closed<br />  Examples:<br />    | browser   | parameters                                                            | <br />    | firefox   |                                                                       | <br />    | default   |                                                                       | <br />    | phantomjs | phantomjs.binary.path:/opt/phantomjs-1.9.0-linux-x86_64/bin/phantomjs | <br />    | chrome    | webdriver.chrome.driver:/opt/chromedriver/chromedriver                |     <br /></pre><br /><h1>Conclusion</h1><div style="text-align: justify;">Il a été présenté dans cet article comment il était possible d'implémenter l'intégration de Cucumber JVM et de Selenium à l'aide de FluentLenium. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cet article n'a, cependant, pas fait mention de l'exécution des tests sur des navigateurs distants via les <b>RemoteWebDriver</b> mais cela est tout à fait possible (même si le code montré ici ne le présente pas) et est même totalement fonctionnel : pour ce faire (code disponible <a href="https://github.com/jetoile/fluentlenium-cucumber/tree/multiNav">ici</a>), il suffit de fournir, entre autre, des paramètres supplémentaires comme l'url de&nbsp;connexion&nbsp;au hub Selenium et d'instancier un <b>RemoteWebDriver</b> plutôt que le webDriver. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">De même, le code permettant d'instancier à la mode singleton les webDriver est&nbsp;disponible&nbsp;<a href="https://github.com/jetoile/fluentlenium-cucumber/blob/multiNav/src/test/java/step/FluentLeniumStepInitilizer.java">ici</a> (voir la méthode <i>initCachedWebDriver()</i> de la classe <b>FluentLeniumStepInitilizer</b>). </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Enfin, un dernier mot sur la façon dont il est possible d'exécuter tout ce beau monde (comme ça, je réponds à la remarque très pertinente de <a href="https://twitter.com/josepaumard">José</a> ;-) ) parce que faire des tests, c'est bien, les jouer, c'est mieux! </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il est possible de jouer les tests d'au moins trois manières distinctes : une orienté "vraie vie" (ie. utilisable au sein d'un build maven et donc exécutable via une usine d'intégration continue) et deux autres plutôt orientés&nbsp;développement.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, pour jouer les tests via maven, il suffit de le déclarer dans le pom.xml le plugin failsafe en le branchant sur la "bonne phase", à savoir le runner Cucumber JVM :   </div><br /><pre class="brush:xml; wrap-lines: false; auto-links: false">&lt;plugin&gt;<br />    &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;<br />    &lt;executions&gt;<br />        &lt;execution&gt;<br />            &lt;goals&gt;<br />                &lt;goal&gt;integration-test&lt;/goal&gt;<br />                &lt;goal&gt;verify&lt;/goal&gt;<br />            &lt;/goals&gt;<br />        &lt;/execution&gt;<br />    &lt;/executions&gt;<br />    &lt;configuration&gt;<br />        &lt;includes&gt;<br />            &lt;include&gt;**/BasicRunner.java&lt;/include&gt;<br />        &lt;/includes&gt;<br />    &lt;/configuration&gt;<br />&lt;/plugin&gt;<br /></pre><br /><div style="text-align: justify;">Coté jouabilité des tests sur un environnement de&nbsp;développement&nbsp; il est possible d'exécuter le <b>Runner</b> Cucumber JVM directement (comme lors de l'exécution d'une classe de test unitaire) ou d'utiliser le plugin Cucumber JVM proposé par notre IDE préféré (pour moi IntelliJ, pour les autres, je ne sais pas...). </div><br /><pre class="brush:java; wrap-lines: false; auto-links: false">import cucumber.api.junit.Cucumber;<br />import org.junit.runner.RunWith;<br /><br />@RunWith(Cucumber.class)<br />@Cucumber.Options(features = "classpath:fr/jetoile/webapp/acceptance", format = {"pretty", "html:target/cucumber", "json:target/cucumber.json"})<br />public class RunCucumberFeatures {<br />}<br /></pre><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-RGW7oSAChOQ/UWXmqPsYh6I/AAAAAAAAA4Y/cDH-YyVcpgs/s1600/screenshot01.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="302" src="http://4.bp.blogspot.com/-RGW7oSAChOQ/UWXmqPsYh6I/AAAAAAAAA4Y/cDH-YyVcpgs/s400/screenshot01.png" width="400" /></a></div><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-FkF8ZO6r6co/UWXnUNjqjII/AAAAAAAAA4g/obtSC7BS6kI/s1600/screenshot02.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="186" src="http://3.bp.blogspot.com/-FkF8ZO6r6co/UWXnUNjqjII/AAAAAAAAA4g/obtSC7BS6kI/s400/screenshot02.png" width="400" /></a></div><br /><br /><div style="text-align: justify;">Enfin, pour rappel, mon usecase étant de tester mon application web en boite noire, un prérequis était que mon application web soit démarrée au préalable.</div><div style="text-align: justify;">Pour ce faire, le plugin maven Jetty (ou Tomcat au choix) a été utilisé et branché sur la phase de pré-integration.</div><div style="text-align: justify;">Lors de l'exécution des tests en mode développement (ie. en les lançant comme un TU ou à l'aide du plugin Cucumber JVM via l'IDE), un profil n'exécutant pas le plugin failsafe mais uniquement le démarrage du jetty/tomcat embarqué a été utilisé. </div><br /><h1>Pour aller plus loin...</h1><ul><li>article sur les limitations de Cucumber JVM pour le partage de données entre steps : <a href="http://zsoltfabok.com/blog/2012/09/cucumber-jvm-hooks/">http://zsoltfabok.com/blog/2012/09/cucumber-jvm-hooks/</a></li><li>page de fluentLenium : <a href="https://github.com/FluentLenium/FluentLenium">https://github.com/FluentLenium/FluentLenium</a></li><li>page des webDriver de Selenium : <a href="http://docs.seleniumhq.org/docs/03_webdriver.jsp">http://docs.seleniumhq.org/docs/03_webdriver.jsp</a></li><li>code : <a href="https://github.com/jetoile/fluentlenium-cucumber">http://github.com/jetoile/fluentlenium-cucumber/</a></li></ul></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Khanh Tuong Maudoux</div>
<div class='content'>
Cool. Merci pour le commentaire!<br /><br />Khanh</div>
</div>
<div class='comment'>
<div class='author'>Thierry LER</div>
<div class='content'>
Vraiment super article. Merci.</div>
</div>
</div>
