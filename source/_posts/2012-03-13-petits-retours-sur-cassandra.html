---
layout: post
title: "Petits retours sur Cassandra"
date: 2012-03-13
comments: false
categories:
 - java
 - réflexion
 - cassandra
 - architecture
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-IvTZebKJhAc/T1hsV7nG8nI/AAAAAAAAAjw/qFiNLqvXgnY/s1600/cassandra01.png" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img alt="" border="0" height="79" src="http://2.bp.blogspot.com/-IvTZebKJhAc/T1hsV7nG8nI/AAAAAAAAAjw/qFiNLqvXgnY/s320/cassandra01.png" width="320" /></a></div><div style="text-align: justify;">Suite à de nombreuses présentations de Cassandra (faites, entre autre, par <a href="http://twitter.com/mfiguiere">Michaël Figuière</a>) et à une opportunité de regarder plus précisément ce qui se cachait réellement derrière cette implémentation d'une solution de la famille des produits NoSQL orienté colonnes, je vais, dans cet article, tenter de décrire ce que j'ai aimé et ce que je n'ai pas aimé sur <a href="http://cassandra.apache.org/">Apache Cassandra</a>.</div><div style="text-align: justify;">Je tiens toutefois à préciser que je n'ai aucune expérience réelle sur le produit et que je ne m'appuierai donc que sur sa <a href="http://www.datastax.com/doc-source/pdf/cassandra10.pdf">documentation officielle</a>&nbsp;en version 1.0 qui date du 2 mars 2012.</div><div style="text-align: justify;">En outre, je ne m'attarderai que sur les points qui m'ont&nbsp;semblé&nbsp;intéressants et marquants.</div><div style="text-align: justify;">Pour ceux qui sont coutumiés de ce blog, je ne changerai pas mes habitudes et je me contenterai seulement de traduire de manière libre les passages qui m'ont intéressés ;-). A noter que de nombreux points sont rappelés à différents endroits dans ce document mais c'est également le cas dans la documentation officielle.</div><!-- more --><h1>          Introduction et concepts</h1><div style="text-align: justify;">Apache Cassandra est un système permettant de gérer une grande quantité de données de manière distribué. Ces dernières peuvent être structurées, semi structurées ou non.</div><div style="text-align: justify;">En fait, Cassandra est été conçu pour être hautement scalable sur un grand nombre de serveurs tout en ne présentant pas de <i>Single Point Of Failure</i>.</div><div style="text-align: justify;">Enfin, Cassandra fourni un schéma de données dynamique afin d'offrir un maximum de flexibilité et de performance.</div><div style="text-align: justify;">Derrière ce jolie discour se cachent quelques termes qu'il est important de connaitre afin de mieux appréhender les différents concepts manipulés par Cassandra :</div><ul><li style="text-align: justify;"><em><b>Keyspace</b></em> : c'est l'équivalent d'une database dans le monde des bases de données relationnel. A noter qu'il est possible d'avoir plusieurs <em>Keyspaces</em> sur un même serveur.&nbsp;</li><li style="text-align: justify;"><em><b>Une famille de colonnes</b></em> : c'est l'objet principal de données et peut être assimilé à une table dans le monde des bases de données relationnel.</li></ul><div><h1>          Architecture de Cassandra</h1></div><div><div style="text-align: justify;">Une instance Cassandra est un collection de noeuds indépendants qui sont configurés ensembles pour former un cluster.</div><div style="text-align: justify;">Dans un cluster, tous les noeuds sont égaux, ce qui signifie qu'il n'y a pas de noeud&nbsp;maître&nbsp;ou un processus centralisant leur gestion.</div><div style="text-align: justify;">En fait, Cassandra utilise un protocole appelé <i><b>Gossip</b></i> afin de découvrir la localisation et les information sur l'état des autres noeuds du cluster. Le protocole <i>Gossip</i> est un protocole de communication de type <i>peer-to-peer</i> dans lequel les noeuds échangent périodiquement des informations sur leur état mais également sur ce qu'ils savent des autres noeuds.</div><div style="text-align: justify;">Pour être plus précis, le processus s'exécute toutes les secondes afin d'échanger les messages avec au plus trois autres noeuds du cluster. De plus, une version est associée à ces messages afin de permettre d'écraser les informations plus anciennes.</div><div style="text-align: justify;">Ainsi, quand un noeud démarre, il regarde, dans un premier temps, son fichier de configuration qui le renseigne sur le nom de son cluster ainsi que les autres noeuds compris dedans. Cela lui permet de les contacter afin de récupérer leur état.</div><div style="text-align: justify;">Cependant, afin d'éviter un partitionnement, tous les noeuds du cluster doivent disposer de la même liste de noeuds dans leurs fichiers de configuration.</div><div style="text-align: justify;">La détection des échecs est une méthode pour déterminer localement si un autre noeud est accessible ou pas. En outre, les informations récoltées par ce mécanisme permet à Cassandra d'éviter d'émettre des requêtes aux noeuds qui ne sont plus accessibles.</div><div style="text-align: justify;">En fait, ce mécanisme fonctionne sur le principe de <i>heartbeat</i> soit de manière directe (ie. en récoltant les informations directement des noeuds) soit de manière indirecte (ie. en récoltant les informations par l'intermédiaire de la connaissance des autres noeuds - par transitivité quoi... ;-) - ).</div><div style="text-align: justify;">Je ne décrirai pas plus précisément cette partie si ce n'est une petite précision. En fait, lorsqu'un noeud est déclaré comme inaccessible, les autres noeuds stockent messages&nbsp;susceptibles&nbsp;d'avoir été manqué par ce noeud. Cependant, il peut arriver qu'entre le moment où le noeud devient inaccessible et le moment où sa perte est détectée, un laps de temps s'écoule et qu'ainsi, les réplicas ne soient pas conservés. En outre, si le noeud vient à être indisponible pendant une période trop importante&nbsp;(par défaut,&nbsp;une heure), alors les messages ne sont plus stockés. C'est pour cette raison qu'il&nbsp;est conseillé d'exécuter régulièrement l'outils de réparation des données.</div><h1>          Partitionnement des données avec Cassandra</h1><div style="text-align: justify;">Concernant cette partie, je ne m'étendrai pas dessus puisque la documentation est suffisante à elle-même.</div><div style="text-align: justify;">Cependant, juste un point qui m'a chagriné.</div><div style="text-align: justify;">En effet, il est possible de configurer le partitionnement pour une famille de colonnes&nbsp;en précisant que l'on veut que cela soit géré avec une stratégie de type&nbsp;<em>Ordered Partitioners</em>.</div><div style="text-align: justify;">Ce mode peut, en effet, avoir un intérêt si l'on souhaite récupérer une plage de lignes comprise entre deux valeurs (chose qui n'est pas possible si le <i>hash MD5</i> des clés des lignes est utilisé).</div><div style="text-align: justify;">Cependant, il est conseillé d'utiliser plutôt une clé deuxième clé d'indexation positionnée sur la colonne contenant les informations voulues. En effet, utiliser la stratégie <em>Ordered Partitionners </em>a les conséquences suivantes :</div><ul><li style="text-align: justify;">L'écriture séquentielle peut&nbsp;entraîner&nbsp;des <i>hotspots</i> :&nbsp;si l'application tente d'écrire ou de mettre à jour un ensemble séquentiel de lignes, alors l'écriture ne sera pas distribué dans le cluster.</li><li style="text-align: justify;">Un&nbsp;<i>overhead</i> accru pour l'administration du <i>load balancer</i> dans le cluster : les administrateurs doivent calculer manuellement les plages de jetons afin de les répartir dans le cluster.</li><li style="text-align: justify;">Répartition&nbsp;inégale&nbsp;de charge pour des familles de colonnes multiples.</li></ul><h1>          La répartition dans Cassandra</h1><div style="text-align: justify;">La réplication est le processus permettant de stocker des copies des données sur de multiples noeuds afin de permettre leur fiabilité et la tolérance à la panne. Quand un <i>keyspace</i> est créé dans Cassandra, il lui est affecté la stratégie de distribution des réplicas, c'est à dire le nombre de réplicas et la manière dont ils sont répliqués dans le cluster. La stratégie de réplication repose sur la configuration du cluster <em>snitch </em>afin de déterminer la localisation physique des noeuds ainsi que leur proximité par rapport aux autres.</div><div style="text-align: justify;">Il est souvent fait référence au facteur de réplication (<em>replication factor</em>) pour parler du nombre total de réplicas dans le cluster.</div><div style="text-align: justify;">Aussi :</div><ul><li style="text-align: justify;">Un facteur de réplication de 1 signifie qu'il n'y a qu'une seule copie de chaque ligne.</li><li style="text-align: justify;">Un facteur de réplication de 2 signifie qu'il existe deux copie de chaque ligne.</li><li style="text-align: justify;">...</li></ul><div style="text-align: justify;">Tous les réplicas possèdent la même importance : il n'y a pas de réplicas principaux ou&nbsp;maîtres&nbsp;du point de vu de la lecture et de la lecture.</div><div style="text-align: justify;">Ainsi, la règle générale est que le facteur de réplication ne doit pas être supérieur au nombre de noeuds dans le cluster. Cependant, il est possible d'augmenter le facteur de réplication puis d'ajouter le nombre de noeuds désiré à postériori. A noter toutefois que lorsque le facteur de réplication est supérieur au nombre de noeuds, alors les écritures ne sont plus prises en compte tandis que l'opération de lecture reste viable tant que le&nbsp;degrés&nbsp;de&nbsp;consistance&nbsp;est respecté.</div><div style="text-align: justify;">Concernant les stratégies de distribution des réplicas, cela permet de jouer sur la façon dont les réplicas sont répartis dans le cluster pour un <i>keyspace</i>. Cette stratégie est à renseigner lors de la création de la <i>keyspace</i>.</div><div style="text-align: justify;">De plus, il est possible de configurer la manière dont les noeuds sont groupés ensemble dans la topology du réseau global. Cet élément de configuration correspond au <em>snitch</em>&nbsp;et est associé au cluster. Cassandra utilise alors cette information pour router les requêtes entre les noeuds.</div><div style="text-align: justify;">Je n'en dirai pas plus pour cette partie mais plus d'informations sont accessibles dans la documentation officielle.</div><h1>          Cassandra du point de vue de l'application Client</h1><div style="text-align: justify;">Tous les noeuds de Cassandra sont égaux. Ainsi, une demande de lecture ou d'écrire peut interroger&nbsp;indifféremment&nbsp;n'importe quel noeud du cluster. Quand un client se connecte à un noeud et demande une opération d'écriture ou de lecture, le noeud courant sert de coordinateur du point de vue du client.</div><div style="text-align: justify;">Le travail du coordinateur est de se comporter comme un proxy entre le client de l'application et les noeuds qui possèdent la données. C'est lui qui a la charge de déterminer quels noeuds de l'anneau devra recevoir la requête.</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-Y_ErJ1Xzjwk/T1jQ9lh4oDI/AAAAAAAAAj4/Y_MOdH2_2mk/s1600/cassandra02.png" style="margin-left: auto; margin-right: auto;"><img alt="" border="0" height="219" src="http://4.bp.blogspot.com/-Y_ErJ1Xzjwk/T1jQ9lh4oDI/AAAAAAAAAj4/Y_MOdH2_2mk/s320/cassandra02.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><br /><div style="text-align: justify;">Concernant les requêtes d'écriture, le coordinateur émet la requête à tous les réplicas qui possèdent la ligne à modifier. Aussi longtemps qu'il sont disponibles, ils reçoivent les demandes d'écriture quelque soit le niveau de consistance demandé par le client. Le niveau de&nbsp;consistance&nbsp;d'écriture détermine le nombre de noeuds qui doivent&nbsp;acquitter l'écriture afin de considérer l'écriture comme ayant réussi.</div><div style="text-align: justify;">Il est à noter que, dans le cas où il existe plusieurs <em>data center deployments</em>, Cassandra optimise les performances d'écriture en choisissant un noeud coordinateur dans chaque <i>data center</i> distant afin de traiter les requêtes des réplica dans le <em>data center</em>. Le noeud coordinateur contacté par l'application cliente n'a alors qu'à transmettre les requêtes d'écriture à un seul noeud de chaque <em>data center</em> distant.</div><div style="text-align: justify;">Si le niveau de consistance choisi est ONE ou LOCAL_QUORUM, alors seuls les noeuds du même <em>data center</em> que le noeud coordinateur doivent acquitter l'écriture.</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-_TFMEXBbdSo/T1jRBazh_wI/AAAAAAAAAkA/7uBwOjhPb5s/s1600/cassandra03.png" style="margin-left: auto; margin-right: auto;"><img alt="" border="0" height="158" src="http://1.bp.blogspot.com/-_TFMEXBbdSo/T1jRBazh_wI/AAAAAAAAAkA/7uBwOjhPb5s/s400/cassandra03.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><br /><div style="text-align: justify;">Concernant la lecture, il y a deux types de requêtes de lecture qu'un coordinateur peut émettre à un réplica :</div><ul><li style="text-align: justify;">Une requête de lecture directe. Dans ce cas, le nombre de réplicats contactés par une demande de lecture directe est déterminé par le niveau de consistance spécifié par le client,</li><li style="text-align: justify;">Une requête de réparation de lecture en tâche de fond. Dans ce cas, elle est envoyée à tous les réplicas additionels qui n'ont pas reçu de requête directe. Ce type de requête permet de vérifier que la ligne est consistante par rapport aux autres réplicas.</li></ul><div><div style="text-align: justify;">Ainsi, dans un premier temps, le coordinateur contacte les réplicas en fonction du niveau de consistance qui a été spécifié. Ces réplicas sont choisis en fonction de leurs capacités à répondre rapidement. Ces derniers répondent avec la donnée demandé et, s'il existe plusieurs réponses, elles sont comparées en mémoire afin de vérifier leur consistance. Si ce n'est pas le cas, alors c'est le réplica qui est le plus récent (en se basant sur le <em>timestamp</em>) qui est utilisé par le coordinateur pour répondre au client.</div></div><div><div style="text-align: justify;">En outre, afin de s'assurer que tous les réplicas ont la version la plus récente, le coordinateur les contacte en tâche de fond et compare la donnée de tous les réplicas restant qui possède la ligne. Il demande ensuite, éventuellement, une opération d'écriture afin de mettre à jour la donnée. C'est cette opération qui est appelé <em>read repair </em>et qui peut être configuré par famille de colonne (par défaut, elle est désactivée).</div></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-uK_LgOrv6w8/T1jUQ2yvdDI/AAAAAAAAAkI/GQewQ8NmdTc/s1600/cassandra04.png" style="margin-left: auto; margin-right: auto;"><img alt="" border="0" height="215" src="http://4.bp.blogspot.com/-uK_LgOrv6w8/T1jUQ2yvdDI/AAAAAAAAAkI/GQewQ8NmdTc/s320/cassandra04.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><h1>          Le modèle de données de Cassandra</h1><div><div style="text-align: justify;">Le modèle de données de Cassandra s'appuie sur un schéma dynamique, avec un modèle de données orienté colonne.</div></div><div><div style="text-align: justify;">Cela signifie que, contrairement à une base de données relationelle, il n'est pas nécessaire de modéliser toutes les colonnes puisqu'une ligne n'a, potentiellement, pas le même ensemble de colonnes.</div></div><div><div style="text-align: justify;">Les colonnes et leurs méta données peuvent être ajoutées par l'application lorsque cela s'avère nécessaire.</div></div><div><div style="text-align: justify;">En fait, le modèle de données de Cassandra a été pensé pour répondre à des problématiques de données distribuées et diffère complètement d'un modèle classique de base de données relationnel où les données sont stockées dans des tables qui sont, dans la plupart des cas, en relation entre elles. En outre, dans un modèle&nbsp;relationnel, les données sont généralement normalisées afin d'éviter la redondance et des jointures sont faites entre les tables sur des clés communes afin de satisfaire les requêtes.</div></div><div><div style="text-align: justify;">Dans Cassandra, le <em>Keyspace</em>&nbsp;est le conteneur des données de l'application (un peu comme une database ou un schéma pour une base de données relationnel). Dans ces <em>keyspaces</em> se trouvent une ou plusieurs familles de colonnes (qui correspondent aux tables en base de données&nbsp;relationnelle).</div></div><div><div style="text-align: justify;">Ces familles de colonnes contiennent des colonnes ainsi qu'un ensemble de colonnes connexes qui sont identifiées par un clé de ligne. En outre, chaque ligne d'une famille de colonnes ne dispose pas nécessairement des mêmes colonnes qu'une autre ligne.</div></div><div><div style="text-align: justify;">Enfin, Cassandra n'impose pas de relations entre les familles de colonnes au sens base de données relationnelle : il n'y a pas de clés étrangères et les jointures entre familles de colonnes ne sont pas supportées.</div></div><div><div style="text-align: justify;">Ainsi, pour faire simple, chaque famille de données dispose de son ensemble de colonnes qui sont destinées à être consulté ensemble pour satisfaire les requêtes spécifiques à l'application.&nbsp;</div></div><div><div style="text-align: justify;">En outre, les familles de colonnes peuvent définir les méta données des colonnes mais pour une colonne donnée correspondant à une ligne, cela est à la charge de l'application. De plus, chaque ligne peut disposer d'un ensemble de colonnes différentes.</div></div><div><div style="text-align: justify;">Par contre, bien que les familles de colonnes puissent être flexibles, dans la pratique, il est conseillé d'y associer une sorte de schéma (à une famille de colonnes, il est préférable de n'y mettre qu'un même type de données).</div></div><div><div style="text-align: justify;">En fait, il y a deux types de familles de colonnes :</div></div><div><ul><li style="text-align: justify;"><b>Les familles de colonnes statiques</b> : elles utilisent un ensemble statique de nom de colonnes et sont très similaires à une table d'une base de données relationnel même si toutes les colonnes n'ont pas à être obligatoirement renseignées. A noter, qu'en général, les méta données des colonnes sont définies, dans ce cas, pour chaque colonne.</li><li style="text-align: justify;"><b>Les familles de colonnes dynamiques</b> : elles permettent, par exemple, de pré calculer un ensemble de résultats et de les stocker dans une même ligne afin de pouvoir y accéder plus tard. Chaque ligne correspond donc à un snapshot de données correspondant à un requête donnée. A noter que, pour une famille de colonnes dynamique, plutôt que d'avoir des méta données pour chaque colonne, le type des informations par colonnes (tels que le comparateur et les validateurs) est défini par l'application lorsque la donnée est insérée.</li></ul></div><div><div style="text-align: justify;">Pour toutes les familles de colonnes, chaque ligne est identifiée de manière unique par sa clé (un peu comme la notion de clé primaire pour les bases de données relationnelles). Une famille de colonnes est, quant à elle, toujours partitionnée par ses clés de ligne qui sont, implicitement, indexées.</div></div><div><div style="text-align: justify;">En fait, &nbsp;dans Cassandra, une colonne est le plus petit incrément de données. Elle est modélisée par un tuple qui contient le nom, la valeur et un <em>timestamp</em>. Ce timestamp est utilisé par Cassandra pour déterminer la mise à jour la plus récente dans la colonne (et, dans ce cas, c'est la plus récente qui est prioritaire lors d'une requête).&nbsp;</div></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-a0aThYoPwxU/T1nHhEkkeiI/AAAAAAAAAkQ/N5n7HZJ1Gb8/s1600/cassandra05.png" style="margin-left: auto; margin-right: auto;"><img alt="" border="0" height="90" src="http://3.bp.blogspot.com/-a0aThYoPwxU/T1nHhEkkeiI/AAAAAAAAAkQ/N5n7HZJ1Gb8/s200/cassandra05.png" width="120" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><div class="separator" style="clear: both; text-align: justify;">Une colonne doit avoir un nom qui peut être un label statique (comme "nom" ou "email") ou peut être mis dynamiquement lorsque la colonne est créée par l'application.</div><div style="text-align: justify;">Les colonnes peuvent être indexées par leurs noms (en utilisant un second index).</div><div style="text-align: justify;">Cependant, une limitation de l'indexation des colonnes est le non support des requêtes qui nécessitent un ordonnancement comme cela peut être le cas avec une collection de données de temps. En effet, dans ce cas, un second index sur la colonne de <i>timestamp</i> ne serait pas suffisant car il n'est pas possible d'avoir la main sur l'ordonnancement de la colonne avec un index&nbsp;secondaire. Pour palier à ce manque, il est toujours possible de maintenir manuellement une famille de colonnes qui ferait office d'index.</div><div style="text-align: justify;">Il est à noter qu'il n'est pas obligatoire pour une colonne d'avoir une valeur puisque, parfois, le nom de cette dernière lui suffit à elle-même.</div><div style="text-align: justify;">En plus des colonnes dites "classiques", Cassandra offre 3 autres types de colonnes (que je détaillerai pas plus) :</div><ul><li style="text-align: justify;"><em>Expiring Columns</em> qui disposent d'un TTL (<em>Time To Live</em>).</li><li style="text-align: justify;"><em>Counter Columns</em> qui permettent de stocker un compteur.</li></ul><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-_NU2ZTQ6yN0/T1201ywQkBI/AAAAAAAAAkY/zfvptCJ7dxM/s1600/cassandra06.png" style="margin-left: auto; margin-right: auto;"><img alt="" border="0" src="http://4.bp.blogspot.com/-_NU2ZTQ6yN0/T1201ywQkBI/AAAAAAAAAkY/zfvptCJ7dxM/s1600/cassandra06.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><ul><li style="text-align: justify;"><em>Super Columns</em> qui permettent de gérer une meta colonne pouvant contenir d'autres colonnes.</li></ul><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-RyNcDkPN5og/T1209KAYDHI/AAAAAAAAAkg/K42iHZ7csaU/s1600/cassandra07.png" style="margin-left: auto; margin-right: auto;"><img alt="" border="0" height="123" src="http://3.bp.blogspot.com/-RyNcDkPN5og/T1209KAYDHI/AAAAAAAAAkg/K42iHZ7csaU/s320/cassandra07.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><div><div style="text-align: justify;">Concernant, le type de données exploitables par Cassandra, il existe deux notions :</div></div><div><ul><li style="text-align: justify;">Le <b><i>validator</i></b> qui est le type de données pour la valeur d'une colonne (ou la clé d'une ligne).</li><li style="text-align: justify;">Le <b><i>comparator</i></b> qui est le type de données pour le nom d'une colonne.</li></ul></div><div style="text-align: justify;">En fait, il est possible de définir un type de données lors de la création d'une famille de colonnes et que son schéma est précisé (cf. les&nbsp;familles de colonnes statiques). Cassandra stocke alors, par défaut,&nbsp;le nom et les valeurs des colonnes en tableau d'hexadécimal (<i>BytesType</i>).</div><div style="text-align: justify;">Ci-dessous, la liste des valeurs possibles pour les <i>validator</i> et <i>comparator</i> (sauf pour le type <i>CounterColumnType</i> qui ne peut être utilisé que comme valeur de colonne) :</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-ZwnUrailUWs/T13LTaRvLBI/AAAAAAAAAko/Ul9Erfto4gI/s1600/cassandra08.png" style="margin-left: auto; margin-right: auto;"><img alt="" border="0" height="281" src="http://2.bp.blogspot.com/-ZwnUrailUWs/T13LTaRvLBI/AAAAAAAAAko/Ul9Erfto4gI/s640/cassandra08.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><br /><div style="text-align: justify;">Plus précisément sur les <i>validator</i>, pour toutes les familles de colonnes, il est conseillé de définir un <i>validator</i> par défaut pour une clé de ligne (qui peut être modifié ou ajouté au besoin). Dans ce cas, une vérification est effectué lors de l'insertion ou la mise à jour de données.</div><div style="text-align: justify;">Concernant le <i>comparator</i>, il est à noter que, dans une ligne, les colonnes sont toujours stockées de manière ordonné par rapport au nom des colonnes. Le <i>comparator</i> précise le type de données pour le nom d'une colonne mais ne peut être modifié.</div><h1>          L'indexation dans Cassandra</h1><div style="text-align: justify;">Un index est une structure de données qui permet un accès rapide ainsi qu'une recherche de données par rapport à un ensemble de critères donnés.</div><div style="text-align: justify;">Dans les bases de données classique, une clé primaire est une clé unique utilisée pour identifier chaque ligne d'une table. Cela permet, comme tous les index, d'accélérer l'accès aux données dans une table. La clé primaire garantie également l'unicité et mais peut également se charger de l'ordonnancement des données.</div><div style="text-align: justify;">Dans Cassandra, l'index primaire d'une famille de colonnes correspond à l'index de ses clés de lignes. Puisque chaque noeud connait la plage de ses clés par noeuds gérés, les requêtes sur les lignes sont plus aisées à localiser en scannant l'index des lignes sur un noeud donnée.</div><div style="text-align: justify;">Avec un partitionnement aléatoire des clés de lignes (qui est la configuration par défaut), les clé de lignes sont partitionnés par le <i>hash MD5</i> et ne peuvent donc pas gérer l'ordonnancement (au sens ordre des données). Il est à noter qu'utiliser un partitionnement ordonné n'est pas conseillé puisque cela implique une maintenance accrue pour la distribution des données sur les noeuds.</div><div style="text-align: justify;">Cassandra propose également un index secondaire qui se fait sur la valeur des colonnes. Il permet d'effectuer des opérations disposant de prédicats d'égalité (par exemple, <em>where column x = value y</em>). Ainsi, les requêtes sur des valeurs indexées peuvent appliquer une sorte de filtres.</div><h1>          L'accès aux données dans Cassandra</h1><h2>         L'écriture</h2><div style="text-align: justify;">Cassandra est optimisé pour permettre une écriture rapide et hautement disponible des données avec un débit élevé. Pour ce faire, les données sont écrites dans un premier temps dans un <b>journal de commit </b>(pour s'assurer de la durabilité), puis dans une structure en mémoire appelé la <strong><em>Memtable</em></strong>. Une écriture est considérée comme ayant réussi si les deux actions précédentes ont réussis. Cela permet d'avoir peu d'entrée/sortie disque au moment de l'écriture. Ainsi, les données sont mises en mémoire et périodiquement écrite sur le disque dans une structure appelé une <strong><em>SSTable</em></strong> (pour <em>Sorted String Table</em>). Les <i>Memtables</i> et <i>SSTables</i> sont maintenus par famille de colonnes : les <i>Memtables</i> sont organisées de manière ordonné par clé de ligne et sont <em>flushé</em> dans les <i>SSTables</i> séquentiellement.</div><div style="text-align: justify;">A noter également que les <i>SSTables</i> sont immuables, ce qui signifie qu'une ligne peut, typiquement, être stockée dans plusieurs fichiers de <i>SSTable</i>. Ainsi, pour répondre à une requête de lecture, il est nécessaire de combiner toutes les <i>SSTables</i> se trouvant sur le disque pour trouver la valeur d'une ligne. Pour optimiser ce processus, Cassandra utilise un structure en mémoire appelé <em><strong>Bloom Filter</strong></em> : chaque <i>SSTable</i> dispose de son propre <i>Bloom Filter</i> qui est utilisé pour vérifier si la clé d'une ligne existe lors d'une requête.</div><div style="text-align: justify;">De plus, en tâche de fond, Cassandra merge périodiquement les <i>SSTables</i> ensembles dans un <i>SSTables</i> d'une taille supérieure. Ce processus est appelé <em><strong>Compaction</strong></em>. Plus précisément, il regroupe les fragments de lignes ensemble, supprime les colonnes qui ont été marquées comme devant être supprimé et reconstruit les index primaires et secondaires. Bien sûr, ce processus a des impacts sur les disk I/O.</div><div style="text-align: justify;">Contrairement aux bases de données relationnelles classique, Cassandra n'offre pas des transactions dites ACID : il n'y a pas de locks ou de dépendances transactionnelles lors d'une mise à jour concurrente de multiples lignes ou de familles de colonnes.</div><div style="text-align: justify;">Pour rappel, ACID est l'acronyme de :</div><ul><li style="text-align: justify;"><strong>Atomic</strong> : tout ce qu'il y a dans une transaction doit être réussi ou sinon un rollback est effectué.</li><li style="text-align: justify;"><strong>Consistent</strong> : une transaction ne peut pas laisser la base de données dans un état incohérent.</li><li style="text-align: justify;"><strong>Isolated</strong> : les transactions ne peuvent pas interagir les unes avec les autres.</li><li style="text-align: justify;"><strong>Durable</strong> : les transactions effectuées persistent même après une &nbsp;défaillance du serveur.</li></ul><div><div style="text-align: justify;">Pour sa part, Cassandra ne traite que les concepts d'isolation et d'atomicité. En fait, pour être plus précis, une écriture est atomique au niveau des lignes (ie. l'insertion ou la mise à jour des colonnes d'une ligne donnée est traitée comme une écriture&nbsp;unique). Ainsi, Cassandra ne supporte pas les transactions dans le sens de mise à jour de lignes multiples. De même, il n'y a pas de rollback lorsque l'écriture réussi sur un noeud mais échoue sur les autres (dans ce cas, il n'est possible de n'avoir qu'un rapport d'erreur mais pas de rollback).</div></div><div><div style="text-align: justify;">Cassandra utilise les <em>timestamps</em> pour déterminer la mise à jour la plus récente d'une colonne ; ce <i>timestamp</i> étant fourni par l'application cliente. Ainsi, la donnée avec le dernier <em>timestamp</em> est toujours celle qui prévaut lors d'une requête. C'est pour cela que, si de multiples clients mettent à jour la même donnée de manière concurrente, alors c'est la donnée la plus récente qui sera persistée.</div></div><div><div style="text-align: justify;">Du coté de la durabilité, toutes les écritures sur un réplica sont enregistrés à la fois en mémoire et dans le journal de commit avant que l'acquittement ne soit émis. Si un échec se produit avant l'écriture sur disque, alors le journal de commit est rejoué du début afin de récupérer les données qui n'ont pas encore été écrites.</div></div><h2>         L'insertion et la mise à jour</h2><div style="text-align: justify;">Plusieurs colonnes peuvent insérées en même temps. Ainsi, lorsque des colonnes sont insérées ou mise à jour dans une famille de colonnes, l'application cliente précise la clé de ligne pour identifier l'enregistrement à mettre à jour. La clé de la ligne peut donc être vu come une clé primaire puisqu'elle doit être unique pour chaque ligne dans une famille de colonnes données. Cependant, à la différence d'une clé primaire, il est possible d'insérer des données à une clé primaire déjà présente, mais dans ce cas, Cassandra répondra comme une mise à jour (si elle n'existe pas, elle sera créé).</div><div style="text-align: justify;">De plus, les colonnes sont écrasées si le <i>timestamp</i> d'une autre version de colonne est plus récente. Il est, cependant, à noter que le <i>timestamp</i> est fourni par le client. Aussi, ces derniers doivent disposer d'une horloge synchronisée par NTP (<em>Network Time Protocol</em>).</div><h2>         La suppression</h2><div style="text-align: justify;">Lorsqu'une ligne ou une colonne est supprimé dans Cassandra, il est important de comprendre les points ci-dessous :</div><ul><li style="text-align: justify;">la suppression de la donnée du disque n'est pas immédiate (pour rappel, une données insérée est écrite dans le <i>SSTable</i> qui se trouve sur le disque). En effet, le <i>SSTable</i> étant immuable, un marqueur appelé <strong><em>tombstone</em></strong>&nbsp;est écrit pour renseigner le nouveau status de la colonne. Les colonnes ainsi marquées persistent pendant un certain laps de temps configurable puis sont réellement supprimées lors du processus de <strong><em>compaction</em></strong>.</li><li style="text-align: justify;">une colonne supprimé peut réapparaitre si la routine de réparation de noeud n'est pas exécuté. En effet, marquer une colonne d'un <em>tombstone</em>&nbsp;implique qu'un réplica qui était dans un état non atteignable lors de la suppression ne recevra l'information que lorsqu'il sera de nouveau dans un état joignable. Cependant, si un noeud est injoignable plus longtemps que le temps configuré de conservation des <em>tombstones</em>, alors le noeud peut&nbsp;complètement&nbsp;manquer la suppression et répliquer les données supprimées lors de son retour dans le cluster.&nbsp;</li><li style="text-align: justify;">La clé de ligne pour une ligne supprimée apparait toujours dans la plage de résultats d'une requête. En effet, quand une ligne est supprimée dans Cassandra, ses colonnes correspondantes sont marquées par un&nbsp;<em>tombstone</em>. Ainsi, tant que les données marquées par un&nbsp;<em>tombstone</em> ne sont pas réellement supprimées par le processus de <em>compaction</em>, la ligne reste vide (ie. sans colonne associées).</li></ul></div><h2>        La lecture</h2><div><div style="text-align: justify;">Pour rappel, lorsqu'une requête de lecture d'une ligne est reçue par un noeud, la ligne doit être combinée de toutes les <i>SSTables</i> du noeud qui contiennent les colonnes de la ligne en question ainsi que de toutes les <i>Memtables</i>. Pour optimiser ce processus, Cassandra utilise une structure en mémoire appelée les <i>bloom filter</i> : chaque <i>SSTable</i> dispose d'un <i>bloom filter</i> associé qui est utilisé pour vérifier s'il existe des données dans la ligne avant de faire une recherche (et ainsi de faire des entrées/sorties disque).</div></div><div><br /></div><h1>       La consistance des données dans Cassandra</h1><div><div style="text-align: justify;">Lorsqu'il est fait question de consistance dans Cassandra, cela s'applique à la façon dont est maintenue la cohérence des données et comment les lignes de données sont synchronisées entre tous les réplicas.</div><div style="text-align: justify;">Cassandra étend le concept de cohérence éventuelle en offrant un consistance réglable.</div><div style="text-align: justify;">Ainsi, pour toutes opérations de lecture ou d'écriture, l'application cliente peut décider du&nbsp;degrés&nbsp;de consistance que doit avoir la requête. En plus de cela, Cassandra dispose d'un mécanisme de réparation afin de s'assurer de la consistance des données entre les différents réplicas.</div></div><h2>   Consistance réglable pour les requêtes clientes</h2><div><div style="text-align: justify;">Le niveau de consistance dans Cassandra peut être associé à n'importe quelle requête de lecture ou d'écriture. Cela permet aux développeurs de l'application de trouver le juste milieu entre le temps d'exécution de leurs requêtes et la consistance qu'ils souhaitent avoir sur les résultats obtenus.</div></div><div><div style="text-align: justify;"><br /></div></div><div><div style="text-align: justify;">Lors d'une écriture, le niveau de consistance précise sur combien de réplicas doit être écrite la donnée avant d'être&nbsp;acquitté&nbsp;du succès de l'opération.</div></div><div><div style="text-align: justify;">Les niveaux de consistance disponibles sont les suivants :</div></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-x5hTsbj3l_g/T18dPz_XiHI/AAAAAAAAAkw/CKBq0LoZ6pE/s1600/cassandra11.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="249" src="http://1.bp.blogspot.com/-x5hTsbj3l_g/T18dPz_XiHI/AAAAAAAAAkw/CKBq0LoZ6pE/s640/cassandra11.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><div>En fait, pour être plus précis, un quorum est calculé de la manière ci-dessous :</div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-vL7EP1n4Jgs/T18f1aw36II/AAAAAAAAAk4/AshD58ObrgE/s1600/cassandra12.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-vL7EP1n4Jgs/T18f1aw36II/AAAAAAAAAk4/AshD58ObrgE/s1600/cassandra12.png" /></a></div><div class="separator" style="clear: both; text-align: justify;">Ainsi, par exemple, si le facteur de réplication est de 3, alors le quorum est de 2 (c'est à dire que l'on tolère qu'un seul réplica est indisponible).</div><div><div style="text-align: justify;">De même, si le facteur de réplication est de 6, alors le quorum des de 4 (c'est à dire que 2 réplicas peuvent être indisponibles).</div></div><div><div style="text-align: justify;"><br /></div></div><div><div style="text-align: justify;">Lors d'une lecture, le niveau de consistance spécifie combien de réplicas doivent répondre avant que le résultat ne soit fourni au client.</div></div><div><div style="text-align: justify;">Cassandra contacte le nombre de réplicas indiqué afin d'obtenir la donnée la plus récente (en se basant sur le <i>timestamp</i>).</div></div><div><div style="text-align: justify;">Les niveaux de consistance disponibles sont les suivants :</div></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-l5GRGCM3d2Y/T18l1f7VGDI/AAAAAAAAAlA/jPAqImzGCWs/s1600/cassandra13.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="200" src="http://2.bp.blogspot.com/-l5GRGCM3d2Y/T18l1f7VGDI/AAAAAAAAAlA/jPAqImzGCWs/s640/cassandra13.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Crédit photo : Cassandra</td></tr></tbody></table><div><div style="text-align: justify;">Le niveau quorum est calculé de la même manière que pour l'écriture.</div></div><div><div style="text-align: justify;">Ainsi, par exemple, pour un facteur de réplication de 3, le quorum est de 2 (c'est à dire que l'on tolère qu'un seul réplica est indisponible).</div></div><div><div style="text-align: justify;">De même, pour un facteur de réplication de 6, le quorum est de 4 (c'est à dire que 2 réplicas peuvent être indisponibles).</div></div><div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Concernant le choix du niveau de consistance sur l'écriture et la lecture, cela dépend,&nbsp;bien sûr,&nbsp;des besoins mais impact fortement le comportement de Cassandra.</div><div style="text-align: justify;">Ainsi, si la latence est une priorité, un niveau de consistance à ONE peut être envisageable. Bien sûr, dans ce cas, il y a une forte probabilité que les données lues ne soient pas cohérente.</div><div style="text-align: justify;">A l'inverse, si c'est l'écriture qui importe, alors une consistance à un niveau ANY peut répondre au besoin. Dans ce cas, ce sont les données lues qui risquent de ne pas être consistantes.</div><div style="text-align: justify;">A noter que si c'est la consistance qui est importante (c'est à dire que les données lues sont les plus proches possibles de ce qui a été écrit), alors la formule suivante peut être appliquée :</div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-19RglOrHOBI/T19Zlpb7TBI/AAAAAAAAAlI/Xa7Kqfi3dpY/s1600/cassandra14.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="55" src="http://1.bp.blogspot.com/-19RglOrHOBI/T19Zlpb7TBI/AAAAAAAAAlI/Xa7Kqfi3dpY/s400/cassandra14.png" width="400" /></a></div></div><h1> Conclusion</h1><div style="text-align: justify;">Dans cet article, j'ai essayé de mettre en avant les points qui m'ont marqués (en bien ou en mal) (je tiens quand même à re-préciser que mon avis n'est que théorique et que je n'ai pas réellement utilisé le produit).&nbsp;</div><div style="text-align: justify;">Ainsi au niveau des points positifs, j'ai aimé les choix techniques et les concepts (très enrichissants d'ailleurs... ;-) ).</div><div style="text-align: justify;">Cependant, coté points négatifs, je ne suis pas fan des dégradations coté consistance qui peuvent se produire (le coup de l'élément supprimé qui revit dans le système... comment dire... mais WTF???!! ;-) &nbsp;- bon ok, la raison est viable mais quand même... -).&nbsp;</div><div style="text-align: justify;">Bien sûr, cela est configurable et il s'agit d'un choix technique mais j'avoue avoir été déçu par Cassandra. En outre, le fait de laisser à l'application cliente le choix du niveau de consistance, même s'il est louable, me semble dangereux au sens maintenabilité et compréhension du fonctionnement du système.</div><div style="text-align: justify;">En tout cas, la documentation du produit est très claire et transparente quant au fonctionnement interne et aux risques encourus, et pour ça, chapeau! ;-)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour conclure, je ne ferai pas de super mot de la fin puisque je ne me suis borné qu'à traduire quelques bouts par ci par là de la documentation et que je trouve que cela suffit à lui-même ;-).</div><div style="text-align: justify;">Par contre, pour tous ceux que ça intéresse, je vous invite à&nbsp;jeter&nbsp;un oeil à la documentation officielle très complète (aussi bien au niveau configuration que explication).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Enjoy! ;-)</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>doanduyhai</div>
<div class='content'>
Excellent article!<br /><br /> J&#39;ai eu l&#39;occasion de travailler récemment avec Cassandra sur le concours Tatami chez Ippon et le plus gros problème que j&#39;ai rencontré sur cette techno, c&#39;est essentiellement la rigidité dans la gestion des noms de colonne (impossiblité de faire un rename etc...) mais c&#39;est lié essentiellement à l&#39;architecture technique même.<br /><br /> Comme tu l&#39;as souligné, des fois on se retrouve à créer des Column Family supplémentaires pour gérer l&#39;indexation de ses données et à la longue ça devient franchement lourd (et proprice aux erreurs en plus).<br /><br /> Ils ont sorti Solandra, un SOLR par dessus Cassandra, pour gérer les recherches et indexation mais je ne sais pas ce que ça vaut, il faut que je teste un de ces quatres</div>
</div>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
Salut Sam,<br /><br />Merci pour le commentaire. Si je viens à utiliser les couches clientes (ie. si je viens à utiliser le produit), j&#39;essaierai de faire un article (dans ce cas, j&#39;aurai un vrai retour d&#39;XP) mais je pense qu&#39;il va falloir attendre un peu... ;-)<br />Sinon si ça te branche, j&#39;héberge ton post ;-)<br /><br />++</div>
</div>
<div class='comment'>
<div class='author'>Sam BESSALAH</div>
<div class='content'>
Excellent Khanh. Beau boulot. Comme dit plus haut il manque un de description sur Thrift, et le client notamment Hector. Mais je suis d&#39;accord avec toi que le core engine et le modèle de données sont ceux qui font vraiment la force de cette techno. MErci Khanh.</div>
</div>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
Salut Damien,<br /><br />Merci pour le commentaire. <br />Concernant la couche cliente, en effet, je n&#39;en ai pas parlé parce que j&#39;avoue que c&#39;était plus le fonctionnement intrinsèque du moteur qui m&#39;intéressait...<br />Tu fais bien de faire la remarque ;-)</div>
</div>
<div class='comment'>
<div class='author'>Damien Lepage</div>
<div class='content'>
Joli travail, les &quot;quelques bouts&quot; sont quand même très bien choisis et donnent une excellente vue d&#39;ensemble de l&#39;architecture. Il manque peut-être des références à Thrift et CQL (Cassandra Query Language) pour la partie cliente. Pour avoir joué un peu avec Cassandra, je trouve que c&#39;est un produit intéressant mais sa nature de type clé-valeur rend vraiment compliquée la structuration de données.</div>
</div>
</div>
