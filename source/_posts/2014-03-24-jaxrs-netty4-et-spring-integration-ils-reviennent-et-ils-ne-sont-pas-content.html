---
layout: post
title: "JAXRS, Netty4 et Spring Integration : ils reviennent et ils ne sont pas content!"
date: 2014-03-24
comments: false
categories:
 - netty
 - java
 - jmx
 - metrics
 - spring integration
 - REST
 - perfomance
 - jolokia
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-XR47rmCwXK0/Ux8gpmR-TLI/AAAAAAAABR0/T1h_RtvDED0/s1600/resteasy_jolokia_metrics_orig3.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-XR47rmCwXK0/Ux8gpmR-TLI/AAAAAAAABR0/T1h_RtvDED0/s1600/resteasy_jolokia_metrics_orig3.png" height="211" width="320" /></a></div><div style="text-align: justify;">Pour faire suite à mes articles <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>, nous allons voir, dans cet article, comment il est possible de créer un <i>service activator</i> avec <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> qui exposera via <b>resteasy-netty4</b> un service REST.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ce service REST esposera simplement une opération en POST qui, via Spring Integration, écrira dans un fichier et qui, pour le fun, écrira également sur la console.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, rien de plus simple, un <a href="http://www.eaipatterns.com/MessagingAdapter.html"><i>Service Activator</i></a> de type <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">gateway</a> a été utilisé.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cet article montrera donc comment il est possible d'intégrer Spring Integration à notre petite <i>stack</i> basé sur Resteasy-Netty4, Jackson, <a href="http://metrics.codahale.com/">Metrics</a>, <a href="https://helloreverb.com/developers/swagger">Swagger</a> et <a href="http://www.jolokia.org/">Jolokia</a>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Le code se trouve sur Github <a href="https://github.com/jetoile/spring-integration-netty4">ici</a>.</div><div style="text-align: justify;"></div><!-- more --><br /><br /><h1 id="pr-sentation-du-_usecase_">Présentation du <i>usecase</i></h1><div style="text-align: justify;">Le service qui est exposé est un service de type REST répondant à un appel de type POST et acceptant du JSON. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il répondra à une requête de type :</div><pre><code class="lang-bash">curl -XPOST -H "Content-Type: application/json" -d '{"message": "hello", "time": "2014-03-05T10:55:39.835+01:00"}'  http://127.0.0.1:8081/sample/write</code></pre><br /><div style="text-align: justify;">et écrira un fichier par requête reçue dans le répertoire /tmp. En outre, il loggera sur la console le message reçu.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, avec la commande suivante, on devrait voir un incrément du nombre à chaque réception de message.</div><pre><code class="lang-bash">watch 'ls *.msg | wc -l'</code></pre><h1 id="mise-en-oeuvre">Mise en oeuvre</h1><h2 id="d-pendances">Dépendances</h2><div style="text-align: justify;">A titre informatif, les dépendances ainsi que leurs versions sont les suivantes (au format gradle) :</div><pre><code class="lang-text">dependencies {<br />    compile group: 'org.springframework.integration', name: 'spring-integration-core', version:'3.0.1.RELEASE'<br />    compile group: 'org.springframework.integration', name: 'spring-integration-jmx', version:'3.0.1.RELEASE'<br />    compile group: 'org.springframework.integration', name: 'spring-integration-http', version:'3.0.1.RELEASE'<br />    compile group: 'org.springframework.integration', name: 'spring-integration-file', version:'3.0.1.RELEASE'<br />    compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'<br />    compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'<br />    compile group: 'org.jolokia', name: 'jolokia-spring', version:'1.1.2'<br />    compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'<br />    compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'<br />    compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'<br />    compile group: 'com.ryantenney.metrics', name: 'metrics-spring', version:'3.0.0-RC4'<br />    compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'<br />    compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'<br />    compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'<br />    compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'<br />    compile group: 'commons-io', name: 'commons-io', version:'2.4'<br />    compile group: 'joda-time', name: 'joda-time', version:'2.3'<br />    compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}<br />}</code></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour le lecteur averti, il constatera que la version de Jackson utilisé ici est la 1 (ie. avec le groupId <i>org.codehaus</i>). En effet, Jackson 2 et JodaTime m'ont fait des misères et je n'ai pas réussi à les résoudre rapidement, donc, par flemme, je suis repassé en version 1... ;-)</div><h2 id="dto">DTO</h2><div style="text-align: justify;">Un DTO annoté JAX-B (compris par Jackson) sera utilisé pour représenter le JSON reçu dans le corps du POST.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il se présente comme suit :</div><pre><code class="lang-java">@XmlRootElement<br />public class DtoRequest {<br /><br />    private String message;<br />    private DateTime time;<br /><br />    public String getMessage() { return message; }<br /><br />    public void setMessage(String message) { this.message = message; }<br /><br />    public DateTime getTime() { return time; }<br /><br />    public void setTime(DateTime time) { this.time = time; }<br /><br />    @Override<br />    public String toString() {<br />        return "DtoRequest{" +<br />                "message='" + message + '\'' +<br />                ", time=" + time +<br />                '}';<br />    }<br />}</code></pre><br /><div style="text-align: justify;">Ici, la méthode <i>toString()</i> a été <i>overridé</i> car utilisé lors de l'affichage du message par le loggueur sur la console.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Jusque là, ça ne casse pas trois pattes à un canard ;-)</div><h2 id="int-gration-compl-te-de-spring-integration">Intégration complète de Spring Integration</h2><div style="text-align: justify;">Pour rappel, Spring Integration est une implémentation des <a href="http://blog.jetoile.fr/2009/12/eip-quest-ce-que-cest.html">EIP</a> (<i>Enterprise Integration Patterns</i>) et propose donc une mise en oeuvre de l'architecture <i>Pipes and Filters</i>. </div><div style="text-align: justify;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-Pd_JIILTp_0/Ux8fIIRV-tI/AAAAAAAABRQ/hevpIqdQU4M/s1600/si-netty4-graph.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-Pd_JIILTp_0/Ux8fIIRV-tI/AAAAAAAABRQ/hevpIqdQU4M/s1600/si-netty4-graph.png" height="420" width="640" /></a></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Au niveau écriture dans un répertoire, le <b>file-outbound-adapter</b> offert par Spring Integration sera utilisé :</div><pre><code class="lang-xml">&lt;file:outbound-channel-adapter id="fileAdapter" auto-create-directory="true"<br />                                       directory="file:${out.directory}"<br />                                       channel="channel"/&gt;</code></pre><br /><div style="text-align: justify;">Coté loggueur, ce sera le composant <b>logging</b> :</div><pre><code class="lang-xml"> &lt;int:logging-channel-adapter auto-startup="true" channel="channel" level="INFO" log-full-message="true"/&gt;</code></pre><br />et où on aura un <i>Pipe</i> (channel) en mode <i>Publish-Subscribe</i> :<br /><pre><code class="lang-xml"> &lt;int:publish-subscribe-channel id="channel"/&gt;</code></pre><br /><div style="text-align: justify;">Au niveau des namespaces et autres informations, on aura ce qui suit :</div><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:int="http://www.springframework.org/schema/integration"<br />       xmlns:file="http://www.springframework.org/schema/integration/file"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<br />                  http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd<br />                  http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd<br />                  http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd"&gt;<br /><br />    &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;<br />        &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;<br />        &lt;property name="locations"&gt;<br />            &lt;list&gt;<br />                &lt;value&gt;classpath:/conf.properties&lt;/value&gt;<br />            &lt;/list&gt;<br />        &lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;<br />        &lt;property name="locateExistingServerIfPossible" value="true"/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;int-jmx:mbean-export default-domain="fr.jetoile.sample" server="mbeanServer"/&gt;<br /><br />    &lt;int:message-history/&gt;    <br />    ...<br />&lt;/beans&gt;</code></pre><br /><div style="text-align: justify;">On y remarque la lecture du fichier de configuration, ainsi que les activations jmx adéquate afin d'avoir un peu d'informations ;-) Concernant l'élément <b>message-history</b>, cela permet de préciser à Spring Integration d'ajouter dans les <i>headers</i> du message (qui, pour rappel, transite via les <i>Pipes</i> entre les différents <i>Filters</i>) des informations de temps d'exécution.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En soit, il s'agit d'une configuration extrèmement simple pour toute personne connaissant un minimum Spring Integration, donc encore une fois, rien de compliqué... ;-)</div><h2 id="_gateway_-spring-integration"><i>Gateway</i> Spring Integration</h2><div style="text-align: justify;">Afin de rentrer dans le vif du sujet, ce paragraphe montrera comment il est possible de transformer notre petit serveur Resteasy-Netty4 en une <i>Gateway</i> Spring Integration.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, il suffit de définir une interface (<i>NettyGateway</i>) qui sera utilisée par Spring Integration.</div><div style="text-align: justify;">Ci dessous un petit <i>extract</i> de la <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">documentation officielle</a> :</div><blockquote><div style="text-align: justify;">Le rôle principale d'une <i>Gateway</i> est de chacher l'API de messaging fournit par Spring Integration. Cela permet à la logique business de l'application de s'abstraire complètement de l'API de Spring Integration et, en utilisant une <i>Gateway</i> générique, le code n'interagit qu'avec une simple interface. </div><div style="text-align: justify;">...</div><div style="text-align: justify;">En fait, Spring Integration fournit un <i>GatewayProxyFactoryBean</i> qui génère un proxy pour n'importe quelle interface et qui, en interne, invoque la méthode de la <i>Gateway</i>. Ainsi, en utilisant l'injection de dépendance, il est possible d'exposer l'interface aux méthodes business.</div></blockquote><pre><code class="lang-java">public interface NettyGateway {<br />    void send(DtoRequest msg);<br />}</code></pre><br />Ainsi, notre service REST se présentera comme suit :<br /><pre><code class="lang-java">@Path("/sample")<br />public class SimpleService {<br /><br />    private NettyGateway messageProducer;<br /><br />    public void setGateway(NettyGateway messageProducer) {<br />        this.messageProducer = messageProducer;<br />    }<br /><br />    @POST<br />    @Path("/write")<br />    @Consumes(MediaType.APPLICATION_JSON)<br />    public Response write(DtoRequest message) {<br />        this.messageProducer.send(message);<br />        return Response.ok().build();<br />    }<br />}</code></pre><br /><div style="text-align: justify;">On y constatera que l'inteface <b>NettyGateway</b> lui a été injecté afin qu'il puisse servir de passe plat.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Coté Spring, la configuration est la suivante :</div><pre><code class="lang-xml">&lt;int:gateway id="nettyGateway" service-interface="fr.jetoile.sample.gateway.NettyGateway"<br />                 default-request-channel="channel"/&gt;<br /><br />&lt;bean id="simpleService" class="fr.jetoile.sample.service.SimpleService"&gt;<br />    &lt;property name="gateway" ref="nettyGateway"/&gt;<br />&lt;/bean&gt;</code></pre><br /><div style="text-align: justify;">Du coté de démarrage de notre serveur Resteasy-Netty4, cela ne sera, bien sûr, plus fait dans le <i>main()</i>, mais dans notre <i>bean</i> Spring à qui sera injectée notre classe implémentant notre service REST :</div><pre><code class="lang-xml">&lt;bean id="nettyContainer" class="fr.jetoile.sample.gateway.NettyContainer"&gt;<br />    &lt;constructor-arg ref="simpleService"/&gt;<br />&lt;/bean&gt;</code></pre><br /><div style="text-align: justify;">Avec :</div><pre><code class="lang-java">public class NettyContainer {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(NettyContainer.class);<br /><br />    public static final String CONF_PROPERTIES = "conf.properties";<br /><br />    private static Configuration config;<br /><br />    private SimpleService simpleService;<br /><br />    public NettyContainer(SimpleService simpleService) {<br />        try {<br />            config = new PropertiesConfiguration(CONF_PROPERTIES);<br /><br />        } catch (ConfigurationException e) {<br />            throw new IllegalArgumentException("bad config");<br />        }<br />        this.simpleService = simpleService;<br />        initServer();<br />    }<br /><br /><br />    private void initServer() {<br />        ResteasyDeployment deployment = new ResteasyDeployment();<br /><br />        int nettyPort = 8081;<br /><br />        if (config != null) {<br />            deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));<br />            deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));<br />            deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));<br />            deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));<br /><br />            nettyPort = config.getInt("netty.port", TestPortProvider.getPort());<br />        } else {<br />            LOGGER.warn("is going to use default netty config");<br />        }<br /><br />        deployment.setResources(Arrays.&lt;Object&gt;asList(simpleService));<br /><br />        MyNettyJaxrsServer netty = new MyNettyJaxrsServer();<br /><br />        netty.setDeployment(deployment);<br />        netty.setPort(nettyPort);<br />        netty.setRootResourcePath("");<br />        netty.setSecurityDomain(null);<br />        netty.start();<br />    }<br />}</code></pre><br /><div style="text-align: justify;">Et voilà... c'est tout!</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ne reste plus que la classe implémentant notre <i>main()</i> qui ne fera que charger le contexte spring :</div><pre><code class="lang-java">public class Client {<br />    public static void main(String[] args) throws ConfigurationException {<br />        new ClassPathXmlApplicationContext("springintegration-config.xml");<br />    }<br />}</code></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Juste un dernier point : le lecteur un peu concentré aura remarqué qu'il y a, ici, un petit meli melo dans la lecture des fichiers de configuration (parfois chargé par Spring, parfois chargé via <i>commons-configuration</i>). Je laisse cependant ces points en suspens et à la discrétion de la personne qui utilisera et lira cet article (ou qui aura atteint ce point...) (s'il y en a... ;-) ).</div><h2 id="int-gration-de-metrics">Intégration de Metrics</h2><div style="text-align: justify;">L'objectif de cet article étant de monter une <i>stack</i> "presque complète", il est, bien sûr, primordial de fournir les bonnes métriques. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Comme dans mon article précédent, ce sera Metrics qui sera utilisé.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cependant, alors que cela avait été fait programmatiquement, ce coup-ci, cela sera fait via Spring (parce que sinon ce n'est pas drôle... ;-) ).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, c'est très simple, en tirant la dépendance <b>'com.ryantenney.metrics', name: 'metrics-spring', version:'3.0.0-RC4'</b> au lieu de <b>'com.codahale.metrics', name: 'metrics-core'</b>, il ne reste qu'à ajouter à notre service REST l'annotation <b>@Timed</b> et d'ajouter dans la configuration Spring les éléments suivants :</div><pre><code class="lang-java">@POST<br />@Path("/write")<br />@Consumes(MediaType.APPLICATION_JSON)<br />@Timed<br />public Response write(DtoRequest message) {<br />    this.messageProducer.send(message);<br />    return Response.ok().build();<br />}</code></pre>Avec la configuration Spring suivante :<br /><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:int="http://www.springframework.org/schema/integration"<br />       xmlns:file="http://www.springframework.org/schema/integration/file"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:metrics="http://www.ryantenney.com/schema/metrics"<br />       xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<br />                  http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd<br />                  http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd<br />                  http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd<br />                  http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;<br /><br />    &lt;metrics:metric-registry id="metrics" /&gt;<br /><br />    &lt;metrics:annotation-driven metric-registry="metrics" /&gt;<br /><br />    &lt;metrics:reporter type="jmx" metric-registry="metrics" /&gt;<br />    ...<br />&lt;/beans&gt;</code></pre><br /><div style="text-align: justify;">Pour montrer que je ne mens pas, on a donc (ici, utilisation de Hawt.io via Jolokia) :</div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-CZebCZS47aE/Ux8fk-EwKQI/AAAAAAAABRY/C7OwMBMZNEc/s1600/si-hawtio-connextion.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-CZebCZS47aE/Ux8fk-EwKQI/AAAAAAAABRY/C7OwMBMZNEc/s1600/si-hawtio-connextion.png" height="288" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-H-LmsIrivjA/Ux8fo7ORYpI/AAAAAAAABRg/EIp_-F6LzF4/s1600/si-hawtio-metrics.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-H-LmsIrivjA/Ux8fo7ORYpI/AAAAAAAABRg/EIp_-F6LzF4/s1600/si-hawtio-metrics.png" height="363" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">&nbsp;On constate encore une fois la simplicité de la chose!</div><h2 id="int-gration-de-jolokia">Intégration de Jolokia</h2><div style="text-align: justify;">De même que pour notre paragraphe précédent, l'intégration de Jolokia se fera ici par configuration Spring plutôt que de manière programmatique.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, il suffit de tirer la dépendance <b>'org.jolokia', name: 'jolokia-spring', version:'1.1.2'</b> au lieu de <b>'org.jolokia', name: 'jolokia-jvm'</b>, et d'ajouter le bon <i>bean</i> à Spring :</div><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:int="http://www.springframework.org/schema/integration"<br />       xmlns:file="http://www.springframework.org/schema/integration/file"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:metrics="http://www.ryantenney.com/schema/metrics"<br />       xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"<br />       xmlns:jolokia="http://www.jolokia.org/jolokia-spring/schema/config"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<br />                  http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd<br />                  http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd<br />                  http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd<br />                  http://www.jolokia.org/jolokia-spring/schema/config http://www.jolokia.org/jolokia-spring/schema/config/jolokia-config.xsd<br />                  http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;<br /><br />    &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;<br />        &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;<br />        &lt;property name="locations"&gt;<br />            &lt;list&gt;<br />                &lt;value&gt;classpath:/conf.properties&lt;/value&gt;<br />            &lt;/list&gt;<br />        &lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;jolokia:agent lookupConfig="true" systemPropertiesMode="never"&gt;<br />        &lt;jolokia:config<br />                autoStart="true"<br />                host="${jolokia.host}"<br />                port="${jolokia.port}"<br />                user="${jolokia.user}"<br />                password="${jolokia.password}"/&gt;<br />    &lt;/jolokia:agent&gt;<br />    ...<br />&lt;/beans&gt;</code></pre><br /><div style="text-align: justify;">Et... c'est tout... Jolokia est intégré à notre petite <i>stack</i>.</div><h2 id="int-gration-de-swagger">Intégration de Swagger</h2><div style="text-align: justify;">Concernant l'intégration de Swagger, cela ne diffère en rien de mon article précédent. Même problème de CORS, même hack...</div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-ev6GX1U7SEs/Ux8fxhWTl_I/AAAAAAAABRo/srY62BOqZS4/s1600/si-swagger.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-ev6GX1U7SEs/Ux8fxhWTl_I/AAAAAAAABRo/srY62BOqZS4/s1600/si-swagger.png" height="582" width="640" /></a></div><br /><h2 id="branchement-des-plugins-maven-appassembler-et-assembly">Branchement des plugins Maven Appassembler et Assembly</h2><div style="text-align: justify;">De même  que pour Swagger, rien à signaler de particulier par rapport à mon article précédent... cela fonctionne sans problème ;-)</div><h1 id="conclusion">Conclusion</h1><div style="text-align: justify;">En conclusion, on peut constater que l'intégration de Spring integration dans notre petite <i>stack</i> est tout aussi trivial que le reste!</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Encore une fois, simple et efficace ;-)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, on peut bénéficier du meilleur des deux mondes. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Bien sûr, on peut se poser la question de l'intérêt de brancher quelques choses de véloce (Netty) avec un framework succeptible d'entrainer un <i>Overhead</i> (spring integration) et qui serait, alors, le point de contension. La question est légitime mais je n'y répondrai pas... ;-) (pour bien faire, il faudrait faire un <i>benchmark</i>).</div></div>
