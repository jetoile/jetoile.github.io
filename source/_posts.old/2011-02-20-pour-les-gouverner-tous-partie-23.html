---
layout: post
title: "Pour les gouverner tous - partie 2/3"
date: 2011-02-20
comments: false
categories:
 - java
 - jgroups
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_XLL8sJPQ97g/TUcoTratqiI/AAAAAAAAAUQ/Gmc1h0rvA2w/s1600/jmx_jgroups01.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em; text-align: justify;"><img border="0" height="173" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/TUcoTratqiI/AAAAAAAAAUQ/Gmc1h0rvA2w/s320/jmx_jgroups01.png" width="320" /></a></div><div style="text-align: justify;">Cet article fait suite à mon <a href="http://jetoile.blogspot.com/2011/01/pour-les-gouverner-tous-partie-13.html">article précédent</a> et a pour objectif de présenter un petit POC (<em>Proof Of Concept</em>) simplicime mettant en oeuvre JGroups&nbsp;en version 2.11.0.GA (la dernière version stable à ce jour). Le principe est de montrer comment il est possible d'utiliser JGroups pour permettre à plusieurs instances d'une même application de se partager les valeurs d'une donnée. Enfin, pour être plus précis, cet objet partagé ne le sera pas vraiment (ndlr : partagé) par toutes les instances mais il s'agira plutôt de permettre à chaque nouvelle instance de récupérer la valeur d'une donnée auprès des autres instance déjà présentes dans le système. En outre, les autres instances déjà présentes devront recevoir directement la valeur de la donnée de la nouvelle instance.</div><div style="text-align: justify;">L'autre raison d'être de cet article permettra d'introduire la couche protocolaire utilisée par mon petit POC qui permet de rendre distribuable un agent JMX dans une architecture distribuée.</div><!-- more --><br /><h1 style="text-align: justify;">Spécification des besoins/pré-requis</h1><div style="text-align: justify;">Ce projet s'appuiera sur les pré-requis suivant :</div><ul><li style="text-align: justify;"><a href="http://www.slf4j.org/">slf4j</a>/<a href="http://logback.qos.ch/">logback</a> pour la partie log</li><li style="text-align: justify;"><a href="http://maven.apache.org/index.html">maven 3</a> (ou 2 au choix) pour la partie build</li><li style="text-align: justify;">et... <a href="http://www.jgroups.org/">JGroups</a> dans sa version 2.11.0.GA ;-)</li></ul><div style="text-align: justify;">Coté tests unitaires, je m'excuse préalablement auprès de vous, mais il n'y en aura pas... et cela pour deux raisons que je vous laisse choisir :</div><ul><li style="text-align: justify;">je suis flemmard ;-) mais surtout, je n'ai pas envie de mocker la terre entière.&nbsp;</li><li style="text-align: justify;">ce petit programme est plus une utilisation basique de JGroups et, le produit fonctionnant bien, je ne vois pas l'intérêt de le retester. En outre, ici, il est plus intéressant de tester de manière intégrée que de manière unitaire en raison de l'aspect distribué de l'application.</li></ul><div style="text-align: justify;">Comme je l'ai mentionné précédemment dans l'introduction, le but de cet article est simple :&nbsp;une application dispose de plusieurs instances qui se trouvent sur des JVM distinctes (il peut donc s'agir d'instances exécutées sur une ou plusieurs machines).</div><ul><li style="text-align: justify;">Si une nouvelle instance est démarrée, elle doit pouvoir demander à toutes les autres instances de l'application la valeur d'une donnée X afin, par exemple, de connaître leur état.&nbsp;</li><li style="text-align: justify;">De plus, toutes les instances déjà existantes dans le système doivent pouvoir être notifiées de l'arrivée d'une nouvelle instance et, par la même occasion, recevoir sa valeur courante de la donnée X.&nbsp;</li><li style="text-align: justify;">Enfin, si une instance disparait du sytème (arrêt, ...), toutes les instances doivent automatiquement supprimer en leur sein la valeur de la donnée de l'instance incriminée.</li></ul><div style="text-align: justify;">Coté configuration de JGroups, cet article s'appuiera sur une configuration par défaut, c'est à dire une configuration en UDP.</div><h1 style="text-align: justify;">Architecture de l'application</h1><div style="text-align: justify;">Comme vous pouvez vous en douter, l'architecture de l'application sera simple puisque JGroups fournit nativement de nombreuses possibilités. Aussi, je ne présenterai pas de super conception.</div><div style="text-align: justify;">Par contre, si les termes <b>ReceiverAdapter</b>, <b>MembershipListener</b> ou <b>View</b> ne vous parlent pas, je vous renverrai :</div><ul><li style="text-align: justify;">soit, à mon <a href="http://jetoile.blogspot.com/2010/12/jgroups-tour-d.html">article</a> sur JGroups ;-)</li><li style="text-align: justify;">soit (mieux), à la <a href="http://www.jgroups.org/ug.html">documentation</a> officielle de ce dernier.</li></ul><div style="text-align: justify;">Notre application sera composée de trois parties :</div><ul><li style="text-align: justify;">La partie donnée : la classe <b>Data</b> représentera la donnée à faire transiter. Il s'agira d'un simple POJO qui sera, bien sûr, sérialisable.</li><li style="text-align: justify;">La partie notification de changement de l'infrastructure (ie. arrivé ou arrêt d'une instance dans le système) : la classe <b>ChangeInfraListener</b> qui implémentera l'interface <i>MembershipListener</i> et donc la méthode<i> viewAccepted()</i> <em>call-backé</em> par JGroups pour notifier d'un changement au niveau d'une des ses vues.</li><li style="text-align: justify;">La partie qui aura à sa charge l'exposition de la donnée représentée par la classe <i>Data</i> et qui aura initialisera l'application : la classe <b>JGroupsClient</b> qui étendra la classe <i>ReceiverAdapter</i> afin de permettre aux autres instances d'interargir avec.</li></ul><div style="text-align: justify;">Coté canaux, l'application en utilisera un seul canal : le canal "<i>channel</i>" qui sera utilisé pour être être notifié de changement d'état sur la vue (il sera donc connecté à la classe implémentant l'interface <i>MembershipListener</i> (ie. <i>ChangeInfraListener</i>) et qui sera également&nbsp;utilisé pour la communication point à point entre les différentes instances : pour rappel, à un membre d'une vue est associée une adresse unique et une vue contient l'ensemble des membres de cette dernière.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A noter que pour la récupération de la donnée au démarrage d'une instance, il aurait également été possible d'implémenter les méthodes <i>getState()</i> et <i>setState()</i> (en combinaison de l'utilisation de la méthode <i>connect(&lt;String&gt; , &lt;Address&gt;, &lt;String&gt;, &lt;long&gt;)</i> sur l'instance de Channel utilisée). Cependant, il était, quand même nécessaire d'implémenter la méthode <i>viewAccepted()</i> afin d'être notifié du démarrage ou de l'arrêt d'une instances dans le système et cela aurait été redondant avec les notifications reçues (en effet, récupérer l'état des autres instances des membres de la vue ne dispense pas de recevoir l'état de la vue via la méthode <i>viewAccepted()</i>). Aussi, je n'ai pas utilisé cette fonctionnalité de JGroups.</div><div style="text-align: justify;">Diagramme de séquence lors de la connexion d'une nouvelle instance de l'application au système, coté nouvelle instance mais aussi coté&nbsp;instances déjà présentes dans le système :</div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-DsKcW_KWIZM/TWFDF_0MbsI/AAAAAAAAAUw/EAXva9PJsm8/s1600/jgroups_seq_diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="260" src="http://4.bp.blogspot.com/-DsKcW_KWIZM/TWFDF_0MbsI/AAAAAAAAAUw/EAXva9PJsm8/s400/jgroups_seq_diagram.png" width="400" /></a></div><h1>Mise en oeuvre</h1><div style="text-align: justify;">A noter que le code écrit ici ne contiendra pas les imports par souci de lisibilité.</div><h2 style="text-align: justify;">La classe JGroupsClient</h2><div style="text-align: justify;">Commençons donc par la mise en oeuvre de la classe <b>JGroupsClient</b> :</div><pre class="brush:java; wrap-lines: false; auto-links: false">package com.jetoile.jgroups.sample;<br />public class JGroupsClient extends ReceiverAdapter {<br /><br />    final static private Logger LOGGER = LoggerFactory.getLogger(JGroupsClient.class);<br /><br />    final private Data data = new Data();<br />    private RpcDispatcher rpcDispatcher;<br />    private Channel channel;<br /><br />    public JGroupsClient(final String data) {<br />        this.data.setData(data);<br />    }<br /><br />    public void stop() throws IOException {<br />        this.channel.close();<br />    }<br /><br />    public void start() throws ChannelException {<br />        this.channel = new JChannel("default-udp.xml");<br /><br />        final ChangeInfraListener changeSetListener = new ChangeInfraListener(channel);<br />        rpcDispatcher = new RpcDispatcher(this.channel, null, changeSetListener, this);<br />        changeSetListener.setRpcDispatcher(rpcDispatcher);<br />        this.channel.connect("privateChannel");<br />        this.data.setAddress(this.channel.getAddress());<br />    }<br /><br />    public Data getData() {<br />        return this.data;<br />    }<br />}<br /></pre><div><div style="text-align: justify;">Dans cette classe, on observe donc que l'on a :</div><ul><li style="text-align: justify;">la méthode start() qui a à sa charge la partie connexion à JGroups,</li><li style="text-align: justify;">la méthode<i> getData()</i> qui correspond à la méthode exposée utilisée pour transmettre la valeur de la donnée aux autres instances.</li></ul></div><h2 style="text-align: justify;">La classe ChangeInfraListener</h2><div><div style="text-align: justify;">Pour la classe&nbsp;<b>ChangeInfraListener</b>, nous aurons&nbsp;:</div></div><pre class="brush:java; wrap-lines: false; auto-links: false">package com.jetoile.jgroups.sample;<br /><br />public class ChangeInfraListener implements MembershipListener {<br /><br />    final static private Logger LOGGER = LoggerFactory.getLogger(ChangeInfraListener.class);<br /><br />    final private Map&lt;Address, String&gt; dataCache = new HashMap&lt;Address, String&gt;();<br /><br />    final private Channel privateChannel;<br /><br />    private RpcDispatcher rpcDispatcher;<br /><br />    public ChangeInfraListener(final Channel privateChannel) {<br />        this.privateChannel = privateChannel;<br />    }<br /><br />    public void setRpcDispatcher(RpcDispatcher rpcDispatcher) {<br />        this.rpcDispatcher = rpcDispatcher;<br />    }<br /><br />    @Override<br />    public void viewAccepted(View new_view) {<br />        // when a new member is up<br />        List&lt;Address&gt; newAddresses = getNewAddresses(new_view.getMembers());<br /><br />        newAddresses.remove(privateChannel.getAddress());<br /><br />        List&lt;Address&gt; ads = new ArrayList&lt;Address&gt;();<br />        for (Address ad : newAddresses) {<br />            if (!dataCache.containsKey(ad)) {<br />                ads.add(ad);<br />            }<br />        }<br /><br />        if (!ads.isEmpty()) {<br />            MethodCall methodCall = new MethodCall("getData", new Object[] {}, new Class[] {});<br />            LOGGER.debug("invoke remote getData on: {}", ads);<br /><br />            RspList resps = rpcDispatcher.callRemoteMethods(ads, methodCall, RequestOptions.SYNC);<br />            LOGGER.debug("after invoke getData - nb result {}", resps.numReceived());<br /><br />            if (resps.numReceived() == 0) {<br />                LOGGER.debug("retry...");<br />                resps = rpcDispatcher.callRemoteMethods(ads, methodCall, RequestOptions.SYNC);<br />            }<br /><br />            for (Object resp : resps.getResults()) {<br />                Data data = (Data) resp;<br />                LOGGER.debug("new data: {}", data);<br />                dataCache.put(data.getAddress(), data.getData());<br />            }<br />        }<br /><br />        List&lt;Address&gt; olds = getObsoleteAddresses(new_view.getMembers());<br />        for (Address old : olds) {<br />            LOGGER.debug("remove data: {}", old);<br />            dataCache.remove(old);<br />        }<br />    }<br /><br />    @Override<br />    public void suspect(Address suspected_mbr) {<br />        // NOTHING TO DO<br />    }<br /><br />    @Override<br />    public void block() {<br />        // NOTHING TO DO<br />    }<br /><br />    List&lt;Address&gt; getNewAddresses(Vector&lt;Address&gt; newMembers) {<br />        List&lt;Address&gt; result = new ArrayList&lt;Address&gt;();<br />        for (Address address : newMembers) {<br />            if (!this.dataCache.containsKey(address)) {<br />                result.add(address);<br />            }<br />        }<br />        return result;<br />    }<br /><br />    List&lt;Address&gt; getObsoleteAddresses(Vector&lt;Address&gt; newMembers) {<br />        List&lt;Address&gt; result = new ArrayList&lt;Address&gt;();<br />        for (Address address : this.dataCache.keySet()) {<br />            if (!newMembers.contains(address)) {<br />                result.add(address);<br />            }<br />        }<br />        return result;<br />    }<br />}<br /></pre><div><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><div style="text-align: justify;">Dans cette classe, on observe que la&nbsp;méthode <i>viewAccepted()</i>&nbsp;(qui est la méthode <i>call-backé</i> par JGroups lors d'une modification de la vue (ie. lors de la connexion ou de la déconnexion d'un autre membre du groupe)), invoque, si un nouveau membre est apparu, l'appel de la méthode&nbsp;distante&nbsp;<i>getData() </i>sur la nouvelle instance en question.&nbsp;</div></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><div style="text-align: justify;">Il est intéressant de noter l'utilisation qui est faite de la classe <b>RequestOptions</b> mais également le fait que les méthode <i>block()</i> et <i>suspect()</i>&nbsp;n'ont pas été spécifiées dans notre cas d'utilisation.&nbsp;</div></div></div><h2 style="text-align: justify;">La classe Data</h2><div style="text-align: justify;">Enfin, la classe<b> Data</b> qui sera utilisée est la suivante (par souci de lisibilité, les méthodes <i>equals()</i> et <i>hashCode()</i> ne sont pas détaillées ici) :</div><pre class="brush:java; wrap-lines: false; auto-links: false">package com.jetoile.jgroups.sample;<br /><br />public class Data implements Serializable {<br /> private Address address;<br /> private String data;<br /><br /> public Data() {<br /> }<br /><br /> public Address getAddress() {<br />  return address;<br /> }<br /><br /> public void setAddress(final Address address) {<br />  this.address = address;<br /> }<br /><br /> public String getData() {<br />  return data;<br /> }<br /><br /> public void setData(String data) {<br />  this.data = data;<br /> }<br /><br /> @Override<br /> public int hashCode() {<br />  // cf. gitHub<br />  return 0;<br /> }<br /><br /> @Override<br /> public boolean equals(Object obj) {<br />  // cf. gitHub<br />  return true;<br /> }<br /><br /> @Override<br /> public String toString() {<br />  return "Data [address=" + address + ", data=" + data + "]";<br /> }<br />}<br /></pre><div><div style="text-align: justify;">Cette classe, comme on peut le remarquer, n'a rien de particulier, si ce n'est qu'elle est sérialisable.</div><div style="text-align: justify;"><br /></div></div><div style="text-align: justify;">Ainsi, on peut voir que l'implémentation est très simple (je ne commenterai donc pas ce qui est fait ici...).</div><h1 style="text-align: justify;">Exécution et utilisation</h1><div style="text-align: justify;">L'exécution, quant à elle, pourra se faire avec une classe de type :</div><pre class="brush:java; wrap-lines: false; auto-links: false">package com.jetoile.jgroups.sample.sample;<br /><br />public class JGroupsClientTest {<br /><br /> public static void main(String[] args) throws ChannelException {<br />  JGroupsClient jgroupsClient = new JGroupsClient("toto");<br />  jgroupsClient.start();<br /> }<br />}</pre><br /><div style="text-align: justify;">A noter que si les différentes instances venaient à ne pas se voir, cela peut provenir d'un souci avec la configuration réseau et qu'il est possible de palier à ce problème en forçant l'utilisation d'adresse IPV4 avec l'option JVM suivante :</div><pre class="brush:bash; wrap-lines: false; auto-links: false">-Djava.net.preferIPv4Stack=true<br /></pre><h1>Conclusion</h1><div style="text-align: justify;">On a vu ici que&nbsp;permettre la communication d'instances d'une application de manière distribuée était aisée avec JGroups. Bien sûr (et comme je l'ai fait remarqué précédemment), la notion de<i> tuning</i> de JGroups (ie. la configuration de la couche protocolaire - cf. <a href="http://jetoile.blogspot.com/2010/12/jgroups-tour-d.html#protocoles">mon article précédent</a>) n'a pas été abordée, mais cela doit être fait en fonction des besoins de l'infrastructure (trafic&nbsp;réseau, firewall, sécurité, ...) et je laisse donc ce point à la convenance de chacun ;-).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ici se&nbsp;clôture&nbsp;donc la partie JGroups de notre petit POC jmanager4all qui nous a permis de voir comment JGroups répondait à notre besoin mais également comment il allait être utilisé par la suite.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Le prochain article s'attaquera donc à la partie interopérabilité avec JMX.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A oui... j'oubliais... le code de se petit POC se trouve sur GitHub :&nbsp;<a href="https://github.com/jetoile/jgroups-sample">https://github.com/jetoile/jgroups-sample</a></div></div>
