<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jmx | Jetoile]]></title>
  <link href="https://blog.jetoile.fr/blog/categories/jmx/atom.xml" rel="self"/>
  <link href="https://blog.jetoile.fr/"/>
  <updated>2017-07-17T12:09:03+02:00</updated>
  <id>https://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Undertow pour booster vos services REST]]></title>
    <link href="https://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest.html"/>
    <updated>2015-06-23T14:51:56+02:00</updated>
    <id>https://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest</id>
    <content type="html"><![CDATA[<p><img src="/images/undertow.png" alt="left-small" />
Il y a quelques temps, j'avais fait une série d'articles sur <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>.</p>

<p>Cette article repart du même besoin, à savoir disposer d'une <em>stack</em> légère pour réaliser un service REST, mais en utilisant <a href="http://undertow.io/">Undertow</a> plutôt que Resteasy-Netty.</p>

<!-- more -->


<p>Au niveau des besoins, ils seront identiques ie. :</p>

<ul>
<li>utiliser JAX-RS,</li>
<li>intégrer Swagger,</li>
<li>intégrer Jolokia,</li>
<li>générer un livrable autoporteur.</li>
</ul>


<p>RestEasy-Netty, même s'il existe de nombreux points d'entrée, demande quelques phases de <em>hack</em> (gestion du <em>crossover domain</em> par exemple) et dispose d'un mécanisme un peu limité concernant la partie sécurité.</p>

<p>En outre, l'absence du mécanisme de Servlet reste un peu embêtant pour mettre en place certaines <em>features</em> comme le MDC ( <a href="http://logback.qos.ch/manual/mdc.html"><em>Mapped Diagnostic Context</em></a> ) bien pratique lorsque l'on est dans une architecture type microservice.</p>

<p>Le code complet est disponible <a href="https://github.com/jetoile/undertow-sample">ici</a>.</p>

<h1>Rappel du cahier des charges</h1>

<p>Comme je l'ai déjà indiqué dans les autres posts, l'objectif est seulement de montrer comme il peut être simple d'exposer un service REST à l'aide d'<a href="http://undertow.io/">Undertow</a>. Pour ce faire, un simple service sera exposé et il consistera à répèter ce qu’on lui demande…</p>

<p>Il répondra donc à une requête de type GET du type : <a href="http://localhost:8081/sample/say/">http://localhost:8081/sample/say/</a><message></p>

<p>Du coté de la réponse, elle aura la forme suivante :
```javascript
{</p>

<pre><code>"message": &lt;message&gt;,
"time":"2015-06-23T15:18:50.748"
</code></pre>

<p>}
```</p>

<h1>Mise en oeuvre</h1>

<p>A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :
```text</p>

<pre><code>compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.11.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.3.1'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.12'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'javax.servlet-api', version:'3.1.0'
compile group: 'io.dropwizard.metrics', name: 'metrics-core', version:'3.1.2'
compile group: 'io.undertow', name: 'undertow-core', version:'1.2.8.Final'
compile group: 'io.undertow', name: 'undertow-servlet', version:'1.2.8.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-undertow', version:'3.0.11.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson2-provider', version:'3.0.11.Final'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version:'2.5.4'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version:'2.5.4'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version:'2.5.4'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.10'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'org.slf4j', name: 'slf4j-api', version:'1.7.12'
compile group: 'ch.qos.logback', name: 'logback-classic', version:'1.1.3'
</code></pre>

<p>```</p>

<p>Concernant la version des différentes dépendances, on constate que ce n'est pas swagger2 qui est utilisé en raison d'une incapacité de ma part à l'intégrer&hellip; :&lsquo;(</p>

<h1>Implémentation du service REST</h1>

<p>Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial… et la classe ci-dessous fait humblement l’affaire :
```java
@Api(value = &ldquo;/sample&rdquo;,</p>

<pre><code>    description = "the sample api")
</code></pre>

<p>@Path(&ldquo;/sample&rdquo;)
@RolesAllowed(&ldquo;admin&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);


@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
@ApiOperation(value = "repeat the word",
        notes = "response the word",
        response = DtoResponse.class)
@ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})
public Response sayHello(@PathParam("msg") String message) {

    log.info("sample log");

    final Timer timer = Main.metricRegistry.timer(name(SimpleService.class, "say-service"));
    final Timer.Context context = timer.time();
    try {

        DtoResponse response = new DtoResponse();
        try {
            response.setMessage(message);
            response.setTime(LocalDateTime.now());
        } catch (Exception e) {
            log.error("internal error: {}", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(response).build();
    } finally {
        if (context != null) context.stop();
    }
}
</code></pre>

<p>}
<code>
Coté du DTO, il est le suivant :
</code>java
@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
private LocalDateTime time;

public DtoResponse() {
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

public LocalDateTime getTime() {
    return time;
}

public void setTime(LocalDateTime time) {
    this.time = time;
}
</code></pre>

<p>}
```</p>

<p>On remarquera l'utilisation de Java8 pour la gestion du temps plutôt que Joda-Time.</p>

<p>En outre, concernant les annotations Swagger et l'utilisation de metrics, nous y reviendrons plus tard.</p>

<p>Concernant le message de log, de même, nous y reviendrons plus tard avec l'intégration d'un MDC pour les logs.</p>

<h1>Mise en oeuvre avec Undertow</h1>

<p>Mettre en place Resteasy avec Undertow est très simple, d’après la documnentation, il suffit de faire :
```java
SimpleService simpleService = new SimpleService();
ResteasyDeployment deployment = new ResteasyDeployment();</p>

<p>deployment.setResources(Arrays.<Object>asList(simpleService));</p>

<p>int port = config.getInt(&ldquo;undertow.port&rdquo;, TestPortProvider.getPort());
String host = config.getString(&ldquo;undertow.host&rdquo;, String.valueOf(TestPortProvider.getHost()));
System.setProperty(&ldquo;org.jboss.resteasy.port&rdquo;, String.valueOf(TestPortProvider.getPort());
System.setProperty(&ldquo;org.jboss.resteasy.host&rdquo;, String.valueOf(TestPortProvider.getHost());</p>

<p>UndertowJaxrsServer server = new UndertowJaxrsServer();</p>

<p>DeploymentInfo deploymentInfo = server.undertowDeployment(deployment);
deploymentInfo.setDeploymentName(&ldquo;&rdquo;);
deploymentInfo.setContextPath(&ldquo;/&rdquo;);
deploymentInfo.setClassLoader(Main.class.getClassLoader());</p>

<p>deployment.setProviderFactory(new ResteasyProviderFactory());
server.deploy(deploymentInfo);
server.start(Undertow.builder().addHttpListener(port, host));
```</p>

<p>On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <code>setResources()</code> sur l’instance de <em>ResteasyDeployment</em> fournit au serveur <em>UndertowJaxrsServer</em> :</p>

<p>Et voilà! On dispose désormais d’un programme exécutable qui démarre un serveur REST basé sur Undertow.</p>

<p>Par contre, il semble que le service ne rende pas vraiment ce que l'on voulait :
<code>bash
curl 'http://localhost:8081/sample/say/&lt;message&gt;'
</code></p>

<p>```json
{</p>

<pre><code>"message": "&lt;message&gt;",
"time": {
    "hour": 15,
    "minute": 55,
    "second": 51,
    "nano": 225000000,
    "year": 2015,
    "month": "JUNE",
    "dayOfMonth": 23,
    "dayOfWeek": "TUESDAY",
    "dayOfYear": 174,
    "monthValue": 6,
    "chronology": {
        "calendarType": "iso8601",
        "id": "ISO"
    }
}
</code></pre>

<p>}
```</p>

<p>Pas de souci, il suffit de préciser comment on souhaite que LocalDateTime soit sérialisé par Jackson :</p>

<p>Ainsi, notre DTO devient :
```java</p>

<p>@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
@JsonSerialize(using = LocalDateTimeToStringSerializer.class)
private LocalDateTime time;

public DtoResponse() {
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

public LocalDateTime getTime() {
    return time;
}

public void setTime(LocalDateTime time) {
    this.time = time;
}
</code></pre>

<p>}
```</p>

<p>où :</p>

<p>```java
public class LocalDateTimeToStringSerializer extends JsonSerializer<LocalDateTime> {</p>

<pre><code>@Override
public void serialize(LocalDateTime value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
    jgen.writeObject(value.format(DateTimeFormatter.ISO_DATE_TIME));
}
</code></pre>

<p>}
```</p>

<p>Après ces modifications, on obtient bien :</p>

<p><code>json
{"message":"&lt;message&gt;","time":"2015-06-23T16:04:01.419"}
</code></p>

<h1>Intégration de Metrics</h1>

<p>Concernant l'intégration de Metrics, pas grand chose de nouveau et donc pas grand chose à dire ;&ndash;)</p>

<p>Déclarer le registry :
<code>java
metricRegistry = new MetricRegistry();
final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();
reporter.start();
</code></p>

<p>Et utiliser le dans vos classes :
```java
final Timer timer = Main.metricRegistry.timer(name(SimpleService.class, &ldquo;say-service&rdquo;));
final Timer.Context context = timer.time();
try {</p>

<pre><code>...
</code></pre>

<p>} finally {</p>

<pre><code>if (context != null) context.stop();
</code></pre>

<p>}
```</p>

<h1>Intégration de la sécurité</h1>

<p>Undertow permet une bien meilleur intégration de la sécurité que RestEasy-Netty. En effet, grâce au mécanisme de Servlet, il est possible de bénéficier de toute la puissance des conteneurs de Servlets.</p>

<p>Du coté du serveur Undertow, il suffit donc de définir un <em>ServletIdentityManager</em> et de lui fournir un <em>LoginConfig</em> :
```java
deployment.setSecurityEnabled(true);</p>

<p>ServletIdentityManager identityManager = new ServletIdentityManager();
identityManager.addUser(&ldquo;khanh&rdquo;, &ldquo;khanh&rdquo;, &ldquo;admin&rdquo;);</p>

<p>deploymentInfo = deploymentInfo.setIdentityManager(identityManager).setLoginConfig(new LoginConfig(&ldquo;BASIC&rdquo;, &ldquo;Test Realm&rdquo;));
```</p>

<p>où :
```java
public class ServletIdentityManager implements IdentityManager {</p>

<pre><code>private static final Charset UTF_8 = Charset.forName("UTF-8");
private final Map&lt;String, UserAccount&gt; users = new HashMap&lt;&gt;();

public void addUser(final String name, final String password, final String... roles) {
    UserAccount user = new UserAccount();
    user.name = name;
    user.password = password.toCharArray();
    user.roles = new HashSet&lt;&gt;(Arrays.asList(roles));
    users.put(name, user);
}

@Override
public Account verify(Account account) {
    // Just re-use the existing account.
    return account;
}

@Override
public Account verify(String id, Credential credential) {
    Account account = users.get(id);
    if (account != null &amp;&amp; verifyCredential(account, credential)) {
        return account;
    }

    return null;
}

@Override
public Account verify(Credential credential) {
    return null;
}

private boolean verifyCredential(Account account, Credential credential) {
    // This approach should never be copied in a realm IdentityManager.
    if (account instanceof UserAccount) {
        if (credential instanceof PasswordCredential) {
            char[] expectedPassword = ((UserAccount) account).password;
            char[] suppliedPassword = ((PasswordCredential) credential).getPassword();

            return Arrays.equals(expectedPassword, suppliedPassword);
        } else if (credential instanceof DigestCredential) {
            DigestCredential digCred = (DigestCredential) credential;
            MessageDigest digest = null;
            try {
                digest = digCred.getAlgorithm().getMessageDigest();

                digest.update(account.getPrincipal().getName().getBytes(UTF_8));
                digest.update((byte) ':');
                digest.update(digCred.getRealm().getBytes(UTF_8));
                digest.update((byte) ':');
                char[] expectedPassword = ((UserAccount) account).password;
                digest.update(new String(expectedPassword).getBytes(UTF_8));

                return digCred.verifyHA1(HexConverter.convertToHexBytes(digest.digest()));
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException("Unsupported Algorithm", e);
            } finally {
                digest.reset();
            }
        }
    }
    return false;
}

private static class UserAccount implements Account {
    // In no way whatsoever should a class like this be considered a good idea for a real IdentityManager implementation,
    // this is for testing only.

    String name;
    char[] password;
    Set&lt;String&gt; roles;

    private final Principal principal = new Principal() {
        @Override
        public String getName() {
            return name;
        }
    };

    @Override
    public Principal getPrincipal() {
        return principal;
    }

    @Override
    public Set&lt;String&gt; getRoles() {
        return roles;
    }
}
</code></pre>

<p>}
```</p>

<p>Il s'agit ici d'une Basic Authentification mais il est bien sûr possible d'en mettre en place d'autre.</p>

<p>Coté autorisation, il est alors possible de bénéficier de l'annotation <code>@RolesAllowed</code> de JAX-RS :
<code>java
@Path("/sample")
@RolesAllowed("admin")
public class SimpleService {
...
}
</code></p>

<h1>Intégration d'un MDC</h1>

<p>Concernant la mise en place d'un MDC (<em>Mapped Diagnostic Context</em>), le fait de bénéficier du mécanisme de <em>Filter</em> des Servlets rend la chose beaucoup plus simple.</p>

<p>En effet, une fois la couche sécurité branchée, il suffit de récupérer le <code>UserPrincipal</code> dans la requête et l'enregistrer dans le MDC.</p>

<p>La déclaration des Filters se fait de la manière suivante pour Undertow :
```java
FilterInfo mdcFilter = new FilterInfo(&ldquo;MDCFilter&rdquo;, MDCServletFilter.class);
deploymentInfo.addFilter(mdcFilter);
deploymentInfo.addFilterUrlMapping(&ldquo;MDCFilter&rdquo;, &ldquo;*&rdquo;, DispatcherType.REQUEST);</p>

<p>FilterInfo mdcInsertingFilter = new FilterInfo(&ldquo;MDCInsertingServletFilter&rdquo;, MDCInsertingServletFilter.class);
deploymentInfo.addFilter(mdcInsertingFilter);
deploymentInfo.addFilterUrlMapping(&ldquo;MDCInsertingServletFilter&rdquo;, &ldquo;*&rdquo;, DispatcherType.REQUEST);
```</p>

<p>Avec le filter ci-dessous :
```java
public class MDCServletFilter implements Filter {</p>

<pre><code>private final String USER_KEY = "username";

public void destroy() {
}

public void doFilter(ServletRequest request, ServletResponse response,
                     FilterChain chain) throws IOException, ServletException {

    boolean successfulRegistration = false;

    HttpServletRequest req = (HttpServletRequest) request;
    Principal principal = req.getUserPrincipal();
    // Please note that we could have also used a cookie to
    // retrieve the user name

    if (principal != null) {
        String username = principal.getName();
        successfulRegistration = registerUsername(username);
    }

    try {
        chain.doFilter(request, response);
    } finally {
        if (successfulRegistration) {
            MDC.remove(USER_KEY);
        }
    }
}

public void init(FilterConfig arg0) throws ServletException {
}


/**
 * Register the user in the MDC under USER_KEY.
 *
 * @param username
 * @return true id the user can be successfully registered
 */
private boolean registerUsername(String username) {
    if (username != null &amp;&amp; username.trim().length() &gt; 0) {
        MDC.put(USER_KEY, username);
        return true;
    }
    return false;
}
</code></pre>

<p>}
<code>
Ainsi, disposer d'un MDC permet d'ajouter automatiquement des informations dans les logs :
</code>xml
<configuration></p>

<pre><code>&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;%d{HH:mm:ss.SSS} %-5level %logger{36} %X{req.remoteHost} %X{req.requestURI} - C:%X{username} - %msg%n

        &lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;


&lt;root level="info"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
&lt;/root&gt;
</code></pre>

<p></configuration>
```</p>

<p>On obtient alors bien les logs voulues :
<code>text
17:15:11.466 INFO  f.j.sample.service.SimpleService 127.0.0.1 /sample/say/&lt;message&gt; - C:khanh - sample log
</code></p>

<h1>Intégration de Jolokia</h1>

<p>Coté Jolokia, pas grand chose à ajouter par rapport à ma série d'article précédent&hellip;
```java
try {</p>

<pre><code>        JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());

        JolokiaServer jolokiaServer = new JolokiaServer(config, true);
        jolokiaServer.start();
</code></pre>

<p>} catch (Exception e) {</p>

<pre><code>        LOGGER.error("unable to start jolokia server", e);
</code></pre>

<p>}
```</p>

<h1>Intégration de Swagger</h1>

<p>Concernant l'intégration de Swagger, le fait de disposer des <em>Filter</em> de Servlet permet de n'avoir pas à faire de <em>hack</em> immonde pour gérer le CORS (cf. <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">article précédent</a>) : il suffit de déclarer un <em>Filter</em> dans Undertow qui a, en outre, la chance d'exister :
```java
CorsFilter filter = new CorsFilter();
filter.setAllowedMethods(&ldquo;GET,POST,PUT,DELETE,OPTIONS&rdquo;);
filter.setAllowedHeaders(&ldquo;X-Requested-With, Content-Type, Content-Length, Authorization&rdquo;);
filter.getAllowedOrigins().add(&ldquo;*&rdquo;);</p>

<p>deployment.setProviderFactory(new ResteasyProviderFactory());
deployment.getProviderFactory().register(filter);
```</p>

<p>Concernant la déclaration dans Undertow, pas grand chose à ajouter :
```java</p>

<pre><code>private static void initSwagger(ResteasyDeployment deployment) {
    BeanConfig swaggerConfig = new BeanConfig();
    swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));
    swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));
    swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));
    swaggerConfig.setScan(true);
    swaggerConfig.setResourcePackage("fr.jetoile.sample.service");

    deployment.setProviderClasses(Lists.newArrayList(
            "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",
            "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));
    deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));
    deployment.setSecurityEnabled(false);
}
</code></pre>

<p>```</p>

<h1>Branchement des plugins Maven Appassembler et Assembly</h1>

<p>Coté génération du livrable, encore une fois, pas grand chose à ajouter par rapport à mon précédent article : l'utilisation des plugins assembly et appassembler est identique.</p>

<h1>Conclusion</h1>

<p>On avait vu dans les articles précédents que RestEasy-Netty était une solution intéressante pour la simplicité de sa mise en oeuvre ainsi que pour le faible overhead.</p>

<p>Cependant, certaines intégrations ressemblaient plus à du <em>hack</em> qu'à une solution configurable.</p>

<p>Undertow (enfin pour être plus précis RestEasy-Undertow) pour sa part offre la même simplicité que RestEasy-Netty mais il permet en plus de s'intégrer avec beaucoup d'autres choses et le fait de retrouver le mécanisme de <em>Filter</em> facilite énormément les choses (par exemple, je ne suis pas sûr que bénéficier du MDC avec RestEasy-Netty ait été aussi simple).</p>

<p>Coté performance, je reviendrai dessus dans un autre article mais je peux déjà dire que la solution RestEasy-Undertow n'a rien à envier à RestEasy-Netty.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty4 et Spring Integration : ils reviennent et ils ne sont pas content!]]></title>
    <link href="https://blog.jetoile.fr/2014/03/jaxrs-netty4-et-spring-integration-ils.html"/>
    <updated>2014-03-24T19:12:29+01:00</updated>
    <id>https://blog.jetoile.fr/2014/03/jaxrs-netty4-et-spring-integration-ils</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-XR47rmCwXK0/Ux8gpmR-TLI/AAAAAAAABR0/T1h_RtvDED0/s1600/resteasy_jolokia_metrics_orig3.png" alt="left-small" /></p>

<p>Pour faire suite à mes articles <a href="/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>, nous allons voir, dans cet article, comment il est possible de créer un service activator avec <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> qui exposera via resteasy-netty4 un service REST.</p>

<p>Ce service REST esposera simplement une opération en POST qui, via Spring Integration, écrira dans un fichier et qui, pour le fun, écrira également sur la console.</p>

<p>Pour ce faire, rien de plus simple, un <a href="http://www.eaipatterns.com/MessagingAdapter.html">Service Activator</a> de type <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">gateway</a> a été utilisé.</p>

<p>Cet article montrera donc comment il est possible d'intégrer Spring Integration à notre petite stack basé sur Resteasy-Netty4, Jackson, <a href="http://metrics.codahale.com/">Metrics</a>, <a href="https://helloreverb.com/developers/swagger">Swagger</a> et <a href="http://www.jolokia.org/">Jolokia</a>.</p>

<p>Le code se trouve sur Github <a href="https://github.com/jetoile/spring-integration-netty4">ici</a>.</p>

<!-- more -->


<h1>Présentation du usecase</h1>

<p>Le service qui est exposé est un service de type REST répondant à un appel de type POST et acceptant du JSON.</p>

<p>Il répondra à une requête de type :
<code>bash
curl -XPOST -H "Content-Type: application/json" -d '{"message": "hello", "time": "2014-03-05T10:55:39.835+01:00"}'  http://127.0.0.1:8081/sample/write
</code>
et écrira un fichier par requête reçue dans le répertoire <code>/tmp</code>. En outre, il loggera sur la console le message reçu.</p>

<p>Ainsi, avec la commande suivante, on devrait voir un incrément du nombre à chaque réception de message.
<code>bash
watch 'ls *.msg | wc -l'
</code></p>

<h1>Mise en oeuvre</h1>

<h2>Dépendances</h2>

<p>A titre informatif, les dépendances ainsi que leurs versions sont les suivantes (au format gradle) :
```text
dependencies {</p>

<pre><code>compile group: 'org.springframework.integration', name: 'spring-integration-core', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-jmx', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-http', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-file', version:'3.0.1.RELEASE'
compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-spring', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.ryantenney.metrics', name: 'metrics-spring', version:'3.0.0-RC4'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}
</code></pre>

<p>}
```</p>

<p>Pour le lecteur averti, il constatera que la version de Jackson utilisé ici est la 1 (ie. avec le groupId <strong>org.codehaus</strong>). En effet, Jackson 2 et JodaTime m'ont fait des misères et je n'ai pas réussi à les résoudre rapidement, donc, par flemme, je suis repassé en version 1&hellip; ;&ndash;)</p>

<h2>DTO</h2>

<p>Un DTO annoté JAX-B (compris par Jackson) sera utilisé pour représenter le JSON reçu dans le corps du POST.</p>

<p>Il se présente comme suit :
```java
@XmlRootElement
public class DtoRequest {</p>

<pre><code>private String message;
private DateTime time;

public String getMessage() { return message; }

public void setMessage(String message) { this.message = message; }

public DateTime getTime() { return time; }

public void setTime(DateTime time) { this.time = time; }

@Override
public String toString() {
    return "DtoRequest{" +
            "message='" + message + '\'' +
            ", time=" + time +
            '}';
}
</code></pre>

<p>}
```</p>

<p>Ici, la méthode <code>toString()</code> a été overridé car utilisé lors de l'affichage du message par le loggueur sur la console.</p>

<p>Jusque là, ça ne casse pas trois pattes à un canard ;&ndash;)</p>

<h2>Intégration complète de Spring Integration</h2>

<p>Pour rappel, Spring Integration est une implémentation des <a href="/2009/12/eip-quest-ce-que-cest.html">EIP</a> (<em>Enterprise Integration Patterns</em>) et propose donc une mise en oeuvre de l'architecture <strong>Pipes and Filters</strong>.</p>

<p><img src="http://3.bp.blogspot.com/-Pd_JIILTp_0/Ux8fIIRV-tI/AAAAAAAABRQ/hevpIqdQU4M/s1600/si-netty4-graph.png" alt="large" /></p>

<p>Au niveau écriture dans un répertoire, le <code>file-outbound-adapter</code> offert par Spring Integration sera utilisé :
```xml
file:outbound-channel-adapter id=&ldquo;fileAdapter&rdquo; auto-create-directory=&ldquo;true&rdquo;</p>

<pre><code>                                   directory="file:${out.directory}"
                                   channel="channel"/&gt;
</code></pre>

<p>```</p>

<p>Coté loggueur, ce sera le composant logging :
<code>xml
 &lt;int:logging-channel-adapter auto-startup="true" channel="channel" level="INFO" log-full-message="true"/&gt;
</code>
et où on aura un Pipe (channel) en mode <code>Publish-Subscribe</code> :
<code>xml
 &lt;int:publish-subscribe-channel id="channel"/&gt;
</code></p>

<p>Au niveau des namespaces et autres informations, on aura ce qui suit :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;
    &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
    &lt;property name="locations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/conf.properties&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
    &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
&lt;/bean&gt;

&lt;int-jmx:mbean-export default-domain="fr.jetoile.sample" server="mbeanServer"/&gt;

&lt;int:message-history/&gt;    
...
</code></pre>

<p></beans>
```</p>

<p>On y remarque la lecture du fichier de configuration, ainsi que les activations jmx adéquate afin d'avoir un peu d'informations ;&ndash;) Concernant l'élément message-history, cela permet de préciser à Spring Integration d'ajouter dans les headers du message (qui, pour rappel, transite via les Pipes entre les différents Filters) des informations de temps d'exécution.</p>

<p>En soit, il s'agit d'une configuration extrèmement simple pour toute personne connaissant un minimum Spring Integration, donc encore une fois, rien de compliqué&hellip; ;&ndash;)</p>

<h2>Gateway Spring Integration</h2>

<p>Afin de rentrer dans le vif du sujet, ce paragraphe montrera comment il est possible de transformer notre petit serveur Resteasy-Netty4 en une Gateway Spring Integration.</p>

<p>Pour ce faire, il suffit de définir une interface (NettyGateway) qui sera utilisée par Spring Integration.
Ci dessous un petit extract de la <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">documentation officielle</a> :</p>

<blockquote><p>Le rôle principale d'une Gateway est de chacher l'API de messaging fournit par Spring Integration. Cela permet à la logique business de l'application de s'abstraire complètement de l'API de Spring Integration et, en utilisant une Gateway générique, le code n'interagit qu'avec une simple interface.</p>

<p>&hellip;</p>

<p>En fait, Spring Integration fournit un GatewayProxyFactoryBean qui génère un proxy pour n'importe quelle interface et qui, en interne, invoque la méthode de la Gateway. Ainsi, en utilisant l'injection de dépendance, il est possible d'exposer l'interface aux méthodes business.</p></blockquote>

<p>```java
public interface NettyGateway {</p>

<pre><code>void send(DtoRequest msg);
</code></pre>

<p>}
```</p>

<p>Ainsi, notre service REST se présentera comme suit :
```java
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private NettyGateway messageProducer;

public void setGateway(NettyGateway messageProducer) {
    this.messageProducer = messageProducer;
}

@POST
@Path("/write")
@Consumes(MediaType.APPLICATION_JSON)
public Response write(DtoRequest message) {
    this.messageProducer.send(message);
    return Response.ok().build();
}
</code></pre>

<p>}
```</p>

<p>On y constatera que l'inteface NettyGateway lui a été injecté afin qu'il puisse servir de passe plat.</p>

<p>Coté Spring, la configuration est la suivante :
```xml
&lt;int:gateway id=&ldquo;nettyGateway&rdquo; service-interface=&ldquo;fr.jetoile.sample.gateway.NettyGateway&rdquo;</p>

<pre><code>             default-request-channel="channel"/&gt;
</code></pre>

<p><bean id="simpleService" class="fr.jetoile.sample.service.SimpleService"></p>

<pre><code>&lt;property name="gateway" ref="nettyGateway"/&gt;
</code></pre>

<p></bean>
<code>
Du coté de démarrage de notre serveur Resteasy-Netty4, cela ne sera, bien sûr, plus fait dans le `main()`, mais dans notre bean Spring à qui sera injectée notre classe implémentant notre service REST :
</code>xml
<bean id="nettyContainer" class="fr.jetoile.sample.gateway.NettyContainer"></p>

<pre><code>&lt;constructor-arg ref="simpleService"/&gt;
</code></pre>

<p></bean>
```</p>

<p>Avec :
```java
public class NettyContainer {</p>

<pre><code>private static final Logger LOGGER = LoggerFactory.getLogger(NettyContainer.class);

public static final String CONF_PROPERTIES = "conf.properties";

private static Configuration config;

private SimpleService simpleService;

public NettyContainer(SimpleService simpleService) {
    try {
        config = new PropertiesConfiguration(CONF_PROPERTIES);

    } catch (ConfigurationException e) {
        throw new IllegalArgumentException("bad config");
    }
    this.simpleService = simpleService;
    initServer();
}


private void initServer() {
    ResteasyDeployment deployment = new ResteasyDeployment();

    int nettyPort = 8081;

    if (config != null) {
        deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));
        deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));
        deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));
        deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));

        nettyPort = config.getInt("netty.port", TestPortProvider.getPort());
    } else {
        LOGGER.warn("is going to use default netty config");
    }

    deployment.setResources(Arrays.&lt;Object&gt;asList(simpleService));

    MyNettyJaxrsServer netty = new MyNettyJaxrsServer();

    netty.setDeployment(deployment);
    netty.setPort(nettyPort);
    netty.setRootResourcePath("");
    netty.setSecurityDomain(null);
    netty.start();
}
</code></pre>

<p>}
```</p>

<p>Et voilà&hellip; c'est tout!</p>

<p>Ne reste plus que la classe implémentant notre main() qui ne fera que charger le contexte spring :
```java
public class Client {</p>

<pre><code>public static void main(String[] args) throws ConfigurationException {
    new ClassPathXmlApplicationContext("springintegration-config.xml");
}
</code></pre>

<p>}
```</p>

<p>Juste un dernier point : le lecteur un peu concentré aura remarqué qu'il y a, ici, un petit meli melo dans la lecture des fichiers de configuration (parfois chargé par Spring, parfois chargé via commons-configuration). Je laisse cependant ces points en suspens et à la discrétion de la personne qui utilisera et lira cet article (ou qui aura atteint ce point&hellip;) (s'il y en a&hellip; ;&ndash;) ).</p>

<h2>Intégration de Metrics</h2>

<p>L'objectif de cet article étant de monter une stack &ldquo;presque complète&rdquo;, il est, bien sûr, primordial de fournir les bonnes métriques.</p>

<p>Comme dans mon article précédent, ce sera Metrics qui sera utilisé.</p>

<p>Cependant, alors que cela avait été fait programmatiquement, ce coup-ci, cela sera fait via Spring (parce que sinon ce n'est pas drôle&hellip; ;&ndash;) ).</p>

<p>Pour ce faire, c'est très simple, en tirant la dépendance <strong>&lsquo;com.ryantenney.metrics&rsquo;, name: &lsquo;metrics-spring&rsquo;, version:&lsquo;3.0.0-RC4&rsquo;</strong> au lieu de <strong>&lsquo;com.codahale.metrics&rsquo;, name: &lsquo;metrics-core&rsquo;</strong>, il ne reste qu'à ajouter à notre service REST l'annotation <code>@Timed</code> et d'ajouter dans la configuration Spring les éléments suivants :</p>

<p>```java
@POST
@Path(&ldquo;/write&rdquo;)
@Consumes(MediaType.APPLICATION_JSON)
@Timed
public Response write(DtoRequest message) {</p>

<pre><code>this.messageProducer.send(message);
return Response.ok().build();
</code></pre>

<p>}
```</p>

<p>Avec la configuration Spring suivante :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:metrics="http://www.ryantenney.com/schema/metrics"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd
              http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;

&lt;metrics:metric-registry id="metrics" /&gt;

&lt;metrics:annotation-driven metric-registry="metrics" /&gt;

&lt;metrics:reporter type="jmx" metric-registry="metrics" /&gt;
...
</code></pre>

<p></beans>
```</p>

<p>Pour montrer que je ne mens pas, on a donc (ici, utilisation de Hawt.io via Jolokia) :</p>

<p><img src="http://4.bp.blogspot.com/-CZebCZS47aE/Ux8fk-EwKQI/AAAAAAAABRY/C7OwMBMZNEc/s1600/si-hawtio-connextion.png" alt="medium" /></p>

<p><img src="http://2.bp.blogspot.com/-H-LmsIrivjA/Ux8fo7ORYpI/AAAAAAAABRg/EIp_-F6LzF4/s1600/si-hawtio-metrics.png" alt="medium" /></p>

<p>On constate encore une fois la simplicité de la chose!</p>

<h2>Intégration de Jolokia</h2>

<p>De même que pour notre paragraphe précédent, l'intégration de Jolokia se fera ici par configuration Spring plutôt que de manière programmatique.</p>

<p>Pour ce faire, il suffit de tirer la dépendance <strong>&lsquo;org.jolokia&rsquo;, name: &lsquo;jolokia-spring&rsquo;, version:&lsquo;1.1.2&rsquo;</strong> au lieu de <strong>&lsquo;org.jolokia&rsquo;, name: &lsquo;jolokia-jvm&rsquo;</strong>, et d'ajouter le bon bean à Spring :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:metrics="http://www.ryantenney.com/schema/metrics"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xmlns:jolokia="http://www.jolokia.org/jolokia-spring/schema/config"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd
              http://www.jolokia.org/jolokia-spring/schema/config http://www.jolokia.org/jolokia-spring/schema/config/jolokia-config.xsd
              http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;
    &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
    &lt;property name="locations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/conf.properties&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;jolokia:agent lookupConfig="true" systemPropertiesMode="never"&gt;
    &lt;jolokia:config
            autoStart="true"
            host="${jolokia.host}"
            port="${jolokia.port}"
            user="${jolokia.user}"
            password="${jolokia.password}"/&gt;
&lt;/jolokia:agent&gt;
...
</code></pre>

<p></beans>
```</p>

<p>Et&hellip; c'est tout&hellip; Jolokia est intégré à notre petite stack.</p>

<h2>Intégration de Swagger</h2>

<p>Concernant l'intégration de Swagger, cela ne diffère en rien de mon article précédent. Même problème de CORS, même hack&hellip;</p>

<p><img src="http://4.bp.blogspot.com/-ev6GX1U7SEs/Ux8fxhWTl_I/AAAAAAAABRo/srY62BOqZS4/s1600/si-swagger.png" alt="medium" /></p>

<h2>Branchement des plugins Maven Appassembler et Assembly</h2>

<p>De même que pour Swagger, rien à signaler de particulier par rapport à mon article précédent&hellip; cela fonctionne sans problème ;&ndash;)</p>

<h1>Conclusion</h1>

<p>En conclusion, on peut constater que l'intégration de Spring integration dans notre petite stack est tout aussi trivial que le reste!</p>

<p>Encore une fois, simple et efficace ;&ndash;)</p>

<p>Ainsi, on peut bénéficier du meilleur des deux mondes.</p>

<p>Bien sûr, on peut se poser la question de l'intérêt de brancher quelques choses de véloce (Netty) avec un framework succeptible d'entrainer un Overhead (spring integration) et qui serait, alors, le point de contension. La question est légitime mais je n'y répondrai pas&hellip; ;&ndash;) (pour bien faire, il faudrait faire un benchmark).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty 4, Jackon 2... les mêmes mais en mieux...]]></title>
    <link href="https://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html"/>
    <updated>2014-03-17T08:43:12+01:00</updated>
    <id>https://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais</id>
    <content type="html"><![CDATA[<p><img src="http://3.bp.blogspot.com/-Vzol1CndcjY/Uxib17Rlf2I/AAAAAAAABQI/Qi4u0DWe2s4/s1600/resteasy_jolokia_metrics.png" alt="left-small" /></p>

<p>Pour faire suite à mon <a href="/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">article précédent</a> qui montrait comment il était possible de construire une <em>stack</em> légère basée sur Resteasy-Netty3, Jackson, <a href="http://www.jolokia.org/">Jolokia</a> et <a href="https://helloreverb.com/developers/swagger">Swagger</a>, cet article montrera comment il est possible de faire la même chose avec Resteasy-Netty4 et Jackson 2.</p>

<p>Même si les changements ne sont pas énormes, il y a quand même quelques variantes, et, histoire d'être exhaustif, cela permet de faire le tour complet&hellip; ;&ndash;)</p>

<p>En fait, les seuls points qui diffèrent, par rapport au code précédent, touchent :</p>

<ul>
<li>les dépendances,</li>
<li>l'intégration de Resteasy-netty4,</li>
<li>l'intégration du JacksonConfig (changement d'API coté Jackson),</li>
<li>le support de JodaTime dans Jackson 2,</li>
<li>et le support du CORS dans Resteasy-Netty4.</li>
</ul>


<p>C'est donc ces différents points qui seront abordés dans cet article.</p>

<p>Le code se trouve sur github sur la branche <a href="https://github.com/jetoile/resteasy-netty-sample/tree/netty4">netty4</a>.</p>

<!-- more -->


<h1>Les Dépendances</h1>

<p>Les dépendances utilisées sont les suivantes (au format gradle) :
<code>text
compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson2-provider', version:'3.0.6.Final'
compile group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-joda', version:'2.3.2'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}
</code></p>

<p>On peut y constater depuis la version précédente que netty est passé en version <strong>4.0.17.Final</strong> mais également c'est maintenant l'artefact <strong>resteasy-netty4</strong> qui est utilisé plutôt que <strong>resteasy-netty</strong>. De la même manière, c'est maintenant l'artefact <strong>resteasy-jackson2-provider</strong> plutôt que <strong>resteasy-jackson-provider</strong>.</p>

<p>En outre l'artefact <strong>jackson-datatype-joda</strong> a été ajouté (nous y reviendrons ultérieurement).</p>

<h1>Intégration de Resteasy-netty4</h1>

<p>Afin de remplacer Resteasy-netty 3 par Resteasy-Netty4, il suffit de modifier les dépendances et de supprimer le hack fait précédemment concernant le CORS (ie. la classe <code>RequestHandler</code>) qui est incompatible avec cette nouvelle version.</p>

<p>Une fois cela fait, le programme devrait être de nouveau fonctionnel sans avoir à modifier quoique ce soit (modulo Swagger-UI mais nous y reviendrons ultérieurement.)</p>

<h1>Intégration de Jackson 2</h1>

<p>Comme il a été vu précédemment, c'est maintenant la version de Jackson 2 qui est utilisé plutôt que la 1.</p>

<p>Aussi, il est nécessaire de modifier les packages de Jackson importés : cela n'est à faire que dans la classe <code>JacksonConfig</code>.</p>

<p>Certaines des API ayant également évoluées, la classe <code>JacksonConfig</code> devient :
```java
public class JacksonConfig implements ContextResolver<ObjectMapper> {</p>

<pre><code>private final ObjectMapper objectMapper;

public JacksonConfig() {
    objectMapper = new ObjectMapper();
    objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
}

@Override
public ObjectMapper getContext(Class&lt;?&gt; objectType) {
    return objectMapper;
}
</code></pre>

<p>}
```</p>

<h1>Support de JodaTime dans Jackson 2</h1>

<p>On a vu dans le paragraphe précédent comment il fallait modifier notre code pour utiliser Jackson 2 à la place de Jackson 1.</p>

<p>Cependant, lors d'un :
<code>bash
curl -XGET http://localhost:8081/sample/say/hello
</code></p>

<p>On obtient :
```javascript
{</p>

<pre><code>"message": "hello",
"time": {
    "era": 1,
    "dayOfMonth": 6,
    "dayOfWeek": 4,
    "dayOfYear": 65,
    "weekyear": 2014,
    "weekOfWeekyear": 10,
    "monthOfYear": 3,
    "yearOfEra": 2014,
    "yearOfCentury": 14,
    "centuryOfEra": 20,
    "millisOfSecond": 173,
    "millisOfDay": 53370173,
    "secondOfMinute": 30,
    "secondOfDay": 53370,
    "minuteOfHour": 49,
    "minuteOfDay": 889,
    "hourOfDay": 14,
    "year": 2014,
    "zone": {
        "fixed": false,
        "uncachedZone": {
            "cachable": true,
            "fixed": false,
            "id": "Europe/Paris"
        },
        "id": "Europe/Paris"
    },
    "millis": 1394113770173,
    "chronology": {
        "zone": {
            "fixed": false,
            "uncachedZone": {
                "cachable": true,
                "fixed": false,
                "id": "Europe/Paris"
            },
            "id": "Europe/Paris"
        }
    },
    "afterNow": false,
    "beforeNow": false,
    "equalNow": true
}
</code></pre>

<p>}
```</p>

<p>Pour corriger cela, il suffit d'importer la dépendance <strong>&lsquo;com.fasterxml.jackson.datatype&rsquo;, name: &lsquo;jackson-datatype-joda&rsquo;</strong> et d'ajouter à l'<code>objectMapper</code> le module <code>JodaModule</code> :
<code>java
objectMapper = new ObjectMapper();
objectMapper.registerModule(new JodaModule());
objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  
</code></p>

<p>Ainsi, on obtient bien :
```javascript
{</p>

<pre><code>"message": "hello",
"time": "2014-03-06T13:53:38.714Z"
</code></pre>

<p>}
```</p>

<h1>Support du CORS dans Resteasy-Netty4</h1>

<p>Précédemment, avec Resteast-netty 3, nous avions remarqué un problème de CORS avec Swagger-UI.
Pour en venir à bout, un <em>hack</em> avait été fait mais ce n'était pas très propre&hellip;</p>

<p>Malheureusement, Resteasy-netty4 n'offre pas, non plus, de manière simple pour surmonter ce problème. Heureusement, en fouillant un peu sur internet, un <a href="http://stackoverflow.com/questions/18857546/implement-cross-origin-resource-sharing-cors-on-resteasy-netty-server">article</a> propose de rajouter un <code>ChannelInboundHandler</code> au <em>pipeline</em> Netty.</p>

<p>Cependant, je n'ai pas trouvé de moyen simple de le faire mis à part la surcharge de la méthode&hellip;</p>

<p>Le code obtenu est donc le suivant :</p>

<p>La classe <code>ChannedInboundHandler</code> :
```java
public class CorsHeadersChannelHandler extends SimpleChannelInboundHandler<NettyHttpRequest> {</p>

<pre><code>protected void channelRead0(ChannelHandlerContext ctx, NettyHttpRequest request) throws Exception {
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");

    ctx.fireChannelRead(request);
}
</code></pre>

<p>}
```</p>

<p>La surcharge de la méthode <code>start()</code> pour ajouter le <em>handler</em> au pipeline Netty (désolé pour le nom&hellip;) :</p>

<p>```java
public class MyNettyJaxrsServer extends NettyJaxrsServer {</p>

<pre><code>private EventLoopGroup eventLoopGroup;
private EventLoopGroup eventExecutor;
private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
private int executorThreadCount = 16;
private SSLContext sslContext;
private int maxRequestSize = 1024 * 1024 * 10;
private int backlog = 128;

@Override
public void setSSLContext(SSLContext sslContext) { this.sslContext = sslContext; }

@Override
public void setIoWorkerCount(int ioWorkerCount) { this.ioWorkerCount = ioWorkerCount; }

@Override
public void setExecutorThreadCount(int executorThreadCount) { this.executorThreadCount =  executorThreadCount; }

@Override
public void setMaxRequestSize(int maxRequestSize) { this.maxRequestSize  = maxRequestSize; }

public void setBacklog(int backlog) { this.backlog = backlog; }

@Override
public void start() {
    eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);
    eventExecutor = new NioEventLoopGroup(executorThreadCount);
    deployment.start();
    final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
    // Configure the server.
    if (sslContext == null) {
        bootstrap.group(eventLoopGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline().addLast(new HttpRequestDecoder());
                        ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
                        ch.pipeline().addLast(new HttpResponseEncoder());
                        ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTP));
                        ch.pipeline().addLast(new CorsHeadersChannelHandler());
                        ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
                        ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
                    }
                })
                .option(ChannelOption.SO_BACKLOG, backlog)
                .childOption(ChannelOption.SO_KEEPALIVE, true);
    } else {
        final SSLEngine engine = sslContext.createSSLEngine();
        engine.setUseClientMode(false);
        bootstrap.group(eventLoopGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline().addFirst(new SslHandler(engine));
                        ch.pipeline().addLast(new HttpRequestDecoder());
                        ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
                        ch.pipeline().addLast(new HttpResponseEncoder());
                        ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTPS));
                        ch.pipeline().addLast(new CorsHeadersChannelHandler());
                        ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
                        ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
                    }
                })
                .option(ChannelOption.SO_BACKLOG, backlog)
                .childOption(ChannelOption.SO_KEEPALIVE, true);
    }
    bootstrap.bind(port).syncUninterruptibly();
}
</code></pre>

<p>}
```</p>

<p>On y observe le rajout du <em>handler</em> :
<code>java
ch.pipeline().addLast(new CorsHeadersChannelHandler());
</code></p>

<p>Enfin, l'initialisation du serveur Resteasy-netty :
<code>java
MyNettyJaxrsServer netty = new MyNettyJaxrsServer();
</code></p>

<h1>Conclusion</h1>

<p>On a vu, dans cet article, comment il était possible d'intégrer JAX-RS avec Netty 4 à l'aide de Resteasy tout en ayant une intégration de Jackson 2.</p>

<p>On a également montré qu'il était possible d'y intégrer très simplement Swagger et Jolokia.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty et bien plus encore... mode d'emploi...]]></title>
    <link href="https://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html"/>
    <updated>2014-03-10T08:03:49+01:00</updated>
    <id>https://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode</id>
    <content type="html"><![CDATA[<p><img src="http://1.bp.blogspot.com/-HYBTn5anFdE/Uxdv3cRgu_I/AAAAAAAABP4/gsCZjUIxDyQ/s1600/resteasy_jolokia_metrics.png" alt="left-small" /></p>

<p>L'informatique évolue constamment et c'est également le cas des architectures qui ont tendance à s'orienter de plus en plus vers l'utilisation de services REST. Ces services REST doivent, en outre, être de plus en plus véloces afin de pouvoir répondre à une charge de plus en plus forte (que ce soit d'un point de vue temps de réponse mais également d'un point de vue charge suportée). C'est dans ce contexte que des solutions comme <a href="http://restlet.org/">Restlet</a> ou <a href="http://restx.io/">RestX</a> (pour n'en citer que quelques-unes) ont vu le jour.</p>

<p>En effet, en plus d'offrir la possibilité de servir des services REST, elles s'appuient sur des framework dont la particularité est d'offrir des traitements non bloquant sur les entrées/sorties (NIO).</p>

<p>C'est dans ce contexte que cet article parlera principalement de Resteasy-Netty 3 (la version 3 a été utilisé en raison de contraintes techniques (connexion à <a href="http://cassandra.apache.org/">Apache Cassandra</a> dont le <a href="https://github.com/datastax/java-driver">driver</a> utilise Netty 3)).</p>

<p>Cependant, ce ne sera pas le seul protagoniste car, comme on verra par la suite, il est très simple à utiliser&hellip;</p>

<p>Le vrai sujet de cet article est, en fait, comment il a été possible d'ajouter d'autres framework comme Swagger ou Jolokia à Resteasy-Netty 3.</p>

<p>Cet article sera découpé en deux parties :</p>

<ul>
<li>Besoin et conception</li>
<li>Mise en oeuvre</li>
</ul>


<p>Le code se trouve sur Github <a href="https://github.com/jetoile/resteasy-netty-sample">ici</a>.</p>

<!-- more -->


<h1>Besoin et conception</h1>

<p>Le besoin était d'offrir un ensemble de services REST qui devait être suffisamment véloce pour répondre au besoin de performance en terme de charge mais également en terme de temps de réponse.</p>

<p>Venant du monde Java et plus précisément de Java EE, il aurait été pertinent de partir sur une solution classique à base de <a href="https://jcp.org/en/jsr/detail?id=311">JAX-RS</a> (<a href="https://jersey.java.net/">Jersey</a> ou <a href="http://www.jboss.org/resteasy">RestEasy</a>) hébergée par un <a href="http://tomcat.apache.org/">Tomcat</a> ou un <a href="http://www.eclipse.org/jetty/">Jetty</a>.</p>

<p>Cependant, une crainte était que le mode de fonctionnement des Servlets soit limitant concernant les entrées/sorties. Bien sûr, il était possible d'utiliser le connecteur NIO de Tomcat mais ce n'est pas cette solution qui a été retenue&hellip; ;&ndash;)</p>

<p>Suite à la lecture de l'excellent <a href="http://blog.xebia.fr/2011/11/09/java-nio-et-framework-web-haute-performance/">article</a> sur le retour d'expérience de <a href="https://twitter.com/slemesle">Séven</a> et de <a href="https://twitter.com/julienBuret">Julien</a> lors du challenge USI 2011, le choix a été fait de partir sur une solution basée sur <a href="http://netty.io/">Netty</a>.</p>

<p>Par contre, développer des services directement sur Netty était embêtant et risquait surtout de rebuter l'équipe de développement. De la même manière, introduire un nouveau framework disposant de ses propres API n'était pas préconisé (NDLR : les standards c'est bien ! ;&ndash;) ).</p>

<p>C'est pour cette raison qu'il était préférable de trouver une solution alliant à la fois les avantages de NIO (et si possible s'appuyant sur Netty) et de JAX-RS.</p>

<p>Ainsi, il a été décidé de partir sur Resteasy-Netty 3 qui semblait offrir le meilleur des deux mondes (je dis &ldquo;semblais&rdquo; car aucun comparatif en charge des différents protagonistes n'a été réalisé et les résultats obtenus ont été suffisamment satisfaisant pour n'avoir pas à pousser plus loin l'expérimentation).</p>

<p>L'un des autres avantages de n'avoir pas utiliser un conteneur de Servlet classique était qu'il permettait de rendre le livrable auto-porteur et légé (il aurait bien sûr été possible d'embarquer un Tomcat ou Jetty embedded ou de &ldquo;s'embeddé&rdquo; dans un Tomcat via le goal exec-war de Tomcat7-maven-plugin).</p>

<p>Bien sûr, l'application devait être administrable et supervisable.</p>

<p>Enfin, cerise sur le gateau, intégrer une solution comme <a href="https://helloreverb.com/developers/swagger">Swagger</a> pour documenter les API REST était un <em>&ldquo;nice to have&rdquo;</em>.</p>

<p>Pour notre cas d'exemple, le seul service exposé sera le classique service qui répète ce qu'on lui demande&hellip;</p>

<p>Il répondra donc à une requête de type GET du type :
<code>http://localhost:8081/sample/say/&lt;message&gt;</code></p>

<p>Du coté de la réponse, elle aura la forme suivante :
```javascript
{</p>

<pre><code>"message": &lt;message&gt;,
"time": "2014-03-05T10:55:39.835+01:00"
</code></pre>

<p>}
```</p>

<p>La date de la réponse sera ajoutée juste pour le &ldquo;fun&rdquo; ;&ndash;)</p>

<h1>Mise en oeuvre</h1>

<p>A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :
<code>text
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'
compile group: 'org.codehaus.jackson', name: 'jackson-core-asl', version:'1.9.13'
compile group: 'org.codehaus.jackson', name: 'jackson-mapper-asl', version:'1.9.13'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') { exclude(module: 'jsr305') }
</code></p>

<h2>Implémentation du service REST</h2>

<p>Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial&hellip; et la classe ci-dessous fait humblement l'affaire :</p>

<p>```java
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);

@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortDataSet(@PathParam("msg") String message) {
    DtoResponse response = new DtoResponse();
    try {
        response.setMessage(message);
        response.setTime(DateTime.now());
    } catch (Exception e) {
        log.error("internal error: {}", e);
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
    return Response.ok(response).build();
}
</code></pre>

<p>}
```</p>

<p>Du coté de l'objet retourné par la réponse au format JSON, Jackson intégré à Resteasy a été utilisé pour la partie marshalling/unmarshalling.</p>

<p>Coté gestion des dates, ce sera JodaTime (l'application tourne avec Java 7).</p>

<p>Du coup, un objet DTO a été écrit et annoté à l'aide d'annotations JAXB :</p>

<p>```java
@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
private DateTime time;

public DtoResponse() {}

public String getMessage() { return message;}

public void setMessage(String message) { this.message = message; }

public DateTime getTime() { return time; }

public void setTime(DateTime time) { this.time = time; }
</code></pre>

<p>}
```</p>

<h2>Mise en oeuvre de Resteasy-Netty 3</h2>

<p>Mettre en place Resteasy-Netty 3 est très simple, d'après la <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/pdf/resteasy-reference-guide-en-US.pdf">documnentation</a>, il suffit de faire :</p>

<p><code>java
public static void start(ResteasyDeployment deployment) throws Exception {
  netty = new NettyJaxrsServer();
  netty.setDeployment(deployment);
  netty.setPort(TestPortProvider.getPort());
  netty.setRootResourcePath("");
  netty.setSecurityDomain(null);
  netty.start();
 }
</code></p>

<p>et c'est donc ce que l'on va faire&hellip; ;&ndash;)</p>

<p><a href="http://commons.apache.org/proper/commons-configuration/">Apache commons-configuration</a> a été utilisé afin de déporter la configuration dans un fichier <em>properties</em>.</p>

<p>```java
public class Client {</p>

<pre><code>private final static Logger LOGGER = LoggerFactory.getLogger(Client.class);
private static final String CONF_PROPERTIES = "conf.properties";
private static Configuration config;

public static void main(String[] args) throws ConfigurationException, BootstrapException {
    try {
        config = new PropertiesConfiguration(CONF_PROPERTIES);
    } catch (ConfigurationException e) {
        throw new BootstrapException("bad config", e);
    }
    initServer();
}

private static void initServer() {
    SimpleService service = new SimpleService();
    ResteasyDeployment deployment = new ResteasyDeployment();

    int nettyPort = 8081;

    if (config != null) {
        deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));
        deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));
        deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));
        deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));

        nettyPort = config.getInt("netty.port", TestPortProvider.getPort());
    } else {
        LOGGER.warn("is going to use default netty config");
    }

    deployment.setResources(Arrays.&lt;Object&gt;asList(service));

    NettyJaxrsServer netty = new NettyJaxrsServer();
    netty.setDeployment(deployment);
    netty.setPort(nettyPort);
    netty.setRootResourcePath("");
    netty.setSecurityDomain(null);
    netty.start();
}    
</code></pre>

<p>}
```</p>

<p>On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <code>setResources()</code> sur l'instance de <code>ResteasyDeployment</code> fournit au serveur <strong>NettyJaxrs</strong> :</p>

<p><code>java
SimpleService service = new SimpleService();
ResteasyDeployment deployment = new ResteasyDeployment();
deployment.setResources(Arrays.&lt;Object&gt;asList(service));
NettyJaxrsServer netty = new NettyJaxrsServer();
netty.setDeployment(deployment);
...
netty.start();
</code></p>

<p>Et voilà! On dispose désormais d'un programme exécutable qui démarre un serveur REST basé sur Netty.</p>

<p>Plutôt simple non? ;&ndash;)</p>

<h2>Configuration de Jackson</h2>

<p>Avec le code précédent, si la commande suivante est exécutée :</p>

<p><code>bash
 curl -XGET  http://localhost:8081/sample/say/hello
</code></p>

<p>Le résultat suivant est obtenu :
```javascript
{</p>

<pre><code>"message": "hello",
"time": 1402560438128
</code></pre>

<p>}
```</p>

<p>Hum&hellip; la date n'est pas formatté comme il faut&hellip; pas glop&hellip; :&lsquo;(</p>

<p>En fait, il est possible de modifier la configuration de <a href="http://jackson.codehaus.org/">Jackson</a> et on trouve, dans la littérature, un moyen très simple de le faire en configurant l'<em>ObjectMapper</em> comme suit :
<code>java
objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);
</code></p>

<p>Bien sûr, le but n'étant pas de faire cette transformation manuellement à chaque fois, on préfère laisser Resteasy le gérer lui-même.</p>

<p>Ainsi, il existe <a href="http://stackoverflow.com/questions/19229341/changing-default-json-time-format-with-resteasy-3-x">deux autres</a> manières de faire :</p>

<ul>
<li>Le faire par annotation</li>
<li>Le faire par configuration dans le <code>web.xml</code></li>
</ul>


<p>Cependant, dans notre cas, nous ne disposons pas d'un conteneur de Servlet classique et il n'est donc pas possible de s'appuyer sur une configuration par web.xml. Pour le faire par annotation, j'avoue ne pas avoir testé mais je suis sceptique&hellip;</p>

<p>Du coup, il reste une possibilité qui est de déclarer un <code>JacksonConfig</code> et de demander à Resteasy-Netty de nous l'enregistrer en tant que <em>provider</em> (en gros de demander à Resteasy-Netty de faire manuellement ce qui est fait via le <code>web.xml</code>) :</p>

<p>```java
public class JacksonConfig implements ContextResolver<ObjectMapper> {</p>

<pre><code>private final ObjectMapper objectMapper;

public JacksonConfig() {
    objectMapper = new ObjectMapper();
    objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);
    objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);
}

@Override
public ObjectMapper getContext(Class&lt;?&gt; objectType) {
    return objectMapper;
}
</code></pre>

<p>}
```</p>

<p>Pour l'enregistrement, c'est très simple puisqu'il suffit d'ajouter la ligne suivante :
<code>deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig"));</code></p>

<p>Et voilà! C'est tout!</p>

<p>Encore une fois, simple et efficace et le résultat obtenu est bien celui escompté :
```javascript
{</p>

<pre><code>"message": "hello",
"time": "2014-06-12T10:06:54.553+02:00"
</code></pre>

<p>}
```</p>

<p>A noter que l'<em>ancienne</em> version de Jackson est utilisée ici car c'est celle qui est utilisé par défaut par Resteasy. Il aurait été possible de l'utiliser dans sa version plus récente mais j'avoue ne pas avoir fait l'exercice&hellip; (cf. <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/html/json.html#d4e1046">ici</a>)</p>

<h2>Intégration de Metrics</h2>

<p>Afin de permettre une mesure des temps d'invocation de différentes opérations, la librairie <a href="http://metrics.codahale.com/">Metrics</a> a été utilisée.</p>

<p>Pour plus d'information dessus, le sujet est très bien traité sur le blog de <a href="https://twitter.com/clescot">Charles</a> :</p>

<ul>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-les-bases/">Metrics : Les Bases</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-jee/">Metrics : Intégration Avec JEE</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-spring-et-guice/">Metrics : Intégration Avec Spring Et Guice</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-JDBC-logback-et-jersey/">Metrics : Intégration Avec JDBC, Logback Et Jersey</a></li>
</ul>


<p>Dans notre cas, bien sûr, pas de <em>Spring</em>, de <em>Guice</em> ou de <em>Servlet Listener</em>. Une simple variable de classe dans la classe portant la méthode <code>main()</code> suffit :
```java
public static MetricRegistry metricRegistry;</p>

<p>public static void main(String[] args) throws ConfigurationException, BootstrapException {
   &hellip;</p>

<pre><code>metricRegistry = new MetricRegistry();
final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();
reporter.start();
</code></pre>

<p>}
```</p>

<p>Concernant l'utilisation à proprement parler, cela se fait de cette manière (dans notre cas, utilisation du <strong>Timer</strong> qui représente un histogramme des durées et une mesure de la fréquence d’apparition) :
```java
@GET
@Path(&ldquo;/say/{msg}&rdquo;)
@Produces(MediaType.APPLICATION_JSON)
public Response getPortDataSet(@PathParam(&ldquo;msg&rdquo;) String message) {</p>

<pre><code>final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));
final Timer.Context context = timer.time();
try {
</code></pre>

<p>  &hellip;</p>

<pre><code>    return Response.ok(response).build();
} finally {
    if (context != null) context.stop();
}
</code></pre>

<p>}
```</p>

<p>Une fois l'application démarrée et après 1 ou 2 appels, l'ObjectName apparait dans la console JMX et il est alors possible de voir les différents résultats.</p>

<p><img src="http://1.bp.blogspot.com/-RMh6acQ8Qkc/UxdsRqymVkI/AAAAAAAABPk/r3rvWdgPNtg/s1600/metrics-hawtio.png" alt="medium" /></p>

<p>On constate encore une fois que la mise en place de Metrics n'a demandé aucun effort particulier.</p>

<h2>Intégration de Jolokia</h2>

<p>Une autre étape de notre périple consiste à activer Jolokia que j'ai déjà présenté dans un <a href="/2014/03/jolokia-le-piment-qui-vous-veut-du-bien.html">article précédent</a>.</p>

<p>Dans notre cas d'usage, cela sera fait de manière programmatique.</p>

<p>Pour ce faire, c'est encore une fois très simple et il suffit d'ajouter le code suivant dans notre classe principale :
```java
private static void initJolokiaServer() {</p>

<pre><code>try {
    JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());

    JolokiaServer jolokiaServer = new JolokiaServer(config, true);
    jolokiaServer.start();
} catch (Exception e) {
    LOGGER.error("unable to start jolokia server", e);
}
</code></pre>

<p>}
```</p>

<p>Concernant sa configuration, pour éviter d'avoir à aller chercher des properties et à repeupler une Map, le fichier par défaut (<code>default-jolokia-agent.properties</code>) a été copié (en renseignant certaines informations comme le user/password) dans le répertoire <code>src/main/resources</code> :
```text</p>

<h1>Configuration properties for the JVM jolokia-agent</h1>

<h1>Host address to bind to.</h1>

<h1>Default: localhost, determinated dynamically via InetAddress.getLocalHost()</h1>

<p>host=0.0.0.0</p>

<h1>Port to listen to</h1>

<p>port=7778</p>

<h1>Context path</h1>

<p>agentContext=/jolokia</p>

<h1>Backlog of request to keep when queue</h1>

<p>backlog=10</p>

<h1>Possible values:</h1>

<h1>* &ldquo;fixed&rdquo;  : Thread pool with at max nrThreads</h1>

<h1>* &ldquo;single&rdquo; : A single thread serves all requests (default)</h1>

<h1>* &ldquo;cached&rdquo; : A thread pool which reuses threads and creates threads on demand (unbounded)</h1>

<h1>executor=fixed</h1>

<h1>nrThreads=5</h1>

<h1>User and password for basic authentication</h1>

<p>user=jolokia
password=jolokia</p>

<h1>How many entroes to keep in the history</h1>

<p>historyMaxEntries=10</p>

<h1>Switch on debugging</h1>

<p>debug=false</p>

<h1>How many debug entries to keep on the server side which can be queried by JMX</h1>

<p>debugMaxEntries=100</p>

<h1>Maximum traversal depth for serialization of complex objects.</h1>

<p>maxDepth=15</p>

<h1>Maximum size of collections returned during serialization.</h1>

<p>maxCollectionSize=1000</p>

<h1>Maximum number of objects returned by serialization</h1>

<p>maxObjects=0
```</p>

<p>Un petit coup de (le user jolokia et le mot de passe jolokia ont été positionné dans le fichier <em>properties</em>) :
<code>bash
curl -XGET -u jolokia:jolokia http://localhost:7778/jolokia/version
</code></p>

<p>nous permet bien d'obtenir la réponse attendue :
```javascript
{</p>

<pre><code>"timestamp": 1394036344,
"status": 200,
"request": {
    "type": "version"
},
"value": {
    "protocol": "7.0",
    "agent": "1.1.2",
    "info": {}
}
</code></pre>

<p>}
```</p>

<p>A noter que les user/password ont été positionné car cela permet une connexion via <a href="http://hawt.io/">Hawt.io</a>.</p>

<h2>Intégration de Swagger</h2>

<p><a href="https://helloreverb.com/developers/swagger">Swagger</a> offre une manière très simple de documenter une API REST. En effet, en s'appuyant sur des annotations à mettre dans la classe de service, elle permet d'offrir une interface d'écrivant les API.</p>

<p><img src="http://4.bp.blogspot.com/-92lPQm1F_DM/UxdsgUK3bDI/AAAAAAAABPs/yWh6QRHKkFc/s1600/swagger.png" alt="medium" /></p>

<p>Pour le mettre en place, il suffit donc de rajouter les annotations adéquates à notre classe <code>SimpleService</code> :</p>

<p>```java
@Api(value = &ldquo;/sample&rdquo;, description = &ldquo;the sample api&rdquo;)
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);

@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
@ApiOperation(value = "repeat the word",
        notes = "response the word",
        response = DtoResponse.class)
@ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})
public Response getPortDataSet(@PathParam("msg") String message) {

    final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));
    final Timer.Context context = timer.time();
    try {
        DtoResponse response = new DtoResponse();
        try {
            response.setMessage(message);
            response.setTime(DateTime.now());
        } catch (Exception e) {
            log.error("internal error: {}", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(response).build();
    } finally {
        if (context != null) context.stop();
    }
}
</code></pre>

<p>}
```</p>

<p>Reste maintenant à ajouter Swagger à notre <code>main()</code> que l'on doit faire programmatiquement faute d'être dans un conteneur de Servlet standard&hellip;</p>

<p>Pour ce faire, il est nécessaire d'instancier un objet <code>BeanConfig</code> qui contient la configuration de Swagger mais surtout l'adresse et le port du serveur sur lequel tourne le service ainsi que le package où se trouve ce dernier. Ces informations sont renseignées, dans notre cas, dans notre fichier de configuration et positionnées programmatiquement dans notre <code>BeanConfig</code>.</p>

<p>Enfin, il faut trouver le moyen de faire le pendant de ce qui est déclaré sur <a href="https://github.com/wordnik/swagger-core/wiki/Servlet-Quickstart">cette page</a>&hellip; bien sûr, le tout sans Servlet&hellip; ouch&hellip; :&lsquo;( En fouillant un peu, on tombe rapidement sur le <a href="https://github.com/wordnik/swagger-core/wiki/Java-CXF-Quickstart">quickstart swagger/cxf</a> où les <em>providers</em> sont positionnés : il suffit de faire pareil avec Resteasy-Netty ;&ndash;)</p>

<p>```java
private static void initSwagger(ResteasyDeployment deployment) {</p>

<pre><code>BeanConfig swaggerConfig = new BeanConfig();
swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));
swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));
swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));
swaggerConfig.setScan(true);
swaggerConfig.setResourcePackage("fr.jetoile.sample.service");

deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig",
        "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",
        "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));
deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));
deployment.setSecurityEnabled(false);
</code></pre>

<p>}
```</p>

<p>Et voilà, ça fonctionne!</p>

<p>En exécutant la commande :
<code>bash
curl -XGET http://localhost:8081/api-docs/sample
</code></p>

<p>On obtient bien le JSON escompté :
```javascript
{</p>

<pre><code>"apiVersion": "1.0.0",
"swaggerVersion": "1.2",
"basePath": "http://localhost:8081",
"resourcePath": "/sample",
"apis": [
    {
        "path": "/sample/say/{msg}",
        "operations": [
            {
                "method": "GET",
                "summary": "repeat the word",
                "notes": "response the word",
                "type": "DtoResponse",
                "nickname": "getPortDataSet",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "msg",
                        "required": true,
                        "allowMultiple": false,
                        "type": "string",
                        "paramType": "path"
                    }
                ],
                "responseMessages": [
                    {
                        "code": 500,
                        "message": "Internal server error"
                    }
                ]
            }
        ]
    }
],
"models": {
    "DtoResponse": {
        "id": "DtoResponse",
        "properties": {
            "message": {
                "type": "string"
            },
            "time": {
                "$ref": "DateTime"
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Mais (car il y a un mais&hellip;) en utilisant <a href="https://github.com/wordnik/swagger-ui">Swagger-UI</a> (qu'il faut déployer sur un apache/nginx/tomcat ou autre), il peut arriver que cela ne fonctionne pas&hellip; )(ie. que Swagger-IU n'arrive pas à fetcher les ressources de notre service REST). Cela arrivera d'ailleurs sûrement si notre application est déployée sur une machine différente de celle où est déployée Swagger-UI (pour rappel, on ne dispose pas, ici, d'un conteneur de Servlet et exposer des pages statiques n'est pas l'objectif de notre petite application). Le problème vient de notre cher ami, le <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>&hellip; Du coup, il devient nécessaire d'ajouter des <em>headers</em> dans le requête de réponse.</p>

<p>Et c'est là que la tâche se gâte&hellip; En effet, pas de possibilité de positionner un filtre comme avec les Servlets. Pas non plus de possibilité de modifier la configuration de Resteasy-Netty 3 pour lui demander d'ajouter des headers (si cela existe, je n'ai pas trouvé)&hellip;</p>

<p>Du coup, la seule solution a été de patcher sauvagement notre ami Resteasy-Netty 3 en surchargeant une de ses classes pour y ajouter les bons headers&hellip; Pas très classe mais bon&hellip;</p>

<p>Pour ce faire, il suffit de créer dans notre application le package <code>org.jboss.resteasy.plugins.server.netty</code> et d'y copier la classe <code>RequestHandler</code> en y ajoutant les headers utiles :
```java
package org.jboss.resteasy.plugins.server.netty;</p>

<p>import org.jboss.netty.channel.*;
import org.jboss.netty.channel.ChannelHandler.Sharable;
import org.jboss.netty.handler.codec.frame.TooLongFrameException;
import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponseStatus;
import org.jboss.resteasy.logging.Logger;
import org.jboss.resteasy.spi.Failure;</p>

<p>import static org.jboss.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;</p>

<p>/<em>*
 * TODO : hack to add CORS into header
 *
 * {@link org.jboss.netty.channel.SimpleChannelUpstreamHandler} which handles the requests and dispatch them.
 *
 * This class is {@link org.jboss.netty.channel.ChannelHandler.Sharable}.
 *
 * @author The Netty Project
 * @author Andy Taylor (<a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#97;&#110;&#x64;&#x79;&#x2e;&#116;&#x61;&#x79;&#108;&#x6f;&#114;&#64;&#106;&#x62;&#111;&#115;&#x73;&#x2e;&#111;&#114;&#x67;">&#x61;&#110;&#x64;&#x79;&#46;&#x74;&#97;&#121;&#x6c;&#111;&#114;&#x40;&#x6a;&#98;&#x6f;&#x73;&#x73;&#46;&#x6f;&#114;&#x67;</a>)
 * @author Trustin Lee
 * @author Norman Maurer
 * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
 </em>/
@Sharable
public class RequestHandler extends SimpleChannelUpstreamHandler {</p>

<pre><code>protected final RequestDispatcher dispatcher;
private final static Logger logger = Logger.getLogger(org.jboss.resteasy.plugins.server.netty.RequestHandler.class);

public RequestHandler(RequestDispatcher dispatcher) { this.dispatcher = dispatcher; }

@Override
public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
    if (e.getMessage() instanceof NettyHttpRequest) {
        NettyHttpRequest request = (NettyHttpRequest) e.getMessage();

        //HACK ICI!!!
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");
        //FIN DU HACK

        if (request.is100ContinueExpected()) { send100Continue(e); }

        NettyHttpResponse response = request.getResponse();
        try {
            dispatcher.service(request, response, true);
        } catch (Failure e1) {
            response.reset();
            response.setStatus(e1.getErrorCode());
            return;
        } catch (Exception ex) {
            response.reset();
            response.setStatus(500);
            logger.error("Unexpected", ex);
            return;
        }

        // Write the response.
        ChannelFuture future = e.getChannel().write(response);

        // Close the non-keep-alive connection after the write operation is done.
        if (!request.isKeepAlive()) { future.addListener(ChannelFutureListener.CLOSE); }
    }
}

private void send100Continue(MessageEvent e) {
    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
    e.getChannel().write(response);
}

@Override
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
    // handle the case of to big requests.
    if (e.getCause() instanceof TooLongFrameException) {
        DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE);
        e.getChannel().write(response).addListener(ChannelFutureListener.CLOSE);
    } else {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}
</code></pre>

<p>}
```</p>

<p>Voilà, après ce petit tour de passe passe, notre swagger-UI fonctionne comme un charme ;&ndash;)</p>

<p>Au final, (presque?) simple non? ;&ndash;)</p>

<h2>Branchement des plugins Maven Appassembler et Assembly</h2>

<p>Afin de générer une application utilisable <em>out of the box</em>, le plugin maven <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/">appassembler</a> a été utilisé. Pour ceux qui ne saurait pas ce que c'est, je les invite à regarder soit la documentation officielle soit un article que j'avais fait <a href="/2012/02/petit-focus-sur-2-plugins-maven.html">précédemment</a> (#autopromo ;&ndash;) ).</p>

<p>Ainsi, ici, le goal <code>generate-daemons</code> du plugin a été utilisé :
```xml
<plugin></p>

<pre><code>&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
&lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;
&lt;executions&gt;

    &lt;execution&gt;
        &lt;id&gt;spring-integ-reader&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;generate-daemons&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
            &lt;target&gt;${project.build.directory}/appassembler-jsw&lt;/target&gt;

            &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt;

            &lt;daemons&gt;
                &lt;daemon&gt;
                    &lt;id&gt;${project.name}&lt;/id&gt;
                    &lt;mainClass&gt;fr.jetoile.sample.Client&lt;/mainClass&gt;
                    &lt;commandLineArguments&gt;
                    &lt;/commandLineArguments&gt;
                    &lt;platforms&gt;
                        &lt;platform&gt;jsw&lt;/platform&gt;
                    &lt;/platforms&gt;
                    &lt;generatorConfigurations&gt;
                        &lt;generatorConfiguration&gt;
                            &lt;generator&gt;jsw&lt;/generator&gt;
                            &lt;includes&gt;
                                &lt;include&gt;linux-x86-64&lt;/include&gt;
                                &lt;include&gt;linux-x86-32&lt;/include&gt;
                            &lt;/includes&gt;
                            &lt;configuration&gt;

                                &lt;property&gt;
                                    &lt;name&gt;configuration.directory.in.classpath.first&lt;/name&gt;
                                    &lt;value&gt;conf&lt;/value&gt;
                                &lt;/property&gt;

                            &lt;/configuration&gt;
                        &lt;/generatorConfiguration&gt;
                    &lt;/generatorConfigurations&gt;
                    &lt;jvmSettings&gt;
                        &lt;initialMemorySize&gt;256M&lt;/initialMemorySize&gt;
                        &lt;maxMemorySize&gt;2048M&lt;/maxMemorySize&gt;
                        &lt;systemProperties&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.port=8199&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.authenticate=false
                            &lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.ssl=false&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.local.only=false
                            &lt;/systemProperty&gt;
                        &lt;/systemProperties&gt;
                        &lt;extraArguments&gt;
                            &lt;extraArgument&gt;-Xdebug&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;
                                -Xrunjdwp:transport=dt_socket,address=9999,server=y,suspend=n
                            &lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-server&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+UnlockCommercialFeatures&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+FlightRecorder&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/extraArgument&gt;
                        &lt;/extraArguments&gt;
                    &lt;/jvmSettings&gt;
                &lt;/daemon&gt;
            &lt;/daemons&gt;
        &lt;/configuration&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;

&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<p>En outre, ce plugin ne créant pas le répertoire <code>logs</code> et ne positionnant pas les droits d'exécution sur les fichiers du répertoire bin, le plugin Maven <a href="https://maven.apache.org/plugins/maven-assembly-plugin/">assembly</a> a été utilisé conjointement :
```xml
<plugin></p>

<pre><code>&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
    &lt;descriptors&gt;
        &lt;descriptor&gt;src/main/assembly/descriptor.xml&lt;/descriptor&gt;
    &lt;/descriptors&gt;
    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;

&lt;/configuration&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;assembly&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;single&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
</code></pre>

<p></plugin>
```</p>

<p>Avec le descripteur simple suivant :
```xml
&lt;?xml version=&ldquo;1.0&rdquo;?>
&lt;assembly xmlns=&ldquo;<a href="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2">http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2</a>&rdquo;</p>

<pre><code>      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"&gt;
&lt;id&gt;reader&lt;/id&gt;
&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
&lt;formats&gt;&lt;format&gt;tar.gz&lt;/format&gt;&lt;/formats&gt;

&lt;fileSets&gt;
    &lt;fileSet&gt;
        &lt;directory&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}&lt;/directory&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;excludes&gt;
            &lt;exclude&gt;bin/${project.name}&lt;/exclude&gt;
            &lt;exclude&gt;bin/wrapper-linux-x86-32&lt;/exclude&gt;
            &lt;exclude&gt;bin/wrapper-linux-x86-64&lt;/exclude&gt;
        &lt;/excludes&gt;
        &lt;fileMode&gt;640&lt;/fileMode&gt;
        &lt;directoryMode&gt;750&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
    &lt;fileSet&gt;
        &lt;directory&gt;src/main/assembly&lt;/directory&gt;
        &lt;outputDirectory&gt;/logs&lt;/outputDirectory&gt;
        &lt;excludes&gt;&lt;exclude&gt;*&lt;/exclude&gt;&lt;/excludes&gt;
    &lt;/fileSet&gt;
&lt;/fileSets&gt;

&lt;files&gt;
    &lt;file&gt;
        &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/${project.name}&lt;/source&gt;
        &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;
        &lt;fileMode&gt;750&lt;/fileMode&gt;
    &lt;/file&gt;
    &lt;file&gt;
        &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/wrapper-linux-x86-64&lt;/source&gt;
        &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;
        &lt;fileMode&gt;750&lt;/fileMode&gt;
    &lt;/file&gt;
&lt;/files&gt;
</code></pre>

<p></assembly>
```</p>

<p>Ainsi, l'exécution de la commande suivante :
<code>bash
mvn package
</code></p>

<p>génère un livrable exploitable directement après sa décompression.</p>

<p>Lors d'un <code>mvn release</code>, il sera également automatiquement uploadé sur le <em>Repository Manager</em>.</p>

<h1>Conclusion</h1>

<p>En conclusion, je n'ai pas grand chose à ajouter si ce n'est que j'ai trouvé Resteasy-Netty simple à utiliser et qu'il a été aisé d'y ajouter tout ce qui était nécessaire à notre besoin.</p>

<p>Et le tout de manière simple et efficace pour une solution véloce et légère!</p>

<p>Pour faire encore plus simple, <a href="http://projectlombok.org/">Lombok</a> aurait pu être utilisé mais, de mémoire, en test de Java 8, une incompatibilité est apparue&hellip; à creuser donc pour cette partie&hellip; ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jolokia : le piment qui vous veut du bien ]]></title>
    <link href="https://blog.jetoile.fr/2014/03/jolokia-le-piment-qui-vous-veut-du-bien.html"/>
    <updated>2014-03-04T00:30:40+01:00</updated>
    <id>https://blog.jetoile.fr/2014/03/jolokia-le-piment-qui-vous-veut-du-bien</id>
    <content type="html"><![CDATA[<p><img src="http://3.bp.blogspot.com/-6Xm2grUWMtI/UxTNAazymaI/AAAAAAAABPE/dXJ7fti_FLA/s1600/jolokia.png" alt="left-small" /></p>

<p> Dans des articles précédents, je m'étais déjà exprimé sur le fait que je trouvais qu'il était important de monitorer son application (qu'il s'agisse d'une application web, d'un batch ou d'une application standalone) (cf. <a href="/2010/05/jmx-ou-comment-administrer-et.html">ici</a>). J'avais même creusé un peu la spécification JMX (cf. <a href="/2010/10/jmx-pour-les-nuls-introduction.html">là</a>).</p>

<p>Pour faire suite à ce besoin, je vais, dans cet article, faire un focus sur un outils que j'ai découvert récemment (merci Romain ;&ndash;) ) mais qui existe depuis un moment (la version 1.0.0 est apparue en octobre 2011 sur le repo Maven central et le premier commit apparaissant sur Github date de Juillet 2010) : cet outils est <strong>Jolokia</strong>.</p>

<p>Comme à mon habitude, pour présenter cet outils, je m'appuierai sur la document officielle dans sa version courante, à savoir la 1.2.0.</p>

<p>Cependant, je ne ferai pas un plagiat exhaustif de la documentation qui est très complète (et surtout, je n'ai pas envie de me traduire les 92 pages de cette dernière&hellip; ;&ndash;) ) mais j'essaierai de faire un focus sur les points que je trouve les plus intéressants (à savoir les principes ainsi que le mode agent JVM (cf. plus tard) ).</p>

<!-- more -->


<h1>Principes et concepts</h1>

<h2>Jolokia&hellip; pour quoi faire?</h2>

<p>Dans le monde Java, il existe un standard pour faire de l'administration/supervision : il s'agit de JMX (Java Management eXtension). Il est inclus depuis le JDK 1.5.</p>

<p>Cependant, JMX est malheureusement un des parents pauvres de Java : souvent méconnu ou mal utilisé, il est aussi très orienté vers le monde Java (et cela, même s'il existe la <a href="https://jcp.org/en/jsr/detail?id=160">JSR 160 &ndash; Java Management eXtension Remote API</a>).</p>

<p>C'est la raison d'être de Jolokia qui offre une approche agent (qui cohabite avec la JSR 160) tout en offrant une interopérabilité via HTTP au moyen de JSON pour la partie <em>payload</em>. Cela lui permet d'exposer les couches d'administration/supervision JMX des applicatifs Java via une protocole interopérable de tous.</p>

<h2>Architecture</h2>

<p>L'architecture de Jolokia diffère de celle de la JSR 160. En effet, la JSR 160 permet à un client d'invoquer de manière transparente un MBean qu'il soit dans un <strong>MBeanServer</strong> local ou distant.</p>

<p>Cependant, même si cela est intéressant, c'est également une approche dangereuse puisque cela masque la partie transport qui peut entraîner un <em>overhead</em> mais cela expose aussi le modèle des objets qui transitent.</p>

<p>En effet, il existe une adhérence implicite au protocole RMI (qui est d'ailleurs le protocole par défaut des connecteurs JMX) pour la partie mécanisme de sérialisation des objets. C'est ce dernier point qui pose un problème d'interopérabilité avec tout programme extérieur à une JVM.</p>

<p>Ainsi, Jolokia, en offrant une approche différente via HTTP/JSon, permet de réconcilier ces différents mondes. Pour ce faire, il propose 2 modes :</p>

<ul>
<li>un mode agent,</li>
<li>un mode proxy.</li>
</ul>


<h3>Le mode agent</h3>

<p>Dans ce mode, Jolokia se présente comme un agent qui expose un protocole au format JSON via HTTP et qui permet de servir de bridge vers les MBeans JMX locaux. Cela se passe donc en dehors du scope de la JSR 160.</p>

<p>Ainsi, il est possible d'exporter ce protocole de différentes manières dont la plus courante est via un conteneur de Servlet (qu'il soit légé ou pas).</p>

<p>Cependant, il existe d'autres possibilités comme des agents spécialisés qui peuvent utiliser un service HTTP OSGI ou qui peuvent embarquer un serveur Jetty.</p>

<p>Il est à noter que l'agent utilise le serveur HTTP embarqué dans toutes les JVM 6 d'Oracle et qu'il peut donc s'attacher dynamiquement à toutes les processus Java.</p>

<p><img src="http://2.bp.blogspot.com/-TnigS1cXxaI/UxTNwI9jtzI/AAAAAAAABPM/q0rHjKSMmq4/s1600/jolokia-agent.png" alt="medium" /></p>

<h3>Le mode proxy</h3>

<p>Ce mode peut être utilisé lorsqu'il n'est pas possible de déployer un agent Jolokia sur la plateforme cible. Pour ce mode, le seul prérequis est l'accès au serveur cible via une connexion à travers de la JSR 160. Cela peut être le cas si l'application ne peut pas être modifiée ou si l'application expose déjà ses MBeans via la JSR 160.</p>

<p>Ce mode nécessite un conteneur de Servlet dans lequel sera déployée l'application web <code>jolokia.war</code> qui a, à sa charge, de &ldquo;<em>proxyfier</em>&rdquo; et qui, par défaut, supporte à la fois le mode agent et le mode proxy.</p>

<p>Ainsi, dans ce mode, un client enverra une requête Jolokia avec une section supplémentaire spécifiant la cible qui doit être atteinte. Toutes les information de routage est donc contenu dans la requête elle-même de manière à ce que le proxy puisse agir sans configuration spécifique.</p>

<p><img src="http://2.bp.blogspot.com/-wf_ReDc9AKk/UxTN2msI-BI/AAAAAAAABPU/neUmwiePEs0/s1600/jolokia-proxy.png" alt="medium" /></p>

<h2>Les agents</h2>

<p>Jolokia propose une approche orientée agent qui doit être, soit déployé sur la cible (<strong>mode agent</strong>), soit sur un serveur proxy (<strong>mode proxy</strong>).</p>

<p>Pour ces deux modes, il existe 4 types d'agent :</p>

<ul>
<li><strong>WAR agent</strong> : cet agent est packagé sous forme de WAR.</li>
<li><strong>OSGI agent</strong> : cet agent au format OSGI (bundle) vient sous 2 formes : un agent minimal qui dispose d'une dépendance sur un OSGI <em>HTTService</em> qui doit être démarré et un agent &ldquo;tout en un&rdquo; qui embarque une implémentation de <em>HTTPService</em>.</li>
<li><strong>Mule agent</strong> : cet agent s'intègre à Mule et fourni une API d'adminitration/supervision dans lequel un agent jolokia dédié est intégré. Il inclut un serveur Jetty embarqué.</li>
<li><strong>JVM agent</strong> : Depuis la version 1.6 du JDK d'Oracle, la JVM embarque un serveur HTTP légé. En utilisant ce dernier, Jolokia expose ses fonctionnalité. Cependant, cet agent peut être un peu lent en raison du fait que le serveur HTTP embarqué dans la JVM ne soit pas optimisé pour les performances.</li>
</ul>


<p>Les deux types d'agent qui seront un peu plus détaillés dans cet article sont les types WAR agent et JVM agent.</p>

<h2>WAR agent</h2>

<p>Le type WAR agent se présente comme une application web standard (au format WAR). La configuration se fait alors via l'élément <code>init-param</code> du web.xml.</p>

<p>Un autre moyen consiste à utiliser le context (dans le cas de Tomcat) qui permet de déporter la configuration en dehors du WAR. Ainsi, par exemple avec Tomcat, avec le context de l'application web se trouvant dans <code>$TOMCAT_HOME/conf/Catalina/localhost</code>, on peut avoir par exemple :</p>

<p><code>xml
&lt;Context&gt;
&lt;Parameter name="maxDepth" value="1"&gt;
&lt;/Context&gt;
</code></p>

<p>Au niveau paramétrage, je vous laisse aller voir la document officielle ;&ndash;).</p>

<p>Du point de vue sécurité, il est possible de bénéficier de la sécurité du conteneur de Servlet via le <code>web.xml</code>.</p>

<p>Une autre manière de faire consite à intégrer Jolokia comme Servlet dans son application web. Pour ce faire, il suffit de tirer la bonne dépendance et de préciser le Servlet de Jolokia de manière classique via les éléments <code>servlet</code> et <code>servlet-mapping</code> du <code>web.xml</code> de l'application.</p>

<p><code>xml
&lt;dependency&gt;
  &lt;groupId&gt;org.jolokia&lt;/groupId&gt;
  &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;
  &lt;version&gt;${jolokia.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></p>

<p>Comme il est possible de déployer de multiples WAR agents Jolokia sur une même JVM, puisque des MBeans spécifiques Jolokia sont déployé dans le <strong>PlatformMBeansServer</strong>, il faut préciser la valeur de l'élément mbeanQualifier dans les paramètres d'init.</p>

<h2>JVM agent</h2>

<p>Ce type d'agent Jolokia que j'ai testé IRL est très simple à utiliser et permet d'attacher un agent à une JVM afin qu'elle expose à la mode REST ses couches d'administration et de supervision.</p>

<p>Il est possible de :</p>

<ul>
<li><em>bootstrapper</em> l'agent JVM au démarrage de la JVM en lui fournissant le jar adéquate ainsi que les options qui vont bien :</li>
</ul>


<p><code>bash
java -javaagent:agent.jar=port=7777,host=localhost
</code></p>

<ul>
<li><em>bootstrapper</em> l'agent JVM en lui fournissant directement une fichier de configuration :</li>
</ul>


<p><code>bash
java -javaagent:agent.jar=config=$FICHIER_CONFIG_JOLOKIA
</code></p>

<p>où un exemple de fichier de configuration peut être trouvé dans jar de l'agent (au nom de <code>default-jolokia-agent.properties</code>).</p>

<p>où <code>agent.jar</code> peut être téléchargé de <a href="http://www.jolokia.org/download.html">http://www.jolokia.org/download.html</a> (artifact : <strong>JVM-Agent</strong>).</p>

<p>De la même manière, un agent Jolokia peut être attaché à une processus Java à la demande (un peu comme lorsque JConsole se connecte à un processus local). Pour ce faire, il suffit de lancer la commande suivante :</p>

<p><code>bash
java -jar agent.jar start &lt;PID&gt;
</code></p>

<h2>Jolokia et la sécurité</h2>

<p>Jolokia permet de configurer la sécurité assez finement. N'ayant pas tester, je ne m'attarderai pas trop sur le sujet.</p>

<p>Cependant, il est intéressant de noter que Jolokia permet de filtrer l'accès des clients par IP mais offre également un accès plus fin pour l'accès aux MBeans (<code>read</code>/<code>write</code>/<code>exec</code>/<code>list</code>/<code>search</code>/<code>version</code>).</p>

<p>Point également important, Jolokia supporte la spécification W3C pour le Cross-Origin Resource Sharing (CORS) qui permet d'utiliser des outils comme <a href="http://hawt.io/">Hawt.io</a> (mais nous y reviendront plus tard&hellip;).</p>

<h2>Le protocole Jolokia</h2>

<p>Jolokia utilise un protocole JSON sur HTTP. La communication est basé sur le paradigme requête/réponse où chaque requête fournit une réponse.</p>

<p>Les requêtes peuvent être envoyées de deux manières :</p>

<ul>
<li>soit avec une requête HTTP GET (dans ce cas, les paramètres sont encodés dans l'URL),</li>
<li>soit avec une requête HTTP POST où la requête est incluse dans le corps de la requête au format JSON.</li>
</ul>


<p>Les réponses retournées par l'agent sont, quant à elles, toujours envoyées en JSON.</p>

<p>De plus, les requêtes au format HTTP GET peuvent prendre deux formes :</p>

<ul>
<li>utiliser un format REST (ex : <a href="http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage">http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</a>)</li>
<li>utiliser un format où la requête est donnée par un paramètre <strong>p=</strong> (ex : <a href="http://localhost:8080/jolokia?p=/read/jboss.jmx:alias=jmx%2Frmi%2FRMIAdaptor/State">http://localhost:8080/jolokia?p=/read/jboss.jmx:alias=jmx%2Frmi%2FRMIAdaptor/State</a>)</li>
</ul>


<p>A noter que Jolokia utilise le caractère &ldquo;!&rdquo; comme caractère d'échappement.</p>

<p>Plutôt que de longs discours, quelques exemples issus de la documentation aideront à comprendre&hellip;</p>

<p>Pour lire la valeur du MBean dont l'objectName est <strong>java.lang:type=Memory/HeapMemoryUsage</strong>, les requêtes suivantes sont équivalentes :</p>

<p><code>bash
curl -XGET "http://127.0.0.1:8778/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used"
</code></p>

<br/>


<p><code>bash
curl -XGET "http://127.0.0.1:8778/jolokia/?p=/read/java.lang:type=Memory/HeapMemoryUsage/used"
</code></p>

<br/>


<p><code>bash
curl -XPOST -d '{"type" : "read", "mbean" : "java.lang:type=Memory", "attribute" : "HeapMemoryUsage", "path" : "used" }' http://127.0.0.1:8778/jolokia/
</code>
soit en format lisible :</p>

<p>```javascript
{</p>

<pre><code>"type": "read",
"mbean": "java.lang:type=Memory",
"attribute": "HeapMemoryUsage",
"path": "used"
</code></pre>

<p>}
```
La réponse obtenue est de la forme :</p>

<p>```javascript
{</p>

<pre><code>"timestamp": 1393865787,
"status": 200,
"request": {
    "mbean": "java.lang:type=Memory",
    "path": "used",
    "attribute": "HeapMemoryUsage",
    "type": "read"
},
"value": 162037504
</code></pre>

<p>}
```
Pour montrer le coté structuré de la réponse, à une requête de type :</p>

<p><code>bash
http://127.0.0.1:8778/jolokia/read/java.lang:type=Memory
</code>
on obtient :
```javascript
{</p>

<pre><code>"timestamp": 1393866039,
"status": 200,
"request": {
    "mbean": "java.lang:type=Memory",
    "type": "read"
},
"value": {
    "Verbose": false,
    "ObjectPendingFinalizationCount": 0,
    "NonHeapMemoryUsage": {
        "max": 329252864,
        "committed": 218951680,
        "init": 19136512,
        "used": 139774968
    },
    "HeapMemoryUsage": {
        "max": 518979584,
        "committed": 518979584,
        "init": 134217728,
        "used": 179096552
    },
    "ObjectName": {
        "objectName": "java.lang:type=Memory"
    }
}
</code></pre>

<p>}
```</p>

<p> Concernant les opérations possibles (dans l'exemple précédent, il s'agissait d'une lecture), il existe :</p>

<ul>
<li><strong>read</strong> avec le format GET suivant :</li>
</ul>


<p><code>&lt;base-url&gt;/read/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;inner path&gt;</code></p>

<p>(ex : <a href="http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used">http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used</a>)</p>

<ul>
<li><strong>write</strong> avec le foramt GET suivant :</li>
</ul>


<p><code>&lt;base url&gt;/write/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;value&gt;/&lt;inner path&gt;</code></p>

<p>(ex : <a href="http://localhost:8080/jolokia/write/java.lang:type=Memory/Verbose/true">http://localhost:8080/jolokia/write/java.lang:type=Memory/Verbose/true</a>)</p>

<ul>
<li><strong>exec</strong> avec le format GET suivant :</li>
</ul>


<p><code>&lt;base url&gt;/exec/&lt;mbean name&gt;/&lt;operation name&gt;/&lt;arg1&gt;/&lt;arg2&gt;/....</code></p>

<p>(ex : <a href="http://localhost:8080/jolokia/exec/java.lang:type=Memory/gc">http://localhost:8080/jolokia/exec/java.lang:type=Memory/gc</a>)</p>

<ul>
<li><strong>search</strong> avec le format GET suivant :</li>
</ul>


<p><code>&lt;base-url&gt;/search/&lt;pattern&gt;</code></p>

<p>(ex : <a href="http://localhost:8080/jolokia/search/*:j2eeType=J2EEServer,*">http://localhost:8080/jolokia/search/*:j2eeType=J2EEServer,*</a>)</p>

<ul>
<li><strong>list</strong> avec le format GET suivant :</li>
</ul>


<p><code>&lt;base-url&gt;/list/&lt;inner path&gt;</code></p>

<p>(ex : <a href="http://localhost:8080/jolokia/list/java.lang/type=Memory/attr">http://localhost:8080/jolokia/list/java.lang/type=Memory/attr</a>)</p>

<ul>
<li><strong>version</strong> qui permet d'avoir la version du protocole utilisé ainsi qu'un ensemble de paramètre avec le format GET suivant :</li>
</ul>


<p><code>&lt;base-url&gt;/version</code></p>

<p>(ex : <a href="http://localhost:8080/jolokia/version">http://localhost:8080/jolokia/version</a>)</p>

<p>Enfin, si le mode proxy est utilisé, seul le mode POST peut être utilisé et doit, alors, avoir le format suivant :</p>

<p>```javascript
{</p>

<pre><code>"type" : "read",
"mbean" : "java.lang:type=Memory",
"attribute" : "HeapMemoryUsage",
"target" : { 
     "url" : "service:jmx:rmi:///jndi/rmi://targethost:9999/jmxrmi",
     "user" : "jolokia",
     "password" : "s!cr!t"
} 
</code></pre>

<p>}
```</p>

<p>Je ne rentrerai pas plus en détaille sur cette partie là qui est beaucoup plus exhaustive dans la documentation officielle (comment les objets sont sérialisés, le mapping complet des MXBeans, la découverte des agents ou les différentes versions du protocole Jolokia &ndash; actuellement la version 7.1 &ndash; ) et si cela est nécessaire, je conseille d'aller directement se référer à la documentation.</p>

<h1>Autres features</h1>

<p>En plus des fonctionnalités présentées précédemment, Jolokia offre les fonctionnalités suivantes :</p>

<ul>
<li>exposition de son propre MBean,</li>
<li>différents clients (javascript, plugin cubism, java, Jmx4Perl),</li>
<li>une API de programmation pour exposer sont MBeanServer,</li>
<li>un JSonMBean,</li>
<li>une integration Spring,</li>
</ul>


<p>Pour l'intégration avec Spring, cela se fait via l'import Maven suivant :
<code>xml
&lt;dependency&gt;
  &lt;groupId&gt;org.jolokia&lt;/groupId&gt;
  &lt;artifactId&gt;jolokia-spring&lt;/artifactId&gt;
  &lt;version&gt;1.2.0&lt;/version&gt;
&lt;/dependency&gt;  
</code></p>

<p>et le contexte Spring suivant :</p>

<p>```xml
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:jolokia="http://www.jolokia.org/jolokia-spring/schema/config"
   xsi:schemaLocation="
   http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.jolokia.org/jolokia-spring/schema/config  http://www.jolokia.org/jolokia-spring/schema/config/jolokia-config.xsd
   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;
</code></pre>

<p>  &lt;jolokia:agent lookupConfig=&ldquo;true&rdquo; systemPropertiesMode=&ldquo;never&rdquo;></p>

<pre><code>    &lt;jolokia:config
            autoStart="true"
            host="${jolokia.host}"
            port="${jolokia.port}"
            user="${jolokia.user}"
            password="${jolokia.password}"/&gt;
&lt;/jolokia:agent&gt;

&lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
    &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
&lt;/bean&gt;
</code></pre>

<p></beans>
```</p>

<h1>Conclusion</h1>

<p>Dans cet article, une présentation succincte a été faite de Jolokia. J'espère qu'elle vous aura plu ;&ndash;)&hellip;</p>

<p>Il s'agit d'un outils simple, pluggable très facilement à n'importe quelle application (une intégration à Cassandra s'est fait en 5 minutes).</p>

<p>Cette présentation était surtout axé concepts et principes afin de bien comprendre ce que peut apporter cet outils.</p>

<p>Cependant, un des gros avantage de Jolokia est un point qui n'a pas été abordé dans cet article : il s'agit de son intégration à <a href="http://hawt.io/">Hawt.io</a>. Cet outils ayant déjà fait le sujet d'article sur le blog de Zenika, je vous invite à y jeter un oeil :</p>

<ul>
<li><a href="http://blog.zenika.com/index.php?post/2014/01/07/HawtIO-la-console-web-polyvalente">HawtIO, la console web polyvalente</a></li>
<li><a href="http://blog.zenika.com/index.php?post/2014/01/14/HawtIO-ecrire-un-plugin">HawtIO, écrire un plugin</a></li>
</ul>


<p>Ainsi, en production, disposer du combo Hawt.io + Jolokia offre, à mon sens, d'énormes avantages comme, par exemple, accèder aux informations de n'importe quelle application qui, généralement, n'est pas accessible pour des raisons de sécurité (cf. <a href="/2010/05/jmx-et-firewall.html">ici</a>).</p>

<p>Bien sûr, il existe d'autres solutions comme l'utilisation de <a href="http://www.crashub.org/">CraSH</a> mais exposer ses MBeans via JSON over HTTP est tellement simple et peut surtout être exploité simplement par les équipes de production ;&ndash;) .</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li>Site de Jolokia : <a href="http://www.jolokia.org/">http://www.jolokia.org/</a></li>
<li>Site de documentation de Jolokia : <a href="http://www.jolokia.org/reference/html/index.html">http://www.jolokia.org/reference/html/index.html</a></li>
<li>Site d'Hawt.io : <a href="http://hawt.io/">http://hawt.io/</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
