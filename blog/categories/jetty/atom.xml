<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jetty | Jetoile]]></title>
  <link href="https://blog.jetoile.fr/blog/categories/jetty/atom.xml" rel="self"/>
  <link href="https://blog.jetoile.fr/"/>
  <updated>2018-10-28T18:01:31+01:00</updated>
  <id>https://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Démarrer une webapp en mode embedded avec Maven]]></title>
    <link href="https://blog.jetoile.fr/2013/03/demarrer-une-webapp-en-mode-embedded.html"/>
    <updated>2013-03-06T15:26:29+01:00</updated>
    <id>https://blog.jetoile.fr/2013/03/demarrer-une-webapp-en-mode-embedded</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-2c2Ie9Tla54/UTaEjXrNaiI/AAAAAAAAA20/MWhTcyyJvMg/s1600/image.png" alt="left-small" /></p>

<p>La mouvance actuelle dit que tout projet qui se veut un minimum industrialisé doit pouvoir détecter les anomalies au plus tôt. Pour ce faire, il est dit qu'il doit disposer de tests, qu'ils soient unitaire, d'intégration, fonctionnel ou d'acceptance.</p>

<p> Pour adresser le problème des tests d'intégration, il est souvent utile de démarrer l'application cible de manière embedded.</p>

<p>Cette article montrera comment il est possible de faire pour un contexte donné.</p>

<p>En outre, vu que ce blog me sert également d'aide mémoire, cela me donnera une excuse pour marquer noir sur blanc des informations que je peine toujours à retrouver&hellip; ;&ndash;)</p>

<p>Pour les habitués de ce blog (oui, je sais, cela fait un moment que je n'ai rien écrit&hellip; ;&ndash;) , le plan sera toujours le même : dans un premier temps, le contexte sera décrit puis des ébauches de solutions seront proposées jusqu'à tendre vers celle qui a été retenue.</p>

<!-- more -->


<h1>Contexte</h1>

<p>Le contexte du projet est le suivant : l'application cible est composée de deux applications web qui suivent le même cycle de vie et qui sont dépendantes l'une de l'autre (au sens <em>runtime</em> en non compilation).</p>

<p>En effet, elle dispose d'une application web proposant un site web écrit en Java et utilisant un framework de type struts 2 (et qui sera nommée par la suite &ldquo;<em>application webapp</em>&rdquo;) et une application web servant un ensemble de ressources en proposant une interface REST (nommée par la suite &ldquo;<em>application rest</em>&rdquo;).</p>

<p>L'application webapp nécessitera, en plus de son rendu de page dynamique, des ressources offertes par l'application REST (appel ajax, &hellip;).</p>

<p><em>ndlr</em> : je sais que la mouvance actuelle dit que les framework web java sont le &ldquo;mal&rdquo; pour faire du web et qu'il est préférable de tendre vers une solution type framework javascript coté client. Cependant, dans notre cas, une forte contrainte SEO faisait qu'il était nécessaire de &ldquo;conserver&rdquo; un rendu dynamique des pages cotés serveur.</p>

<p>D'un point de vu technique, le projet s'appuiera sur Maven 3 (encore lui&hellip; ;&ndash;) ), et sur des technologies standards à base de Servlets (2.5+), de JSP, de JAX-RS, &hellip; enfin, de techno standard capable de tourner sur un conteneur de Servlet classique type Tomcat 6 ou 7.</p>

<p>L'arborescence du projet est la suivante :</p>

<p><img src="http://4.bp.blogspot.com/-1N_8WSbysb8/UTZKH2xIekI/AAAAAAAAA2c/itx2Qxav2CA/s1600/tree01.png" alt="center" /></p>

<p>Avant de commencer à rentrer dans le vif du sujet, il est important de remarquer qu'il existe de nombreux plugins Maven permettant de démarrer de manière <em>embedded</em> un artifact maven de type war via les goals adéquates (<code>mvn tomcat7:run</code>, <code>mvn jetty:run</code>, &hellip;). Cependant, pour rappel, notre objectif est de démarrer de manière conjointe nos deux applications web.</p>

<p>En outre, le but ultime (pour ceux qui ne l'auraient pas encore deviné ;&ndash;) ) étant d'exécuter de manière boite noire des tests d'integration/d'acceptance, le démarrage devra se faire dans un module Maven frère de nos deux modules webapp et restful.</p>

<p>L'arborescence attendue du projet est donc la suivante :</p>

<p><img src="http://2.bp.blogspot.com/-QYIOY3HI__s/UTZKLlWV1bI/AAAAAAAAA2k/HXtJ0QDW6BE/s1600/tree02.png" alt="center" /></p>

<p>Enfin, pour finir le tour de notre petit cahier des charges, le livrable généré ne devra pas dépendre de profils Maven particuliés (le but étant, bien sûr, de ne pas avoir un livrable dépendant d'une configuration donnée).</p>

<p>Cependant, afin d'avoir la main, lors des tests d'intégration/d'acceptance, sur le jeu de données qui sera injecté dans le système à tester, il devra être possible de modifier &ldquo;à chaud&rdquo; certaines configurations. Pour ce faire, une surcharge des fichiers de configuration des applications devra être faite.</p>

<p><em>ndlr</em> : l'application ayant un certain existant, elle ne dispose pas de fonctionnalités comme les <strong>Profile</strong> Spring ou l'utilisation de variables systèmes : toutes les propriétés de configuration se trouvent donc dans des fichiers properties ou dans des fichiers de contexte Spring.</p>

<h1>Le plugin tomcat 7</h1>

<p><img src="http://2.bp.blogspot.com/-vO0vp3GQG_4/UTbgJFKXJ5I/AAAAAAAAA3E/Z8EtqhZbPJU/s1600/tomcat.gif" alt="center" /></p>

<h2>Mise en oeuvre</h2>

<p>Le plugin <a href="http://tomcat.apache.org/maven-plugin-2.0/index.html">Maven Tomcat 7</a> est un plugin que j'apprécie pour sa simplicité d'utilisation et ses différentes <em>features</em> (merci <a href="https://twitter.com/olamy">@olamy</a> pour me l'avoir fait découvrir/redécouvrir ;&ndash;) ) et c'est donc naturellement que c'est le premier qui a été testé. De plus, la cible de déploiement étant Tomcat, cela tombait bien ;&ndash;) .</p>

<p>Pour répondre à notre cas d'usage, le plugin Tomcat 7 propose le goal <code>run-war-only</code> qui permet, via la configuration <code>&lt;warDirectory&gt;</code>, de préciser un répertoire où se trouve l'application web.</p>

<p>En effet, le war étant généré dans un module maven frère de celui où doit être démarré le Tomcat <em>embedded</em>, il doit, préalablement, être récupéré (en évitant, bien évidemment, les chemins relatifs). En outre, pour rappel, la nécessité de surcharger la configuration de certains fichiers à fait tendre la solution vers les étapes suivantes (opération spécifique à une application web) :</p>

<ul>
<li>récupération du war dans le repository maven,</li>
<li>dézippage du war dans le répertoire <code>target/webapp</code>,</li>
<li>copie des fichiers de configuration permettant la surcharge des fichiers de configuration de l'application dans le répertoire <code>target/webapp/WEB-INF/classes</code>,</li>
<li>un appel au goal <code>run-war-only</code> du plugin Tomcat en précisant l'emplacement du war éclaté à charger.</li>
</ul>


<p>Cela a été fait via la configuration Maven suivante :</p>

<p>```xml
<plugin>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <id>unzip-webapp</id>
            <phase>compile</phase>
            <goals>
                <goal>unpack</goal>
            </goals>
            <configuration>
                <artifactItems>
                     <artifactItem>
                         <groupId>${project.groupId}</groupId>
                         <artifactId>webapp</artifactId>
                         <version>${project.version}</version>
                         <type>war</type>
                     </artifactItem>
                </artifactItems>
 
                <outputDirectory>${project.build.directory}/webapp</outputDirectory>
                <overWriteSnapshots>true</overWriteSnapshots>
            </configuration>
        </execution>
    </executions>
</plugin>
 </p>

<!--use to copy test resources into webapp classpath-->


<p><plugin>
    <artifactId>maven-resources-plugin</artifactId>
    <executions>
        <execution>
            <id>copy-webapp-resources</id>
            <phase>process-test-resources</phase>
            <goals>
                <goal>copy-resources</goal>
            </goals>
            <configuration>
                <outputDirectory>${project.build.directory}/webapp/WEB-INF/classes</outputDirectory>
                <resources>
      <resource>
          <directory>src/test/resources/webapp</directory>
          <filtering>true</filtering>
      </resource>
                </resources>
            </configuration>
        </execution>
    </executions>
</plugin>
 
<plugin>
    <groupId>org.apache.tomcat.maven</groupId>
    <artifactId>tomcat7-maven-plugin</artifactId>
    <version>2.0</version>
 
    <executions>
        <execution>
            <id>tomcat-war-exec</id>
            <goals>
                <goal>run-war-only</goal>
            </goals>
            <phase>pre-integration-test</phase>
            <configuration>
                <warDirectory>${project.build.directory}/webapp/</warDirectory>
                <fork>true</fork>
                <ignorePackaging>true</ignorePackaging>
                <contextFile>src/test/resources/webapp/context.xml</contextFile>
            </configuration>
        </execution>
        <execution>
            <id>start-tomcat</id>
            <phase>pre-integration-test</phase>
            <goals>
                <goal>run</goal>
            </goals>
            <configuration>
            </configuration>
        </execution>
        <execution>
            <id>stop-tomcat</id>
            <phase>post-integration-test</phase>
            <goals>
                <goal>shutdown</goal>
            </goals>
        </execution>
    </executions>
 
    <configuration>
        <port>9090</port>
        <path>/</path>
    </configuration>
 
    <dependencies>
        <!-- les artéfacts des jars à mettre dans le classpath du serveur Tomcat tels que les drivers de connexion-->
    </dependencies>
</plugin>
```</p>

<p>Il est intéressant de noter plusieurs points :</p>

<ul>
<li>la précision du fichier <code>context.xml</code> qui contient, entre autre, le <strong>contextName</strong> de l'application web mais surtout, dans notre cas, la déclaration de notre base de données dans l'annuaire JNDI,</li>
<li>le rajout éventuel de jar dans le classpath serveur,</li>
<li>le fait de lancer le serveur en phase de <code>pre-integration-test</code> et de l'éteindre en phase de <code>post-integration-test</code>.</li>
</ul>


<p>Cependant, pour ceux qui auraient suivi, je rappelle que l'application cible était composée de deux applications web : webapp et restful&hellip;</p>

<p>Malheureusement, sauf erreur de ma part, le plugin Maven Tomcat7 ne propose pas de déployer deux applications web simultanément lorsque ces dernières sont éclatées dans un répertoire.</p>

<h2>Conclusion</h2>

<p>On a vu dans ce paragraphe comment il était possible de déployer simplement, via le plugin Maven Tomcat 7, une application web de manière <em>embedded</em> dans un processus Maven.</p>

<p>Malheureusement, le goal qui nous intéressait ne permettant pas démarrer deux applications web simultanément, il n'a pas pu répondre à notre besoin.</p>

<h1>Le plugin Jetty</h1>

<p><img src="http://3.bp.blogspot.com/-9CX6HuFGgPA/UTbgPT2O6gI/AAAAAAAAA3M/JQ_lOt2NnsI/s1600/jetty_logo.png" alt="center" /></p>

<h2>Mise en oeuvre</h2>

<p>Dans cette deuxième tentative, c'est le <a href="http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin">plugin Maven Jetty</a> qui a été utilisé.</p>

<p>Même s'il n'est pas la cible de déploiement, nos applications étant assez standards, il a été acté que le conteneur n'aurait que peu d'impacts sur les tests d'intégration/d'acceptance.</p>

<p>La philosophie mise en oeuvre est similaire à celle choisie avec le plugin Maven Tomcat 7, à savoir :</p>

<ul>
<li>récupération du war dans le repository maven,</li>
<li>dézippage du war dans le répertoire <code>target/webapp</code>,</li>
<li>copie des fichiers de configuration dans le répertoire <code>target/webapp/WEB-INF/classes</code>,</li>
<li>appel du bon goal du plugin Jetty en précisant l'emplacement du war éclaté à charger.</li>
</ul>


<p>Bien sûr, ici, le goal est propre au plugin Jetty, à savoir <code>run-exploded</code> :</p>

<p><code>xml
&lt;plugin&gt;
    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
    &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;7.6.9.v20130131&lt;/version&gt;    
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;jetty-war-exec&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;run-exploded&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;pre-integration-test&lt;/phase&gt;
            &lt;configuration&gt;
                &lt;daemon&gt;true&lt;/daemon&gt;            
                &lt;jvmArgs&gt;&lt;!-- eventuellement les options jvm--&gt;&lt;/jvmArgs&gt;
                &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;
                &lt;jettyConfig&gt;${basedir}/src/test/resources/jetty.xml&lt;/jettyConfig&gt;
                &lt;webAppConfig&gt;
                   &lt;contextPath&gt;/webapp&lt;/contextPath&gt;
                   &lt;jettyEnvXml&gt;${basedir}/src/test/resources/webapp/jetty-webapp-context.xml&lt;/jettyEnvXml&gt;
                &lt;/webAppConfig&gt;
                &lt;war&gt;${project.build.directory}/webapp&lt;/war&gt;
                &lt;connectors&gt;
                   &lt;connector implementation="org.eclipse.jetty.server.nio.SelectChannelConnector"&gt;
                       &lt;host&gt;127.0.0.1&lt;/host&gt;
                       &lt;port&gt;9090&lt;/port&gt;
                   &lt;/connector&gt;
                &lt;/connectors&gt;
 
                &lt;contextHandlers&gt;
                   &lt;contextHandler implementation="org.eclipse.jetty.webapp.WebAppContext"&gt;
                       &lt;war&gt;${project.build.directory}/restful&lt;/war&gt;
                       &lt;contextPath&gt;/restful&lt;/contextPath&gt;
                   &lt;/contextHandler&gt;
                &lt;/contextHandlers&gt;
 
            &lt;/configuration&gt;
        &lt;/execution&gt;
 
        &lt;execution&gt;
            &lt;id&gt;stop-jetty&lt;/id&gt;
            &lt;phase&gt;post-integration-test&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;stop&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;stopPort&gt;9999&lt;/stopPort&gt;
                &lt;stopKey&gt;stopKey&lt;/stopKey&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
 
    &lt;/executions&gt;
    &lt;dependencies&gt;
        &lt;!-- eventuellement les jar à ajouter au classpath du conteneur de servlet--&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</code></p>

<p>On peut remarquer que la configuration du plugin Jetty est beaucoup plus verbeuse que celle du plugin Tomcat avec, notamment, la nécessité de préciser :</p>

<ul>
<li>un fichier de configuration jetty permettant, dans notre cas, de préciser que Jetty doit démarrer son module pour charger l'annuaire JNDI (fichier <code>jetty.xml</code>),</li>
<li>la déclaration d'un connecteur pour pouvoir préciser le port de lancement du conteneur de Servlet,</li>
<li>le fichier <code>jetty-webapp-context.xml</code> pendant du <code>context.xml</code> de Tomcat,</li>
<li>l'obligation de rajouter l'élément <code>contextHandlers</code> pour pouvoir déclarer la deuxième application web à démarrer.</li>
</ul>


<p>A noter qu'il est également possible de déclarer les deux applications web via des <strong>contextHandler</strong>, permettant d'avoir une configuration plus symétrique :</p>

<p><code>xml
&lt;plugin&gt;
    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
    &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;7.6.9.v20130131&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;jetty-war-exec&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;start&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;pre-integration-test&lt;/phase&gt;
            &lt;configuration&gt;
                &lt;daemon&gt;true&lt;/daemon&gt;
                &lt;jvmArgs&gt;&lt;/jvmArgs&gt;
                &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;
                &lt;jettyConfig&gt;${basedir}/src/test/resources/jetty.xml&lt;/jettyConfig&gt;
                &lt;webAppConfig&gt;
                     &lt;jettyEnvXml&gt;${basedir}/src/test/resources/webapp/jetty-webapp-context.xml&lt;/jettyEnvXml&gt;
                &lt;/webAppConfig&gt;
                &lt;connectors&gt;
                     &lt;connector implementation="org.eclipse.jetty.server.nio.SelectChannelConnector"&gt;
                         &lt;host&gt;127.0.0.1&lt;/host&gt;
                         &lt;port&gt;9090&lt;/port&gt;
                     &lt;/connector&gt;
                &lt;/connectors&gt;
 
                &lt;contextHandlers&gt;
                     &lt;contextHandler implementation="org.eclipse.jetty.webapp.WebAppContext"&gt;
                         &lt;war&gt;${project.build.directory}/webapp&lt;/war&gt;
                         &lt;contextPath&gt;/webapp&lt;/contextPath&gt;
                     &lt;/contextHandler&gt;
 
                     &lt;contextHandler implementation="org.eclipse.jetty.webapp.WebAppContext"&gt;
                         &lt;war&gt;${project.build.directory}/restful&lt;/war&gt;
                         &lt;contextPath&gt;/restful&lt;/contextPath&gt;
                     &lt;/contextHandler&gt;
                &lt;/contextHandlers&gt;
 
            &lt;/configuration&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
            &lt;id&gt;stop-jetty&lt;/id&gt;
            &lt;phase&gt;post-integration-test&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;stop&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;stopPort&gt;9999&lt;/stopPort&gt;
                &lt;stopKey&gt;stopKey&lt;/stopKey&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
 
 
    &lt;/executions&gt;
    &lt;dependencies&gt;
         
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</code></p>

<p>A titre informatif, le fichier <code>jetty.xml</code> permettant de charger le module JNDI est le suivant :</p>

<p><code>xml
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure.dtd"&gt;
 
 
&lt;Configure id="Server" class="org.eclipse.jetty.server.Server"&gt;
    &lt;Array id="plusConfig" type="java.lang.String"&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.WebInfConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.WebXmlConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.MetaInfConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.FragmentConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.plus.webapp.EnvConfiguration&lt;/Item&gt;                  &lt;!-- add for JNDI --&gt;
        &lt;Item&gt;org.eclipse.jetty.plus.webapp.PlusConfiguration&lt;/Item&gt;                 &lt;!-- add for JNDI --&gt;
        &lt;Item&gt;org.eclipse.jetty.annotations.AnnotationConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.JettyWebXmlConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.TagLibConfiguration&lt;/Item&gt;
    &lt;/Array&gt;
 
    &lt;Call name="setAttribute"&gt;
        &lt;Arg&gt;org.eclipse.jetty.webapp.configuration&lt;/Arg&gt;
        &lt;Arg&gt;
            &lt;Ref id="plusConfig"/&gt;
        &lt;/Arg&gt;
    &lt;/Call&gt;
&lt;/Configure&gt;
</code></p>

<p>et le fichier <code>jetty-webapp-context.xml</code> pendant du fichier <code>context.xml</code> de Tomcat est :</p>

<p><code>xml
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure.dtd"&gt;
 
&lt;Configure class="org.eclipse.jetty.webapp.WebAppContext"&gt;
 
&lt;New id="myoracle" class="org.eclipse.jetty.plus.jndi.Resource"&gt;
    &lt;Arg&gt;jdbc/myoracle&lt;/Arg&gt;
    &lt;Arg&gt;
        &lt;New class="org.apache.commons.dbcp.BasicDataSource"&gt;
            &lt;Set name="driverClassName"&gt;driver.jdbc.class&lt;/Set&gt;
            &lt;Set name="url"&gt;jdbc:url_connection&lt;/Set&gt;
            &lt;Set name="username"&gt;login&lt;/Set&gt;
            &lt;Set name="password"&gt;password&lt;/Set&gt;
        &lt;/New&gt;
    &lt;/Arg&gt;
&lt;/New&gt;
 
&lt;/Configure&gt;
</code></p>

<h2>Conclusion</h2>

<p>On a pu constater que l'utilisation du plugin Maven Jetty a parfaitement répondu à notre petit cahier des charges. C'est vrai que cela peut sembler un peu poussif mais cela est surtout dû au fonctionnement même de Jetty.</p>

<p>Enfin, il est à noter que la configuration présentée dans le paragraphe précédent ne fonctionne pas pour la version 6 du plugin (connecteurs et packages différents, &hellip;) et qu'elle a été testé avec la version 7.6.9.v20130131. Normalement, cela devrait fonctionner avec la version 8 mais n'ayant pas testé, je ne pourrais pas le certifier&hellip;</p>

<h1>Conclusion</h1>

<p>En conclusion, cet article avait pour objectif de présenter quelques-unes des façons de démarrer de manière <em>embedded</em> des applications web dans des conteneurs de Servlet légés au sein d'un processus Maven.</p>

<p>Cela peut, notamment, être utile pour initialiser une ou plusieurs applications au sein du processus de tests pour, par exemple, exécuter de manière automatisée des tests d'intégration ou d'acceptance, chose qui est de plus en plus courante au sein de nos usine d'intégration continue.</p>

<p>Bien sûr, il existe de nombreuses autres solutions (par exemple, <a href="http://arquillian.org/">Arquillian</a>) mais aussi d'autres approches (le choix retenu ici a été celui de la boite noire) qui ont toutes leurs avantages et leurs inconvénients par rapport à un besoin donné.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetty, Maven et JMX]]></title>
    <link href="https://blog.jetoile.fr/2011/09/jetty-maven-et-jmx.html"/>
    <updated>2011-09-26T23:19:12+02:00</updated>
    <id>https://blog.jetoile.fr/2011/09/jetty-maven-et-jmx</id>
    <content type="html"><![CDATA[<p><img src="http://2.bp.blogspot.com/-bGP4Fnvfp1s/TnEtqz-UNkI/AAAAAAAAAa4/KBXNM8QXHKc/s1600/logoArticle.png" alt="left-small" /></p>

<p>Vous avez peut être remarqué que ces derniers temps, j'étais très Maven et JMX. Cet article ne déroge pas à la règle puisque je vais parler de&hellip; Maven et de JMX.</p>

<p>Enfin pour être plus précis, je vais montrer comment il est facilement possible de déployer une application web dans le conteneur embarqué Jetty via Maven en activant la couche JMX afin de pouvoir tester de manière intégrée cette couche.</p>

<p>Pour ce faire, je présenterai dans un premier temps le contexte, puis comment cela peut être mise en œuvre.
Bien sûr, cet article montre comment j'ai fait mais il ne représente pas la seule manière de faire&hellip; ;&ndash;). En outre, il ne présente rien de novateur mais je me suis dit que cela pouvait toujours être utile afin d'éviter de faire perdre du temps à d'autres personnes.</p>

<!-- more -->


<h1>Contexte</h1>

<p>Ce paragraphe présente mes motivations pour avoir eu un besoin d'une utilisation d'un Jetty embedded à Maven en activant la couche JMX car, c'est vrai, ce n'est pas un besoin très courant et qu'il peut même sembler, au premier abord, paraitre un peu stupide (en effet, utiliser un Jetty embedded répond plutôt à un besoin de poste de développement ou au pire (et je dis bien au pire!!) à un pseudo TU qui n'est, du coup, pas un TU&hellip; (ndlr : enfin, encore une fois, je diverge&hellip; ;&ndash;) )).</p>

<p>En fait, pour les besoins d'une démonstration, je voulais juste présenter une petite application web qui remontait des métriques via JMX. N'ayant pas foncièrement envie d'avoir à décompresser un Jetty sur mon poste, je me suis dit qu'un Jetty embedded dans Maven suffisait largement à ma petite démo.</p>

<p>En outre, cela offrait également la possibilité à n'importe qui de rejouer la démo sans avoir à installer localement un conteneur de Servlets et sans à avoir à modifier le paramétrage de ce dernier pour activer la couche JMX de la JVM.</p>

<p>L'application web utilisée pour ce petit POC est assez basique puisqu'il ne s'agit que d'un simple Servlet redirigeant vers une simple jsp.</p>

<p>Ce Servlet incrémentera un compteur exposé en JMX afin de fournir cette métrique basique à la couche de supervision.</p>

<p>Spring 3 sera également utilisé pour lier le tout&hellip;</p>

<p>En fait, si vous me demandez pourquoi j'ai branché Spring pour une application ausi simple, c'est, en fait, que JMX n'était pas le seul composant que je voulais montrer pendant la petite démonstration&hellip;</p>

<p>Si vous avez l'esprit chagrin et que vous me re-demandez pourquoi je n'ai pas utilisé un aspect, c'est que l'aspect était justement l'autre aspect de ma démo ;&ndash;).</p>

<h1>Mise en oeuvre</h1>

<p>Pour ce paragraphe de mise en œuvre, je présenterai successivement :</p>

<ul>
<li>Le code de l'application web utilisé.</li>
<li>La configuration Maven utilisée permettant de démarrer l'application web dans un Jetty embedded.</li>
<li>Les subtilités de la configuration à effectuer pour ajouter la couche JMX.</li>
</ul>


<h1>Application web cible</h1>

<p>Comme annoncé précédemment, notre application web cible se compose de :</p>

<ul>
<li>un Servlet,</li>
<li>une page JSP,</li>
<li>un POJO utilisé par Spring pour la partie MBean (Spring aura, à sa charge, sa <em>proxification</em> en MBean Standard et son enregistrement au sein du MBean Server),</li>
<li>un fichier de configuration web.xml,</li>
<li>et un fichier de contexte Spring.</li>
</ul>


<p>Il est à noter qu'elle utilisera la spécification 2.5 des Servlets afin de permettre, dans les parties suivantes, de montrer la différence de configuration qu'il existe entre Jetty 6 et 7.</p>

<h2>Code du Servlet</h2>

<p><code>java
public class SimpleServlet extends HttpServlet {
    private static Logger LOGGER = LoggerFactory.getLogger(SimpleServlet.class);
 
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ApplicationContext beanFactory = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext());
        SimpleCounter jmxTestBean = beanFactory.getBean("simpleCounter", SimpleCounter.class);
        jmxTestBean.inc();
 
        req.setAttribute("nbInvocation", jmxTestBean.getNbGet());
 
        RequestDispatcher dispatcher = req.getRequestDispatcher("WEB-INF/jsp/simpleDisplay.jsp");
        if (dispatcher != null) {
            dispatcher.forward(req, resp);
        } else {
            LOGGER.warn("unable to get the request dispatcher");
        }
    }
}
</code></p>

<p>On constate que le Servlet est basique. Il n'y a donc rien à dire dessus si ce n'est la récupération du POJO <em>proxifié</em> par Spring pour incrémenter un compteur qui sera exposé en JMX.</p>

<h2>Code du POJO utilisé comme MBean Standard</h2>

<p><code>java
public class SimpleCounter {
    private int nbGet = 0;
 
    public void inc() {
        this.nbGet++;
    }
 
    public void setNbGet(int nbGet) {
        this.nbGet = nbGet;
    }
 
    public int getNbGet() {
        return nbGet;
    }
}
</code></p>

<p>Concernant le POJO, rien de spécial non plus à remarquer. Juste à noter que les setter et getter sont nécessaires afin de rendre l'attribut <code>nbGet</code> accessible en lecture/écriture par la couche cliente JMX.</p>

<h2>Code de la jsp</h2>

<p><code>xml
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;simple display&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;This is a simple display&lt;/h1&gt;
        Has been invoked: ${nbInvocation} times
    &lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>Rien de particulier non plus à dire sur la jsp&hellip;</p>

<h2>Code du web.xml</h2>

<p><code>xml
&lt;web-app version="2.5" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemalocation="http://java.sun.com/xml/ns/javaee
 http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
 &lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;
 &lt;/context-param&gt;
 &lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
 &lt;/listener&gt;
 
 &lt;servlet&gt;
  &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;fr.jetoile.demo.servlet.SimpleServlet&lt;/servlet-class&gt;
  &lt;init-param&gt;
   &lt;param-name&gt;sleep-time-in-seconds&lt;/param-name&gt;
   &lt;param-value&gt;10&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
 &lt;/servlet&gt;
 
 &lt;servlet-mapping&gt;
  &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/sample&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></p>

<p>Le fichier descripteur <code>web.xml</code> est classique donc rien de nouveau sur les tropiques ;&ndash;). Comme dit plus haut, c'est ici la version 2.5 des servlets qui est utilisée afin de permettre un choix plus important de conteneurs de Servlets.</p>

<h2>Code du contexte Spring</h2>

<p><code>xml
&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xsi:schemalocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;
 &lt;bean class="org.springframework.jmx.support.MBeanServerFactoryBean" id="mbeanServer"&gt;
  &lt;property name="locateExistingServerIfPossible" value="true"&gt;&lt;/property&gt;
 &lt;/bean&gt;
 
 &lt;bean class="org.springframework.jmx.export.MBeanExporter" id="exporter"&gt;
  &lt;property name="beans"&gt;
   &lt;map&gt;
    &lt;entry key="bean:application=jmx-sample,name=simpleCounter" value-ref="simpleCounter"&gt;&lt;/entry&gt;
   &lt;/map&gt;
  &lt;/property&gt;
   &lt;property name="server" ref="mbeanServer"&gt;&lt;/property&gt;
 &lt;/bean&gt;
 
 &lt;bean class="fr.jetoile.demo.jmx.SimpleCounter" id="simpleCounter"&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></p>

<p>Concernant le fichier descripteur de Spring, on constate que la classe <code>MBeanServerFactoryBean</code> de Spring est utilisée comme moyen de récupération/création du MBeanServer et que c'est le <code>MBeanExporter</code> qui a la charge de l'enregistrement du MBean injecté.</p>

<h1>Application web exécutable via Jetty au sein de Maven</h1>

<p>Afin de permettre une exécution de notre application web dans un Jetty embedded dans Maven, il faut, bien sûr, une structure Maven.</p>

<p>Elle est la suivante :
<img src="http://3.bp.blogspot.com/-q2jJEYSygfg/TnErFlaNEDI/AAAAAAAAAag/2vgwO_zYc6A/s1600/jmx-sample-tree.png" alt="center" /></p>

<p>Concernant le fichier descripteur <code>pom.xml</code>, il contiendra, bien sûr, le plugin nécessaire au lancement de jetty.</p>

<p>Afin d'être plus exhaustif, dans notre POC, deux profils Maven seront utilisés afin de pouvoir spécifier la version de Jetty à utiliser (le choix sera laissé entre Jetty 6 et 7). En outre, le port d'écoute est forcé à 9090 :</p>

<p><code>xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
 &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 &lt;groupId&gt;fr.jetoile.demo&lt;/groupId&gt;
 &lt;artifactId&gt;jmx-sample&lt;/artifactId&gt;
 &lt;packaging&gt;war&lt;/packaging&gt;
 &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
 
 &lt;properties&gt;
  &lt;java.version&gt;1.5&lt;/java.version&gt;
  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
 
  &lt;slf4j.version&gt;1.6.1&lt;/slf4j.version&gt;
  &lt;logback.version&gt;0.9.27&lt;/logback.version&gt;
  &lt;commons-lang.version&gt;2.5&lt;/commons-lang.version&gt;
  &lt;spring.version&gt;3.0.6.RELEASE&lt;/spring.version&gt;
  &lt;servlet.version&gt;2.5&lt;/servlet.version&gt;
 &lt;/properties&gt;
 
 &lt;dependencies&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
   &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
   &lt;version&gt;${logback.version}&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
   &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
   &lt;version&gt;${slf4j.version}&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;commons-lang&lt;/groupId&gt;
   &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
   &lt;version&gt;${commons-lang.version}&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
   &lt;version&gt;${spring.version}&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
   &lt;version&gt;${spring.version}&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
   &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
   &lt;version&gt;${servlet.version}&lt;/version&gt;
   &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
 &lt;/dependencies&gt;
 
 &lt;build&gt;
  &lt;plugins&gt;
 
   &lt;plugin&gt;
    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
   &lt;/plugin&gt;
 
   &lt;plugin&gt;
    &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
   &lt;/plugin&gt;
 
   &lt;plugin&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.3.2&lt;/version&gt;
    &lt;configuration&gt;
     &lt;source&gt;${java.version}&lt;/source&gt;
     &lt;target&gt;${java.version}&lt;/target&gt;
     &lt;encoding&gt;UTF-8&lt;/encoding&gt;
    &lt;/configuration&gt;
   &lt;/plugin&gt;
 
   &lt;plugin&gt;
    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.4.3&lt;/version&gt;
    &lt;configuration&gt;
     &lt;encoding&gt;UTF-8&lt;/encoding&gt;
    &lt;/configuration&gt;
   &lt;/plugin&gt;
  &lt;/plugins&gt;
 &lt;/build&gt;
  
  
 &lt;profiles&gt;
  &lt;profile&gt;
   &lt;id&gt;jetty6&lt;/id&gt;
   &lt;properties&gt;
    &lt;jetty.version&gt;6.1.26&lt;/jetty.version&gt;
   &lt;/properties&gt;
   &lt;build&gt;
    &lt;plugins&gt;
     &lt;plugin&gt;
      &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
      &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;
      &lt;version&gt;${jetty.version}&lt;/version&gt;
      &lt;configuration&gt;
       &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;
       &lt;webAppConfig&gt;
        &lt;contextPath&gt;/jmx-sample&lt;/contextPath&gt;
       &lt;/webAppConfig&gt;
       &lt;connectors&gt;
         &lt;connector implementation="org.mortbay.jetty.nio.SelectChannelConnector"&gt;
         &lt;port&gt;9090&lt;/port&gt;
         &lt;host&gt;0.0.0.0&lt;/host&gt;
         &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt;
        &lt;/connector&gt;
       &lt;/connectors&gt; 
      &lt;/configuration&gt;
     &lt;/plugin&gt;
    &lt;/plugins&gt;
   &lt;/build&gt;
  &lt;/profile&gt;
  &lt;profile&gt;
   &lt;id&gt;jetty7&lt;/id&gt;
   &lt;properties&gt;
    &lt;jetty.version&gt;7.4.5.v20110725&lt;/jetty.version&gt;
   &lt;/properties&gt;
   &lt;build&gt;
    &lt;plugins&gt;
     &lt;plugin&gt;
      &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
      &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;${jetty.version}&lt;/version&gt;
      &lt;configuration&gt;
       &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;
       &lt;webAppConfig&gt;
        &lt;contextPath&gt;/jmx-sample&lt;/contextPath&gt;
       &lt;/webAppConfig&gt;
       &lt;connectors&gt;
           &lt;connector implementation="org.eclipse.jetty.server.nio.SelectChannelConnector"&gt;
         &lt;port&gt;9090&lt;/port&gt;
         &lt;host&gt;0.0.0.0&lt;/host&gt;
         &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt;
        &lt;/connector&gt;
       &lt;/connectors&gt; 
      &lt;/configuration&gt;
     &lt;/plugin&gt;
    &lt;/plugins&gt;
   &lt;/build&gt;
  &lt;/profile&gt;
 &lt;/profiles&gt;
&lt;/project&gt;
</code>
Il n'y a rien de particulier à remarquer si ce n'est une version de plugin maven pour Jetty qui diffère, ainsi qu'un changement de package pour le SelectChannelConnector utilisé pour spécifier le port d'écoute.</p>

<p>Pour démarrer notre Jetty, il ne reste plus qu'à exécuter, au choix, la commande :</p>

<p><code>bash
mvn -Pjetty6 jetty:run
</code></p>

<p>ou :</p>

<p><code>bash
mvn -Pjetty7 jetty:run
</code></p>

<h2>Activation de JMX</h2>

<p>Après avoir montré l'application web ainsi que la configuration du plugin Maven de Jetty nécessaire à son exécution dans le conteneur embarqué, il est possible de démarrer l'application web dans le Jetty embedded.</p>

<p><img src="http://1.bp.blogspot.com/-MC5ASoy7hYY/TnEsBl97o9I/AAAAAAAAAao/wKFzpPyRaI0/s1600/visualVM.png" alt="center" /></p>

<p><img src="http://1.bp.blogspot.com/-h1-h-jZ47Ys/TnEr6OFgvnI/AAAAAAAAAak/hkrxFyewmwA/s1600/jconsole.png" alt="center" />
Cependant, même si nos JConsole ou VisualVM préférées proposent une connexion au MBean Server local (visible au travers notre processus Maven3 <code>org.codehaus.plexus.classworlds.launcher.Launcher</code>), il n'est pas possible d'effectuer une connexion en spécifiant le JMXServiceURL de type : <code>service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi</code> .</p>

<p>En effet, par défaut, Jetty ne créé pas de MBeanServer et, à fortiori, n'enregistre aucun connecteur RMI nécessaire à une application JMX cliente.</p>

<p>A titre informatif, même en démarrant un serveur Jetty en mode standalone, il est nécessaire de préciser, à son démarrage, le fichier de configuration <code>jetty-jmx.xml</code> se trouvant, par défaut, dans son répertoire etc et qu'il faut éditer (pour préciser le port du serveur RMI à démarrer et le JMXServiceURL du connecteur JMX RMI).
Pour Jetty 7, cela peut être fait, soit en modifiant le fichier start.ini, soit en démarrant Jetty en ligne de commande :</p>

<p><code>bash
java -jar start.jar etc/jetty-jmx.xml etc/jetty.xml
</code>
Pour Jetty 6, cela peut être fait, soit en modifiant le fichier <code>bin/jetty-service.conf</code>, soit en démarrant Jetty en ligne de commande :</p>

<p><code>bash
java -DOPTIONS=jmx -jar start.jar etc/jetty-jmx.xml etc/jetty.xml
</code></p>

<p>Aussi, pour activer la création d'un serveur RMI et créer un MBean Server dans le Jetty embarqué par Maven, il est nécessaire de fournir au plugin le fichier <code>jetty-jmx.xml</code>.</p>

<p>Pour ce faire, il est possible de spécifier une configuration à Jetty via l'élément : <code>&lt;jettyConfig&gt;</code>
<code>xml
&lt;profiles&gt;
 &lt;profile&gt;
  &lt;id&gt;jetty6&lt;/id&gt;
  &lt;properties&gt;
   &lt;jetty.version&gt;6.1.26&lt;/jetty.version&gt;
  &lt;/properties&gt;
  &lt;build&gt;
   &lt;plugins&gt;
    &lt;plugin&gt;
     &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
     &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;
     &lt;version&gt;${jetty.version}&lt;/version&gt;
     &lt;configuration&gt;
      &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;
      &lt;jettyConfig&gt;${basedir}/src/config/jetty-jmx-6.xml&lt;/jettyConfig&gt;
      &lt;webAppConfig&gt;
       &lt;contextPath&gt;/jmx-sample&lt;/contextPath&gt;
      &lt;/webAppConfig&gt;
      &lt;connectors&gt;
        &lt;connector implementation="org.mortbay.jetty.nio.SelectChannelConnector"&gt;
        &lt;port&gt;9090&lt;/port&gt;
        &lt;host&gt;0.0.0.0&lt;/host&gt;
        &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt;
       &lt;/connector&gt;
      &lt;/connectors&gt;
     &lt;/configuration&gt;
    &lt;/plugin&gt;
   &lt;/plugins&gt;
  &lt;/build&gt;
 &lt;/profile&gt;
 &lt;profile&gt;
  &lt;id&gt;jetty7&lt;/id&gt;
  &lt;properties&gt;
   &lt;jetty.version&gt;7.4.5.v20110725&lt;/jetty.version&gt;
  &lt;/properties&gt;
  &lt;build&gt;
   &lt;plugins&gt;
    &lt;plugin&gt;
     &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
     &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
     &lt;version&gt;${jetty.version}&lt;/version&gt;
     &lt;configuration&gt;
      &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;
      &lt;jettyConfig&gt;${basedir}/src/config/jetty-jmx.xml&lt;/jettyConfig&gt;
      &lt;webAppConfig&gt;
       &lt;contextPath&gt;/jmx-sample&lt;/contextPath&gt;
      &lt;/webAppConfig&gt;
      &lt;connectors&gt;
          &lt;connector implementation="org.eclipse.jetty.server.nio.SelectChannelConnector"&gt;
        &lt;port&gt;9090&lt;/port&gt;
        &lt;host&gt;0.0.0.0&lt;/host&gt;
        &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt;
       &lt;/connector&gt;
      &lt;/connectors&gt; 
     &lt;/configuration&gt;
    &lt;/plugin&gt;
   &lt;/plugins&gt;
  &lt;/build&gt;
 &lt;/profile&gt;
&lt;/profiles&gt;
</code></p>

<p>La nouvelle arborescence de notre projet devient donc :</p>

<p><img src="http://1.bp.blogspot.com/-isxZpdoIozo/TnHVHTqIwRI/AAAAAAAAAbA/urXO-bvkGsM/s1600/jmx-sample-tree2.png" alt="center" /></p>

<p>En outre, il est nécessaire de démarrer la JVM avec l'option -Dcom.sun.management.jmxremote :
<code>bash
mvn -Dcom.sun.management.jmxremote -Pjetty6 package jetty:run
</code></p>

<br/>


<p><code>bash
mvn -Dcom.sun.management.jmxremote -Pjetty7 package jetty:run
</code></p>

<p>Suite au lancement du serveur Jetty via Maven, il est alors possible d'y accéder au travers d'un client JMX en mode distant :
<img src="http://4.bp.blogspot.com/-neKAz6J3YXk/TnEsy6vJiZI/AAAAAAAAAa0/S8go6tW4weA/s1600/connection.png" alt="center" /></p>

<p><img src="http://4.bp.blogspot.com/-FlX8ZwRcjTU/TnEsVSwh0yI/AAAAAAAAAas/VxjMj6QeEHU/s1600/visualVM2.png" alt="medium" /></p>

<p><img src="http://3.bp.blogspot.com/-WYs5-5s-Aik/TnEsZ24uHdI/AAAAAAAAAaw/3bTMjhjYLdg/s1600/visualVM3.png" alt="medium" /></p>

<p>A titre informatif, ci-joint les fichiers de configuration de Jetty permettant la création d'un serveur RMI, du MBean Server et du connecteur RMI ainsi que de sa configuration.</p>

<p>Pour Jetty 6 :
<code>xml
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure//EN" "http://jetty.mortbay.org/configure.dtd"&gt;
 
&lt;Configure id="Server" class="org.mortbay.jetty.Server"&gt;
    &lt;Call id="MBeanServer" class="java.lang.management.ManagementFactory" name="getPlatformMBeanServer"/&gt;
 
    &lt;Get id="Container" name="container"&gt;
      &lt;Call name="addEventListener"&gt;
        &lt;Arg&gt;
          &lt;New class="org.mortbay.management.MBeanContainer"&gt;
            &lt;Arg&gt;&lt;Ref id="MBeanServer"/&gt;&lt;/Arg&gt;
            &lt;Call name="start" /&gt;
          &lt;/New&gt;
        &lt;/Arg&gt;
      &lt;/Call&gt;
    &lt;/Get&gt;
 
    &lt;Call id="rmiRegistry" class="java.rmi.registry.LocateRegistry" name="createRegistry"&gt;
      &lt;Arg type="int"&gt;1099&lt;/Arg&gt;
    &lt;/Call&gt;
     
    &lt;Call id="jmxConnectorServer" class="javax.management.remote.JMXConnectorServerFactory" name="newJMXConnectorServer"&gt;
      &lt;Arg&gt;
        &lt;New  class="javax.management.remote.JMXServiceURL"&gt;
          &lt;Arg&gt;service:jmx:rmi://localhost:1099/jndi/rmi://localhost:1099/jmxrmi&lt;/Arg&gt;
        &lt;/New&gt;
      &lt;/Arg&gt;
      &lt;Arg/&gt;
      &lt;Arg&gt;&lt;Ref id="MBeanServer"/&gt;&lt;/Arg&gt;
      &lt;Call name="start"/&gt;
    &lt;/Call&gt;
&lt;/Configure&gt;
</code></p>

<p>Pour Jetty 7 :
<code>xml
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure.dtd"&gt;
&lt;Configure id="Server" class="org.eclipse.jetty.server.Server"&gt;
 
  &lt;Call id="MBeanServer" class="java.lang.management.ManagementFactory"
    name="getPlatformMBeanServer" /&gt;
 
  &lt;New id="MBeanContainer" class="org.eclipse.jetty.jmx.MBeanContainer"&gt;
    &lt;Arg&gt;
      &lt;Ref id="MBeanServer" /&gt;
    &lt;/Arg&gt;
  &lt;/New&gt;
 
  &lt;Get id="Container" name="container"&gt;
    &lt;Call name="addEventListener"&gt;
      &lt;Arg&gt;
        &lt;Ref id="MBeanContainer" /&gt;
      &lt;/Arg&gt;
    &lt;/Call&gt;
  &lt;/Get&gt;
 
  &lt;Call name="addBean"&gt;
    &lt;Arg&gt;
      &lt;Ref id="MBeanContainer" /&gt;
    &lt;/Arg&gt;
  &lt;/Call&gt;
 
  &lt;Get id="Logger" class="org.eclipse.jetty.util.log.Log" name="log" /&gt;
  &lt;Ref id="MBeanContainer"&gt;
    &lt;Call name="addBean"&gt;
      &lt;Arg&gt;
        &lt;Ref id="Logger" /&gt;
      &lt;/Arg&gt;
    &lt;/Call&gt;
  &lt;/Ref&gt;
   
  &lt;Call name="createRegistry" class="java.rmi.registry.LocateRegistry"&gt;
    &lt;Arg type="java.lang.Integer"&gt;1099&lt;/Arg&gt;
    &lt;Call name="sleep" class="java.lang.Thread"&gt;
       &lt;Arg type="java.lang.Integer"&gt;1000&lt;/Arg&gt;
    &lt;/Call&gt;
  &lt;/Call&gt;
  
 &lt;New id="ConnectorServer" class="org.eclipse.jetty.jmx.ConnectorServer"&gt;
    &lt;Arg&gt;
      &lt;New class="javax.management.remote.JMXServiceURL"&gt;
        &lt;Arg type="java.lang.String"&gt;rmi&lt;/Arg&gt;
        &lt;Arg type="java.lang.String" /&gt;
        &lt;Arg type="java.lang.Integer"&gt;0&lt;/Arg&gt;
        &lt;Arg type="java.lang.String"&gt;/jndi/rmi://localhost:1099/jmxrmi&lt;/Arg&gt;
      &lt;/New&gt;
    &lt;/Arg&gt;
    &lt;Arg&gt;org.eclipse.jetty:name=rmiconnectorserver&lt;/Arg&gt;
    &lt;Call name="start" /&gt;
  &lt;/New&gt;
&lt;/Configure&gt;
</code></p>

<h1>Conclusion</h1>

<p>Cet article avait pour objectif de montrer comment il pouvait être facile d'activer la couche JMX pour un serveur Jetty embedded dans Maven.</p>

<p>C'est vrai que démarrer un Jetty embarqué n'a pas pour objectif de faire des tests d'intégration mais cela peut toujours être utile dans le cas d'un POC ou d'une démonstration (qui était d'ailleurs l'objectif de ce petit cas d'usage. ;&ndash;) ).</p>
]]></content>
  </entry>
  
</feed>
