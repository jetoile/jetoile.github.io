<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: microservice | Jetoile]]></title>
  <link href="https://blog.jetoile.fr/blog/categories/microservice/atom.xml" rel="self"/>
  <link href="https://blog.jetoile.fr/"/>
  <updated>2018-10-28T17:58:30+01:00</updated>
  <id>https://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Template de projets REST]]></title>
    <link href="https://blog.jetoile.fr/2015/10/template-de-projets-rest.html"/>
    <updated>2015-10-07T17:33:08+02:00</updated>
    <id>https://blog.jetoile.fr/2015/10/template-de-projets-rest</id>
    <content type="html"><![CDATA[<p><img src="/images/template_rest.png" alt="left-small" />
Il y a déjà un long moment, j'avais posté une série d'article expliquant comment il était possible de faire des web service de type REST de manière simple via <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">RestEasy-Netty</a> ou via <a href="http://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest.html">Undertow</a>.</p>

<p>Dans la continuité de cette course au plus léger, je me suis dit que cela pouvait être intéressant de faire une petite étude un peu plus exhaustive des solutions légères qui existaient.</p>

<p>L'objectif étant extraire une sorte de bench un peu naïf et un peu <em>out of the box</em>. Parmi les solutions retenues, il y a :</p>

<ul>
<li>Resteasy-Netty</li>
<li>Resteasy-Undertow</li>
<li>Restlet</li>
<li>SpringBoot</li>
<li>Resteasy sur Tomcat en utilisant ses connecteurs NIO</li>
<li>Resteasy sur Jetty</li>
</ul>


<p>Cette article est là pour restituer mes résultats&hellip;</p>

<!-- more -->


<p>En fait, non&hellip; j'ai menti puisque je ne ferai aucun retour mais que je donnerai seulement le lien vers mon github où il est possible de trouver ces <em>bootstrap</em> de projets&hellip;</p>

<p>En effet, faire un <em>bench</em> est dangereux et complexe surtout quand toutes les implémentations ne sont pas maitrisées et qu'un <em>tuning</em> de ces dernières peut grandement modifier le résultat.</p>

<p>En outre, avoir un service exhaustif (autre que un simple <em>helloword</em>) qui est représentatif d'une vrai application et qui ne fait pas que taper dans le cache de la JVM ou de l'OS est plus complexe qu'écrire un simple <em>sample</em>.</p>

<p>Enfin, par manque de moyen (2 ordinateurs reliés par un wifi capricieux et par flemme de me monter des environnements plus représentatifs), je n'ai pu obtenir de résultats fiables&hellip;</p>

<p>Aussi, ci-joint les <em>repos</em> où il est possible de trouver le code (qui se veut ultra simple et qui a été fait sans chercher l'optimisation et sur un coin de table donc si des bourdes ont été faites, je m'en excuse&hellip;) :</p>

<ul>
<li><a href="https://github.com/jetoile/resteasy-netty-sample">Sample RestEasy-Netty</a></li>
<li><a href="https://github.com/jetoile/dropwizard-sample">Sample Dropwizard</a></li>
<li><a href="https://github.com/jetoile/restlet-sample">Sample Restlet</a></li>
<li><a href="https://github.com/jetoile/undertow-sample">Sample RestReasy-Undertow</a></li>
<li><a href="https://github.com/jetoile/tomcat-resteasy-sample">Sample Tomcat/Jetty</a> : simple webapp à déployer dans les conteneurs avec les bonnes options</li>
<li><a href="https://github.com/jetoile/springboot-sample">Sample SpringBoot</a></li>
<li><a href="https://github.com/jetoile/gatling-sample">Sample de projet Gatling pour le tir de performance</a></li>
</ul>


<p>Ainsi, si le coeur vous en dit, vous pourrez vous faire vous même une idée de qui est le plus fort&hellip; et même comparer avec vos solutions maisons&hellip; ;)</p>

<p>Allez, et parce que je suis sympa, je mets quand même le rapport Gatling obtenu suite à 1 seul tir en local. Je laisse le lecteur se faire une idée&hellip; ou pas&hellip;</p>

<ul>
<li><a href="/images/res_charge_gatling/dropwizard-1/index.html">Résultat Dropwizard</a></li>
<li><a href="/images/res_charge_gatling/jetty-1/index.html">Résultat Jetty</a></li>
<li><a href="/images/res_charge_gatling/netty-1/index.html">Résultat RestEasy-Netty</a></li>
<li><a href="/images/res_charge_gatling/restlet-1/index.html">Résultat Restlet</a></li>
<li><a href="/images/res_charge_gatling/springboot-1/index.html">Résultat SpringBoot</a></li>
<li><a href="/images/res_charge_gatling/tomcat-nio-1/index.html">Résultat Tomcat NIO</a></li>
<li><a href="/images/res_charge_gatling/undertow-1/index.html">Résultat RestEasy-Undertow</a></li>
</ul>


<p>Voilà un article un peu facile et qui n'apporte pas grand chose mais je trouvais qu'il était toujours intéressant pour les lecteurs curieux d'avoir la possibilité de voir différentes implementations&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Undertow pour booster vos services REST]]></title>
    <link href="https://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest.html"/>
    <updated>2015-06-23T14:51:56+02:00</updated>
    <id>https://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest</id>
    <content type="html"><![CDATA[<p><img src="/images/undertow.png" alt="left-small" />
Il y a quelques temps, j'avais fait une série d'articles sur <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>.</p>

<p>Cette article repart du même besoin, à savoir disposer d'une <em>stack</em> légère pour réaliser un service REST, mais en utilisant <a href="http://undertow.io/">Undertow</a> plutôt que Resteasy-Netty.</p>

<!-- more -->


<p>Au niveau des besoins, ils seront identiques ie. :</p>

<ul>
<li>utiliser JAX-RS,</li>
<li>intégrer Swagger,</li>
<li>intégrer Jolokia,</li>
<li>générer un livrable autoporteur.</li>
</ul>


<p>RestEasy-Netty, même s'il existe de nombreux points d'entrée, demande quelques phases de <em>hack</em> (gestion du <em>crossover domain</em> par exemple) et dispose d'un mécanisme un peu limité concernant la partie sécurité.</p>

<p>En outre, l'absence du mécanisme de Servlet reste un peu embêtant pour mettre en place certaines <em>features</em> comme le MDC ( <a href="http://logback.qos.ch/manual/mdc.html"><em>Mapped Diagnostic Context</em></a> ) bien pratique lorsque l'on est dans une architecture type microservice.</p>

<p>Le code complet est disponible <a href="https://github.com/jetoile/undertow-sample">ici</a>.</p>

<h1>Rappel du cahier des charges</h1>

<p>Comme je l'ai déjà indiqué dans les autres posts, l'objectif est seulement de montrer comme il peut être simple d'exposer un service REST à l'aide d'<a href="http://undertow.io/">Undertow</a>. Pour ce faire, un simple service sera exposé et il consistera à répèter ce qu’on lui demande…</p>

<p>Il répondra donc à une requête de type GET du type : <a href="http://localhost:8081/sample/say/">http://localhost:8081/sample/say/</a><message></p>

<p>Du coté de la réponse, elle aura la forme suivante :
```javascript
{</p>

<pre><code>"message": &lt;message&gt;,
"time":"2015-06-23T15:18:50.748"
</code></pre>

<p>}
```</p>

<h1>Mise en oeuvre</h1>

<p>A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :
```text</p>

<pre><code>compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.11.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.3.1'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.12'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'javax.servlet-api', version:'3.1.0'
compile group: 'io.dropwizard.metrics', name: 'metrics-core', version:'3.1.2'
compile group: 'io.undertow', name: 'undertow-core', version:'1.2.8.Final'
compile group: 'io.undertow', name: 'undertow-servlet', version:'1.2.8.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-undertow', version:'3.0.11.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson2-provider', version:'3.0.11.Final'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version:'2.5.4'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version:'2.5.4'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version:'2.5.4'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.10'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'org.slf4j', name: 'slf4j-api', version:'1.7.12'
compile group: 'ch.qos.logback', name: 'logback-classic', version:'1.1.3'
</code></pre>

<p>```</p>

<p>Concernant la version des différentes dépendances, on constate que ce n'est pas swagger2 qui est utilisé en raison d'une incapacité de ma part à l'intégrer&hellip; :&lsquo;(</p>

<h1>Implémentation du service REST</h1>

<p>Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial… et la classe ci-dessous fait humblement l’affaire :
```java
@Api(value = &ldquo;/sample&rdquo;,</p>

<pre><code>    description = "the sample api")
</code></pre>

<p>@Path(&ldquo;/sample&rdquo;)
@RolesAllowed(&ldquo;admin&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);


@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
@ApiOperation(value = "repeat the word",
        notes = "response the word",
        response = DtoResponse.class)
@ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})
public Response sayHello(@PathParam("msg") String message) {

    log.info("sample log");

    final Timer timer = Main.metricRegistry.timer(name(SimpleService.class, "say-service"));
    final Timer.Context context = timer.time();
    try {

        DtoResponse response = new DtoResponse();
        try {
            response.setMessage(message);
            response.setTime(LocalDateTime.now());
        } catch (Exception e) {
            log.error("internal error: {}", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(response).build();
    } finally {
        if (context != null) context.stop();
    }
}
</code></pre>

<p>}
<code>
Coté du DTO, il est le suivant :
</code>java
@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
private LocalDateTime time;

public DtoResponse() {
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

public LocalDateTime getTime() {
    return time;
}

public void setTime(LocalDateTime time) {
    this.time = time;
}
</code></pre>

<p>}
```</p>

<p>On remarquera l'utilisation de Java8 pour la gestion du temps plutôt que Joda-Time.</p>

<p>En outre, concernant les annotations Swagger et l'utilisation de metrics, nous y reviendrons plus tard.</p>

<p>Concernant le message de log, de même, nous y reviendrons plus tard avec l'intégration d'un MDC pour les logs.</p>

<h1>Mise en oeuvre avec Undertow</h1>

<p>Mettre en place Resteasy avec Undertow est très simple, d’après la documnentation, il suffit de faire :
```java
SimpleService simpleService = new SimpleService();
ResteasyDeployment deployment = new ResteasyDeployment();</p>

<p>deployment.setResources(Arrays.<Object>asList(simpleService));</p>

<p>int port = config.getInt(&ldquo;undertow.port&rdquo;, TestPortProvider.getPort());
String host = config.getString(&ldquo;undertow.host&rdquo;, String.valueOf(TestPortProvider.getHost()));
System.setProperty(&ldquo;org.jboss.resteasy.port&rdquo;, String.valueOf(TestPortProvider.getPort());
System.setProperty(&ldquo;org.jboss.resteasy.host&rdquo;, String.valueOf(TestPortProvider.getHost());</p>

<p>UndertowJaxrsServer server = new UndertowJaxrsServer();</p>

<p>DeploymentInfo deploymentInfo = server.undertowDeployment(deployment);
deploymentInfo.setDeploymentName(&ldquo;&rdquo;);
deploymentInfo.setContextPath(&ldquo;/&rdquo;);
deploymentInfo.setClassLoader(Main.class.getClassLoader());</p>

<p>deployment.setProviderFactory(new ResteasyProviderFactory());
server.deploy(deploymentInfo);
server.start(Undertow.builder().addHttpListener(port, host));
```</p>

<p>On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <code>setResources()</code> sur l’instance de <em>ResteasyDeployment</em> fournit au serveur <em>UndertowJaxrsServer</em> :</p>

<p>Et voilà! On dispose désormais d’un programme exécutable qui démarre un serveur REST basé sur Undertow.</p>

<p>Par contre, il semble que le service ne rende pas vraiment ce que l'on voulait :
<code>bash
curl 'http://localhost:8081/sample/say/&lt;message&gt;'
</code></p>

<p>```json
{</p>

<pre><code>"message": "&lt;message&gt;",
"time": {
    "hour": 15,
    "minute": 55,
    "second": 51,
    "nano": 225000000,
    "year": 2015,
    "month": "JUNE",
    "dayOfMonth": 23,
    "dayOfWeek": "TUESDAY",
    "dayOfYear": 174,
    "monthValue": 6,
    "chronology": {
        "calendarType": "iso8601",
        "id": "ISO"
    }
}
</code></pre>

<p>}
```</p>

<p>Pas de souci, il suffit de préciser comment on souhaite que LocalDateTime soit sérialisé par Jackson :</p>

<p>Ainsi, notre DTO devient :
```java</p>

<p>@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
@JsonSerialize(using = LocalDateTimeToStringSerializer.class)
private LocalDateTime time;

public DtoResponse() {
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

public LocalDateTime getTime() {
    return time;
}

public void setTime(LocalDateTime time) {
    this.time = time;
}
</code></pre>

<p>}
```</p>

<p>où :</p>

<p>```java
public class LocalDateTimeToStringSerializer extends JsonSerializer<LocalDateTime> {</p>

<pre><code>@Override
public void serialize(LocalDateTime value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
    jgen.writeObject(value.format(DateTimeFormatter.ISO_DATE_TIME));
}
</code></pre>

<p>}
```</p>

<p>Après ces modifications, on obtient bien :</p>

<p><code>json
{"message":"&lt;message&gt;","time":"2015-06-23T16:04:01.419"}
</code></p>

<h1>Intégration de Metrics</h1>

<p>Concernant l'intégration de Metrics, pas grand chose de nouveau et donc pas grand chose à dire ;&ndash;)</p>

<p>Déclarer le registry :
<code>java
metricRegistry = new MetricRegistry();
final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();
reporter.start();
</code></p>

<p>Et utiliser le dans vos classes :
```java
final Timer timer = Main.metricRegistry.timer(name(SimpleService.class, &ldquo;say-service&rdquo;));
final Timer.Context context = timer.time();
try {</p>

<pre><code>...
</code></pre>

<p>} finally {</p>

<pre><code>if (context != null) context.stop();
</code></pre>

<p>}
```</p>

<h1>Intégration de la sécurité</h1>

<p>Undertow permet une bien meilleur intégration de la sécurité que RestEasy-Netty. En effet, grâce au mécanisme de Servlet, il est possible de bénéficier de toute la puissance des conteneurs de Servlets.</p>

<p>Du coté du serveur Undertow, il suffit donc de définir un <em>ServletIdentityManager</em> et de lui fournir un <em>LoginConfig</em> :
```java
deployment.setSecurityEnabled(true);</p>

<p>ServletIdentityManager identityManager = new ServletIdentityManager();
identityManager.addUser(&ldquo;khanh&rdquo;, &ldquo;khanh&rdquo;, &ldquo;admin&rdquo;);</p>

<p>deploymentInfo = deploymentInfo.setIdentityManager(identityManager).setLoginConfig(new LoginConfig(&ldquo;BASIC&rdquo;, &ldquo;Test Realm&rdquo;));
```</p>

<p>où :
```java
public class ServletIdentityManager implements IdentityManager {</p>

<pre><code>private static final Charset UTF_8 = Charset.forName("UTF-8");
private final Map&lt;String, UserAccount&gt; users = new HashMap&lt;&gt;();

public void addUser(final String name, final String password, final String... roles) {
    UserAccount user = new UserAccount();
    user.name = name;
    user.password = password.toCharArray();
    user.roles = new HashSet&lt;&gt;(Arrays.asList(roles));
    users.put(name, user);
}

@Override
public Account verify(Account account) {
    // Just re-use the existing account.
    return account;
}

@Override
public Account verify(String id, Credential credential) {
    Account account = users.get(id);
    if (account != null &amp;&amp; verifyCredential(account, credential)) {
        return account;
    }

    return null;
}

@Override
public Account verify(Credential credential) {
    return null;
}

private boolean verifyCredential(Account account, Credential credential) {
    // This approach should never be copied in a realm IdentityManager.
    if (account instanceof UserAccount) {
        if (credential instanceof PasswordCredential) {
            char[] expectedPassword = ((UserAccount) account).password;
            char[] suppliedPassword = ((PasswordCredential) credential).getPassword();

            return Arrays.equals(expectedPassword, suppliedPassword);
        } else if (credential instanceof DigestCredential) {
            DigestCredential digCred = (DigestCredential) credential;
            MessageDigest digest = null;
            try {
                digest = digCred.getAlgorithm().getMessageDigest();

                digest.update(account.getPrincipal().getName().getBytes(UTF_8));
                digest.update((byte) ':');
                digest.update(digCred.getRealm().getBytes(UTF_8));
                digest.update((byte) ':');
                char[] expectedPassword = ((UserAccount) account).password;
                digest.update(new String(expectedPassword).getBytes(UTF_8));

                return digCred.verifyHA1(HexConverter.convertToHexBytes(digest.digest()));
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException("Unsupported Algorithm", e);
            } finally {
                digest.reset();
            }
        }
    }
    return false;
}

private static class UserAccount implements Account {
    // In no way whatsoever should a class like this be considered a good idea for a real IdentityManager implementation,
    // this is for testing only.

    String name;
    char[] password;
    Set&lt;String&gt; roles;

    private final Principal principal = new Principal() {
        @Override
        public String getName() {
            return name;
        }
    };

    @Override
    public Principal getPrincipal() {
        return principal;
    }

    @Override
    public Set&lt;String&gt; getRoles() {
        return roles;
    }
}
</code></pre>

<p>}
```</p>

<p>Il s'agit ici d'une Basic Authentification mais il est bien sûr possible d'en mettre en place d'autre.</p>

<p>Coté autorisation, il est alors possible de bénéficier de l'annotation <code>@RolesAllowed</code> de JAX-RS :
<code>java
@Path("/sample")
@RolesAllowed("admin")
public class SimpleService {
...
}
</code></p>

<h1>Intégration d'un MDC</h1>

<p>Concernant la mise en place d'un MDC (<em>Mapped Diagnostic Context</em>), le fait de bénéficier du mécanisme de <em>Filter</em> des Servlets rend la chose beaucoup plus simple.</p>

<p>En effet, une fois la couche sécurité branchée, il suffit de récupérer le <code>UserPrincipal</code> dans la requête et l'enregistrer dans le MDC.</p>

<p>La déclaration des Filters se fait de la manière suivante pour Undertow :
```java
FilterInfo mdcFilter = new FilterInfo(&ldquo;MDCFilter&rdquo;, MDCServletFilter.class);
deploymentInfo.addFilter(mdcFilter);
deploymentInfo.addFilterUrlMapping(&ldquo;MDCFilter&rdquo;, &ldquo;*&rdquo;, DispatcherType.REQUEST);</p>

<p>FilterInfo mdcInsertingFilter = new FilterInfo(&ldquo;MDCInsertingServletFilter&rdquo;, MDCInsertingServletFilter.class);
deploymentInfo.addFilter(mdcInsertingFilter);
deploymentInfo.addFilterUrlMapping(&ldquo;MDCInsertingServletFilter&rdquo;, &ldquo;*&rdquo;, DispatcherType.REQUEST);
```</p>

<p>Avec le filter ci-dessous :
```java
public class MDCServletFilter implements Filter {</p>

<pre><code>private final String USER_KEY = "username";

public void destroy() {
}

public void doFilter(ServletRequest request, ServletResponse response,
                     FilterChain chain) throws IOException, ServletException {

    boolean successfulRegistration = false;

    HttpServletRequest req = (HttpServletRequest) request;
    Principal principal = req.getUserPrincipal();
    // Please note that we could have also used a cookie to
    // retrieve the user name

    if (principal != null) {
        String username = principal.getName();
        successfulRegistration = registerUsername(username);
    }

    try {
        chain.doFilter(request, response);
    } finally {
        if (successfulRegistration) {
            MDC.remove(USER_KEY);
        }
    }
}

public void init(FilterConfig arg0) throws ServletException {
}


/**
 * Register the user in the MDC under USER_KEY.
 *
 * @param username
 * @return true id the user can be successfully registered
 */
private boolean registerUsername(String username) {
    if (username != null &amp;&amp; username.trim().length() &gt; 0) {
        MDC.put(USER_KEY, username);
        return true;
    }
    return false;
}
</code></pre>

<p>}
<code>
Ainsi, disposer d'un MDC permet d'ajouter automatiquement des informations dans les logs :
</code>xml
<configuration></p>

<pre><code>&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;%d{HH:mm:ss.SSS} %-5level %logger{36} %X{req.remoteHost} %X{req.requestURI} - C:%X{username} - %msg%n

        &lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;


&lt;root level="info"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
&lt;/root&gt;
</code></pre>

<p></configuration>
```</p>

<p>On obtient alors bien les logs voulues :
<code>text
17:15:11.466 INFO  f.j.sample.service.SimpleService 127.0.0.1 /sample/say/&lt;message&gt; - C:khanh - sample log
</code></p>

<h1>Intégration de Jolokia</h1>

<p>Coté Jolokia, pas grand chose à ajouter par rapport à ma série d'article précédent&hellip;
```java
try {</p>

<pre><code>        JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());

        JolokiaServer jolokiaServer = new JolokiaServer(config, true);
        jolokiaServer.start();
</code></pre>

<p>} catch (Exception e) {</p>

<pre><code>        LOGGER.error("unable to start jolokia server", e);
</code></pre>

<p>}
```</p>

<h1>Intégration de Swagger</h1>

<p>Concernant l'intégration de Swagger, le fait de disposer des <em>Filter</em> de Servlet permet de n'avoir pas à faire de <em>hack</em> immonde pour gérer le CORS (cf. <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">article précédent</a>) : il suffit de déclarer un <em>Filter</em> dans Undertow qui a, en outre, la chance d'exister :
```java
CorsFilter filter = new CorsFilter();
filter.setAllowedMethods(&ldquo;GET,POST,PUT,DELETE,OPTIONS&rdquo;);
filter.setAllowedHeaders(&ldquo;X-Requested-With, Content-Type, Content-Length, Authorization&rdquo;);
filter.getAllowedOrigins().add(&ldquo;*&rdquo;);</p>

<p>deployment.setProviderFactory(new ResteasyProviderFactory());
deployment.getProviderFactory().register(filter);
```</p>

<p>Concernant la déclaration dans Undertow, pas grand chose à ajouter :
```java</p>

<pre><code>private static void initSwagger(ResteasyDeployment deployment) {
    BeanConfig swaggerConfig = new BeanConfig();
    swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));
    swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));
    swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));
    swaggerConfig.setScan(true);
    swaggerConfig.setResourcePackage("fr.jetoile.sample.service");

    deployment.setProviderClasses(Lists.newArrayList(
            "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",
            "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));
    deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));
    deployment.setSecurityEnabled(false);
}
</code></pre>

<p>```</p>

<h1>Branchement des plugins Maven Appassembler et Assembly</h1>

<p>Coté génération du livrable, encore une fois, pas grand chose à ajouter par rapport à mon précédent article : l'utilisation des plugins assembly et appassembler est identique.</p>

<h1>Conclusion</h1>

<p>On avait vu dans les articles précédents que RestEasy-Netty était une solution intéressante pour la simplicité de sa mise en oeuvre ainsi que pour le faible overhead.</p>

<p>Cependant, certaines intégrations ressemblaient plus à du <em>hack</em> qu'à une solution configurable.</p>

<p>Undertow (enfin pour être plus précis RestEasy-Undertow) pour sa part offre la même simplicité que RestEasy-Netty mais il permet en plus de s'intégrer avec beaucoup d'autres choses et le fait de retrouver le mécanisme de <em>Filter</em> facilite énormément les choses (par exemple, je ne suis pas sûr que bénéficier du MDC avec RestEasy-Netty ait été aussi simple).</p>

<p>Coté performance, je reviendrai dessus dans un autre article mais je peux déjà dire que la solution RestEasy-Undertow n'a rien à envier à RestEasy-Netty.</p>
]]></content>
  </entry>
  
</feed>
