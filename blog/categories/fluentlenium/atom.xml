<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fluentlenium | Jetoile]]></title>
  <link href="https://blog.jetoile.fr/blog/categories/fluentlenium/atom.xml" rel="self"/>
  <link href="https://blog.jetoile.fr/"/>
  <updated>2017-07-17T12:27:59+02:00</updated>
  <id>https://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BreizhCamp 2013]]></title>
    <link href="https://blog.jetoile.fr/2013/06/breizhcamp-2013.html"/>
    <updated>2013-06-13T01:27:32+02:00</updated>
    <id>https://blog.jetoile.fr/2013/06/breizhcamp-2013</id>
    <content type="html"><![CDATA[<p><img src="http://1.bp.blogspot.com/-Q9wf4o9BcBc/UboAHmjPqbI/AAAAAAAAA8M/2DZwYkDxpUg/s1600/logo.png" alt="left-small" /></p>

<p>Pour ceux qui l'aurait loupé, le BreizhCamp dans sa version 2013 a actuellement lieu.</p>

<p>Etant un grand amoureux de la Bretagne, je ne pouvais manquer le cru de cette année&hellip;</p>

<p>En outre, j'ai eu la chance d'y présenter un <strong>Tools In Action</strong> d'&frac12; heure sur le sujet des tests d'acceptance et plus précisément sur la façon dont il est possible d'intégrer Cucumber JVM, Selenium et FluentLenium.</p>

<p>Les slides sont dès à présent disponibles :</p>

<iframe frameborder="0" height="400" marginheight="0" marginwidth="0" scrolling="no" src="http://www.slideshare.net/slideshow/embed_code/22931252" width="476"></iframe>


<p>Et un projet d'exemple est accessible <a href="http://github.com/jetoile/sample-cucumber">ici</a>.</p>

<p>A noter que cette présentation concorde parfaitement avec la version de FluentLenium dans sa version 9.0 (comme par hasard! ;&ndash;) ).</p>

<p>Enjoy! ;&ndash;)</p>

<p>PS : en plus, pour une fois, il ne pleut pas&hellip; ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Industrialiser la récolte de métriques Web]]></title>
    <link href="https://blog.jetoile.fr/2013/04/industrialiser-la-recolte-de-metriques.html"/>
    <updated>2013-04-25T22:01:09+02:00</updated>
    <id>https://blog.jetoile.fr/2013/04/industrialiser-la-recolte-de-metriques</id>
    <content type="html"><![CDATA[<p><img src="http://1.bp.blogspot.com/-3MDuvu3M7y8/UXhaQ4KpF0I/AAAAAAAAA7c/0_a7KhiLEfw/s1600/01-timeline-harstorage5.png" alt="left-small" /></p>

<p> A l'origine, une des principales raisons à la mise en place d'un serveur d'intégration continue était l'automatisation des processus qui, fait manuellement, étaient souvent consommateur de temps et générateur d'erreurs humaines. Petit à petit, ce dernier s'est imposé comme l'orchestrateur de tous les processus et est devenu un des points central de l'usine de développement. En effet, en plus de ses capacités à compiler, packager, faire passer les tests unitaires, d'intégration et d'acceptance, il est souvent utilisé pour livrer mais également pour effectuer des tests de non régression.</p>

<p>Parmi ces tests de non regression, il est possible d'y inclure (en plus des classiques tests unitaires, d'intégration et d'acceptances) les tests de performances (<a href="http://jmeter.apache.org/">JMeter</a>, <a href="http://jmeter.apache.org/">Gatling</a>, <a href="http://clif.ow2.org/">Clif</a>) et la remontée de métriques de qualité de code (<a href="http://pmd.sourceforge.net/">PMD/CPD</a>, <a href="http://findbugs.sourceforge.net/">Findbugs</a>, <a href="http://checkstyle.sourceforge.net/">Checkstyle</a>, ou plus simplement <a href="http://www.sonarsource.org/">Sonar</a>).</p>

<p>Bien évidemment, récupérer des métriques sans les consolider ni les comparer avec l'historique est totalement inutile car cela n'offrirait aucune visibilité sur l'amélioration ou la dégradation du produit.</p>

<p>Ce petit laïus semble trivial pour ceux qui font du Java (enfin je l'espère&hellip; ;&ndash;) ). Cependant il l'est un peu moins dans le monde pur web (ie. lorsque l'on veut tester une couche pur front). Bien sûr, il y a Selenium &amp; co mais cela ne permet de ne tester que le fonctionnel. En outre, en cherchant dans la littérature (pour rappel, je ne suis pas développeur front), on peut constater que, souvent, les outils utilisés pour obtenir des métriques sur la qualité de rendu d'une page ou le temps de chargement de ses différents composants sont souvent intégrés au <a href="https://developers.google.com/chrome-developer-tools/">navigateur du développeur</a> et que, souvent, il est nécessaire de se faire des nœuds au cerveau pour les intégrer aux usines logicielles telles que celles dont l'écosystème Java a l'habitude.</p>

<p>Vous l'aurez compris, cet article a donc pour objectif de montrer comment il est possible d'intégrer tout ce beau monde&hellip;</p>

<p>Il se limitera cependant à la récupération de métriques sur la qualité de rendu d'une page ainsi qu'à son temps de chargement.</p>

<p>Dans un premier temps, cet article présentera donc comment il est possible de récupérer des métriques type <a href="http://yslow.org/">YSlow</a> ou <a href="https://developers.google.com/speed/pagespeed/">Pagespeed</a> (ie. une note globale sur la page) puis, dans un second temps, comment il est possible de récupérer des métriques sur le temps de chargement des pages. Enfin, pour faire le liant avec mes articles précédent, on verra comment il est possible de remonter et historiser ces métriques au travers un test d'acceptance.</p>

<p>Evidemment, l'objectif n'étant pas d'obtenir ces métriques de manière &ldquo;one shot&rdquo;, une attention particulière sera portée sur l'intégration de ces outils à une usine logicielle et à leurs capacités à fournir une évolution dans le temps.</p>

<!-- more -->


<h1>HTML et ses bonnes pratiques</h1>

<h2>Contexte</h2>

<p>Parmi les outils courants pour récupérer une évaluation d'une page HTML au sein d'un navigateur, il existe YSlow et Pagespeed. Ces deux outils fournissent un ensemble de notes qui permettent de qualifier les <em>bonnes</em> pratiques tels que la minification des fichiers Javascript.</p>

<p><img src="http://1.bp.blogspot.com/-FK0JmFOA6-E/UXhYlIp8YuI/AAAAAAAAA6M/X7S8oxoqMA4/s1600/01-pagespeed_chrome.png" alt="medium" /></p>

<p><img src="http://3.bp.blogspot.com/-BzaEnN79iIo/UXhZTxUiGaI/AAAAAAAAA6Y/YTmOqzR5c7M/s1600/yslow.png" alt="medium" /></p>

<p> Bien sûr, le fait d'utiliser un plugin de navigateur n'est pas ce qu'il y a de plus industrialisable. Le besoin peut être décomposé en deux étapes :</p>

<ul>
<li>la récupération des métriques,</li>
<li>la présentation de ces métriques dans un <em>dashboard</em> afin qu'elles soient lisibles et qu'il soit possible de voir leur évolution dans le temps.</li>
</ul>


<h2>Solution et mise en oeuvre</h2>

<p>Comme dit dans le paragraphe précédent, il convient au préalable de générer les métriques.</p>

<p>Du coté de YSlow, cela est facilement faisable en s'appuyant sur phantomjs.</p>

<p>Pour ce faire, il suffit de récupérer et d'installer le binaire de <a href="http://phantomjs.org/">phantomjs</a>. Il reste ensuite à récupérer le script yslow.js puis d'exécuter la commande suivante :</p>

<p><code>bash
/opt/phantomjs/bin/phantomjs yslow.js &lt;url page&gt;
</code></p>

<p><img src="http://2.bp.blogspot.com/-YmCjl2Qldg8/UXgB31zhtoI/AAAAAAAAA5U/P79Nn3j6Pvo/s1600/01-yslow_cmd2.png" alt="medium" /></p>

<p>Il est également possible de s'appuyer sur <a href="http://nodejs.org/">nodejs</a> mais l'opération devient alors un peu plus compliqué : il faut d'abord installer nodejs puis yslow avant de pouvoir lancer la génération du rapport en passant par la génération d'un fichier HAR (<a href="http://httparchive.org/index.php">HTTP ARchive</a>) :</p>

<p><code>bash
sudo /opt/nodejs/bin/npm install yslow -g
/opt/phantomjs/bin/phantomjs /opt/phantomjs/examples/netsniff.js  &lt;url page&gt; | yslow
</code>
<img src="http://2.bp.blogspot.com/-gD-DFJtuChI/UXgBG-wifGI/AAAAAAAAA5M/2M1bFUsavqc/s1600/01-yslow_cmd.png" alt="medium" /></p>

<p> Coté génération du rapport Pagespeed, trois pistes ont été étudiées :</p>

<ul>
<li>la première en utilisant un <a href="https://github.com/pauly/pagespeed">module nodejs</a>,</li>
<li>la deuxième en compilant Pagespeed directement depuis le <a href="https://code.google.com/p/page-speed/">site de google</a>,</li>
<li>la troisième en s'appuyant sur un <a href="https://code.google.com/p/harstorage/downloads/list">binaire déjà compilé</a> trouvé sur le site de <a href="https://code.google.com/p/harstorage/">HarStorage</a>.</li>
</ul>


<p>Les deux premières solutions se sont malheureusement avérées être un échec : en effet, concernant le module nodejs, il s'est avéré être incompatible à l'installation avec la version courante de nodejs (0.10.4). Or une version antérieure se trouvait être incompatible avec le module YSlow&hellip; (j'avoue ne pas m'être amusé à tester toutes les versions de nodejs et j'ai donc laissé cette piste de coté).</p>

<p>Du coté de la deuxième piste, je n'ai malheureusement pas réussi à la faire compiler&hellip; :&lsquo;( et cela malgré moultes tentatives sur les versions 1.7, 1.8 et 1.9 sur mon système Linux (Ubuntu 12.10) mais également sur un système disposant de XUbuntu 11.10. Cette piste a donc également été abandonnée&hellip;</p>

<p>La troisième tentative a, heureusement, été plus concluante. Ainsi, après téléchargement du binaire, il est possible, en lui fournissant un fichier HAR (générable, par exemple, à l'aide du module netsniff de phantomjs), de générer nos métriques PageSpeed :</p>

<p><code>bash
/opt/phantomjs/bin/phantomjs /opt/phantomjs/examples/netsniff.js  &lt;url page&gt; &gt; monhar.har
./pagespeed_bin --input_file monhar.har
</code></p>

<p><img src="http://3.bp.blogspot.com/-EPCoFg22lhA/UXhTkX7iPOI/AAAAAAAAA5k/mHf-dyeVctI/s1600/01-pagespeed_cmd.png" alt="medium" /></p>

<p> La génération des rapports ayant été effectuée, l'étape suivante pour répondre à notre cahier des charges consiste à remonter nos métriques récoltées par YSlow dans un outils un peu plus agréable.</p>

<p>Pour ce faire, le plugin <a href="https://wiki.jenkins-ci.org/display/JENKINS/TAP+Plugin">TAP</a> (<em>Test Anything Protocol</em>) de Jenkins a été utilisé. Ainsi, combiné avec l'exécution de récupération de la métrique, cela permet d'avoir au sein de Jenkins un job dédié à la génération de cette dernière et à son affichage, la gestion de l'historisation étant déléguée à l'historique du job.</p>

<p>Cependant, YSlow ne prenant en entrée qu'une url, un job doit être créé pour chaque page ciblée.</p>

<p><img src="http://2.bp.blogspot.com/-FEOYf1dOdCA/UXhXRxIT9SI/AAAAAAAAA50/iMrSJG1J3N4/s1600/01-tap.png" alt="medium" /></p>

<p><img src="http://2.bp.blogspot.com/-cFZAvtOQj0k/UXhX3xVuVUI/AAAAAAAAA58/9JNC8XhNsRo/s1600/01-tap1.png" alt="medium" /></p>

<p>Coté Pagespeed, j'avoue ne pas avoir cherché mais le chapitre suivant proposera une solution simple et efficace pour obtenir une visualisation et une historisation de ces métriques.</p>

<h2>Conclusion</h2>

<p>Comme on a pu le constater, la génération de métriques YSlow et/ou Pagespeed oblige (je n'ai pas trouvé d'autres moyens plus simples :&lsquo;( ) à passer par des frameworks tierces tels que phantomjs ou nodejs.</p>

<p>Pour le lecteur qui a su lire entre les lignes, il a pu constater qu'il y a deux approches possibles : soit passer par phantomjs (qui offre un navigateur headless) pour capturer la page rendu en déléguant au script de YSlow l'analyse de la page, soit passer par phantomjs pour générer un fichier HAR (qui contient, entre autre, les ressources chargées par la page ainsi que leur temps de récupération et le statut associé) puis de le passer à YSlow (via son module nodeJS) ou à PageSpeed.</p>

<p>En outre, du fait que les résultats obtenus l'ont été par page, pour un site complet, cela peut vite devenir&hellip; rébarbatif (pour rester poli)&hellip; pas glop&hellip;</p>

<h1>Vitesse de rendu</h1>

<h2>Contexte</h2>

<p>Dans la première partie, nous avons vu comment il était possible de générer des rapports d'exécution de bonnes pratiques d'une page HTML. Dans ce chapitre, nous nous intéresserons à la récupération de métriques de rendu d'une page au sens temps de récupération de ses différents éléments.</p>

<p><img src="http://2.bp.blogspot.com/-9lTF11FrC0M/UXhZk7aI6gI/AAAAAAAAA6g/0ei3KIbIxUQ/s1600/02-timeline_firefox.png" alt="medium" /></p>

<p><img src="http://2.bp.blogspot.com/-ImWAUCGEEIk/UXhZtgHULqI/AAAAAAAAA6o/RV8oNYSYBWg/s1600/01-timeline.png" alt="medium" /></p>

<p> Comme précédemment, le problème peut être décomposé en deux étapes :</p>

<ul>
<li>la génération du rapport,</li>
<li>sa représentation graphique pour une utilisation exploitable ainsi que son historisation.</li>
</ul>


<p>Pour la partie génération, plusieurs pistes ont été étudiées :</p>

<ul>
<li>utilisation de phantomjs et de son plugin loadpage,</li>
<li>utilisation de phantomjs et de son plugin netsniff (se trouvant dans le répertoire examples) pour générer un rapport HAR.</li>
</ul>


<p>Coté affichage et historisation, nous verrons que cela a, encore une fois, été un peu galère même si les résultats obtenus sont satisfaisant (ouf&hellip; heureusement).</p>

<h2>Solution et mise en oeuvre</h2>

<p>La première piste étudiée a été celle utilisant le plugin loadpage.js de phantomjs :
<code>bash
/opt/phantomjs/bin/phantomjs /opt/phantomjs/examples/loadspeed.js &lt;url page&gt;
</code></p>

<p><img src="http://2.bp.blogspot.com/-EnsolVkBftc/UXhYbNBGVSI/AAAAAAAAA6E/_gwMF7JBVnY/s1600/01-timeline-loadspeed.png" alt="medium" /></p>

<p> Cependant, ce plugin ne renvoie que le temps de chargement de la page et ne fournit pas un niveau de granulatité suffisante.</p>

<p>Le deuxième piste étudiée a été l'utilisation du plugin netsniff de phantomjs. Ce plugin permet de générer un fichier HAR (HTTP ARchive) qui contient l'ensemble des ressources chargées par la page ainsi que leur temps de chargement.</p>

<p><code>bash
/opt/phantomjs/bin/phantomjs /opt/phantomjs/examples/netsniff.js &lt;url page&gt; &gt; monFichier.har
</code></p>

<p> Cette solution semble satisfaisante. Ne reste plus qu'à afficher le fichier HAR dans un dashboard&hellip;</p>

<p>Coté affichage, deux approches ont été testées :</p>

<ul>
<li>HarViewer,</li>
<li>HarStorage.</li>
</ul>


<p><a href="https://github.com/jarib/har">HarViewer</a> est un visualisateur de fichiers HAR. Il s'agit d'un programme ruby et demande donc une installation de ce dernier.</p>

<p><img src="http://4.bp.blogspot.com/-U2Ki3STxZYM/UXhZ7TQPV6I/AAAAAAAAA6w/UbXv2iVxqVU/s1600/01-timeline-har1.png" alt="medium" /></p>

<p> Cependant, il ne permet pas de suivre l'évolution d'une page dans le temps (pas de fonctionnalité d'historisation ni de comparaison)&hellip; dommage&hellip;</p>

<p>Du coté de <a href="https://code.google.com/p/harstorage/">HarStorage</a>, son <a href="https://code.google.com/p/harstorage/wiki/Installation">installation</a> demande de nombreux autres composants (MongoDB, Python, &hellip;). Cependant, il offre une interface web par laquelle il est possible d'uploader ses fichiers HAR et, ainsi, d'en obtenir un stockage et donc, une historisation. Cerise sur la gateau, il offre également (modulo quelques manipulations) une génération et une visualisation des métriques PageSpeed.</p>

<p><img src="http://1.bp.blogspot.com/-m9UWNizIcgQ/UXhaHh19BQI/AAAAAAAAA64/JDn7UAs0O_4/s1600/01-timeline-harstorage1.png" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-1H5GqfbNF6Y/UXhaP7dQSjI/AAAAAAAAA7A/0Mq75mOVQ74/s1600/01-timeline-harstorage2.png" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-bCcDJ9DDRLU/UXhaP-REdGI/AAAAAAAAA7E/4SbClht1xao/s1600/01-timeline-harstorage3.png" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-xPHq6jh2V8A/UXhaQU3VcHI/AAAAAAAAA7I/8tyx8vKdB_4/s1600/01-timeline-harstorage4.png" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-3MDuvu3M7y8/UXhaQ4KpF0I/AAAAAAAAA7M/LzB4r9hRU98/s1600/01-timeline-harstorage5.png" alt="medium" /></p>

<h2>Conclusion</h2>

<p>On a vu dans ce chapitre comment il était possible de générer et de visualiser des timeline de rendu de pages HTML. La solution HarStorage me semble, dans le cadre d'une phase d'industrialisation, la solution la plus aboutie en permettant de conserver un historique pour évaluer l'évolution de la page tout en fournissant un moyen de visualiser les métriques de PageSpeed (chose qui n'avait, pour rappel, pas été abordé dans le chapitre précédent).</p>

<p>Cependant, on a pu constater qu'il était nécessaire de faire pas mal d'actions : génération d'un fichier HAR puis upload manuel dans HarStorage ou exécution manuel de HarViewer.</p>

<p>En outre, le même constat peut être fait que pour le chapitre précédent : les résultats obtenus l'ont été par page&hellip; pas glop&hellip;</p>

<h1>Automatisation totale</h1>

<h2>Contexte</h2>

<p>On a vu dans les chapitres précédent comment générer des rapports au format HAR via phantomjs. Cependant, dans le cas où des tests d'acceptance sont déjà mis en place sur le projet via, par exemple, Selenium et Cucumber JVM, il peut être judicieux de se servir de l'existant pour intégrer la génération des rapports ainsi que la remonté de ces dernières dans l'outils de DashBoard.</p>

<p>Cela permet ainsi de faire une pierre deux coups, mais également d'éviter les étapes manuelles ou d'avoir à maintenir des jobs jenkins un peu trop techniques.</p>

<h2>Solution et mise en oeuvre</h2>

<p>Comme annoncé précédemment, l'objectif de ce chapitre est d'étudier la faisabilité d'intégration de la génération de rapport HAR et leur upload dans HarStorage avec notre trio <a href="http://blog.jetoile.fr/2013/04/fluentlenium-et-cucumber-jvm-complement.html">Cucumber JVM/FluentLenium/Selenium</a>.</p>

<p>En fait, il est possible d'automatiser la génération d'un rapport HAR à travers Selenium (et donc FluentLenium) en utilisant un proxy. Pour ce faire deux approches sont possibles :</p>

<ul>
<li>utiliser le proxy <a href="http://opensource.webmetrics.com/browsermob-proxy/">BrowserMobProxy</a> de manière autonome,</li>
<li>utiliser le proxy BrowserMobProxy de manière programmatique.</li>
</ul>


<p>La partie upload au sein de HarStorage peut également être faite à l'aide des API Rest offertes par HarStorage.</p>

<p>Pour la première piste, je ne m'étendrai pas dessus puisque la solution est directement accessible sur le <a href="https://code.google.com/p/harstorage/wiki/JavaTutorial">site de HarStorage</a>. Il est juste important de noter que cette dernière nécessite d'avoir préalablement récupérer le proxy BrowserMobProxy en le compilant si nécessaire via un coup de mvn package -Preleasse (l'assembly se trouve branché au profil release) et de l'avoir lancé avec un port d'écoute donné, port qui est nommé PROXY_API_PORT dans le code :</p>

<p><code>bash
./bin/browsermob-proxy --port 9090
</code></p>

<p> En effet, BrowserMobProxy se comporte comme un serveur de proxy qu'il est possible de créer et d'enregistrer dynamiquement. Dans le code, la variable de classe PROXY_PORT correspond au port du proxy réel qui sera créé au sein du server BrowserMobProxy exécuté sur le port indiqué par PROXY_API_PORT. La classe fournit n'a pour rôle que d'interagir avec le serveur BrowserMobProxy au travers de son API REST (création d'un proxy, création et récupération du HAR).</p>

<p>La deuxième approche consiste, quant à elle, à créer ce serveur programmatiquement puis à lui demander l'instanciation d'un proxy Selenium (il n'y a donc pas besoin de récupérer le serveur BrowerMobProxy).</p>

<p>```java
ProxyServer server = new ProxyServer(Integer.valueOf(PROXY_API_PORT));
   server.start();</p>

<p>   // Change browser settings
   Proxy proxy = server.seleniumProxy();</p>

<p>   ////////////////////////////////////////////////
   // ip a renseigner soit manuellement soit en utilisant NetworkInterface
   ////////////////////////////////////////////////
   String ip = &ldquo;&rdquo;;
   proxy.setHttpProxy(ip + &ldquo;:&rdquo; + PROXY_API_PORT);
   proxy.setHttpProxy(ip + &ldquo;:&rdquo; + PROXY_API_PORT);</p>

<p>   DesiredCapabilities capabilities = new DesiredCapabilities();
   capabilities.setCapability(CapabilityType.PROXY, proxy);</p>

<p>   Driver firefoxDriver = new FirefoxDriver(capabilities)</p>

<p>   server.newHar(name);</p>

<p>   ////////////////////////////////////////////////
   // ma navigation via selenium avec le driver
   ////////////////////////////////////////////////</p>

<p>   // Read data from container
   Har har = server.getHar();</p>

<p>   String strFilePath = &ldquo;target/selenium_report.har&rdquo;;
   File file = new File(strFilePath);
   if (file.exists()) {</p>

<pre><code>   file.delete();  
</code></pre>

<p>   }
   FileOutputStream fos = new FileOutputStream(file);
   har.writeTo(fos);
   server.stop();</p>

<p>   InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(file) );
   LineNumberReader lineNumberReader = new LineNumberReader(inputStreamReader);
   String ligne;
   String res = &ldquo;&rdquo;;
   while ((ligne = lineNumberReader.readLine()) != null) {</p>

<pre><code>       res += ligne;
</code></pre>

<p>   }</p>

<p>   // Send results to HAR Storage
   try {</p>

<pre><code>   HarStorage hs = new HarStorage(HARSTORAGE_HOST, Integer.toString(HARSTORAGE_PORT));

   String response = hs.save(res);
   System.out.println(response);
</code></pre>

<p>   } catch (Exception e) {</p>

<pre><code>   e.printStackTrace();
</code></pre>

<p>   }
```</p>

<p>Par contre, il semble que le driver de phantomjs ne fonctionne pas&hellip; dommage&hellip;</p>

<p>Bien sûr, cela est parfaitement intégrable à ce qui a été fait dans mon article précédent (ie. via Cucumber JVM et FluentLenium), ce qui permet d'obtenir une feature Cucumber JVM du type :</p>

<p>```text
Feature: harstorage</p>

<p>  Scenario Outline: har browser navigation:</p>

<pre><code>Given I connect on url http://127.0.0.1:8080 with different browsers and I register the HarStorage Server on 127.0.0.1:5000 with name test:
  | &lt;browser&gt; | &lt;parameters&gt; | &lt;host&gt; | &lt;version&gt; | &lt;platform&gt; |
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
Then I send har files to the HarStorage Server
Then drivers are closed
</code></pre>

<p>  Examples:</p>

<pre><code>| browser | parameters | host | version | platform |
| firefox |            | none |         |          |
</code></pre>

<h1>| firefox |            | <a href="http://10.147.2.83:4444/wd/hub">http://10.147.2.83:4444/wd/hub</a> |         | win7     |</h1>

<p>```</p>

<h2>Conclusion</h2>

<p>On a vu dans ce paragraphe qu'il était aisé d'intégrer la génération et l'upload d'un fichier HAR issu d'un scénario fonctionnel dans HarStorage.</p>

<p>Cependant, ce mécanisme ne fonctionne malheureusement pas avec phantomjs, ce qui peut forcer à l'utilisation de Selenium Server (à noter que cela n'a pas été testé avec d'autres driver que Firefox).</p>

<p>Enfin, un point essentiel à noter est que par cette méthode, le temps d'exécution du javascript n'est pas remonté dans la timeline. En effet, l'utilisation d'un proxy ne fournit pas cette information alors qu'avec une génération direct d'un fichier HAR via phantomjs, cette donnée est bien présente.</p>

<h1>Conclusion</h1>

<p>Cet article a montré (enfin je l'espère&hellip;) comment il était possible d'automatiser la génération de métrique de rendu des pages HTML  dans une usine logicielle .</p>

<p>C'est vrai que de nombreuses technologies/manipulations sont nécessaires alors qu'il existe de nombreux(?) services qui rendent le même service (<a href="http://gtmetrix.com/">GTMetrix</a>, <a href="http://www.webpagetest.org/compare">WebPageSpeed</a>, &hellip;).</p>

<p>Malheureusement, ces services ne sont généralement branchées qu'en production (pas d'accès aux serveurs de tests/intégrations des entreprises) alors que les avoir au plus tôt dans le cycle de développement permettrait de minimiser les risques de régression et surtout de pousser à avoir une meilleure qualité telle que nous le permet Sonar.</p>

<p>Je tiens tout de même à préciser que j'ai été déçu de ne pas trouver une solution plus simple d'intégration de ces outils dans nos usines de développement.</p>

<p>Cela pourrait s'expliquer par un manque de maturité de l'environnement Java pour faire du Web 2.0 (sic) ou par une mutation du métier de développeur web qui tendrait vers une meilleure qualité logicielle mais qui n'aurait pas encore assimilé/intégré toutes les contraintes induites par une usine logicielle telle que celles que l'on connait dans notre monde Java&hellip; enfin, en gros, il reste du boulot&hellip;</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li>YSlow : <a href="http://yslow.org">http://yslow.org</a></li>
<li><p>PageSpeed : <a href="https://code.google.com/p/page-speed">https://code.google.com/p/page-speed</a></p></li>
<li><p>HAR : <a href="http://www.softwareishard.com/blog/har-12-spec/">http://www.softwareishard.com/blog/har-12-spec/</a></p></li>
<li><p>HarViewer : <a href="https://github.com/jarib/har">https://github.com/jarib/har</a></p></li>
<li>HarStorage : <a href="https://code.google.com/p/harstorage/">https://code.google.com/p/harstorage/</a></li>
<li>BrowserMobProxy : <a href="http://opensource.webmetrics.com/browsermob-proxy/">http://opensource.webmetrics.com/browsermob-proxy/</a></li>
<li><p>Jenkins TAP Plugin : <a href="https://wiki.jenkins-ci.org/display/JENKINS/TAP+Plugin">https://wiki.jenkins-ci.org/display/JENKINS/TAP+Plugin</a></p></li>
<li><p>CucumberJVM : <a href="https://github.com/cucumber/cucumber-jvm">https://github.com/cucumber/cucumber-jvm</a></p></li>
<li>FluentLenium : <a href="https://github.com/FluentLenium/FluentLenium">https://github.com/FluentLenium/FluentLenium</a></li>
<li><p>Selenium : <a href="http://docs.seleniumhq.org/">http://docs.seleniumhq.org/</a></p></li>
<li><p>PhantomJS : <a href="http://phantomjs.org/">http://phantomjs.org/</a></p></li>
<li><p>NodeJS : <a href="http://nodejs.org/">http://nodejs.org/</a></p></li>
<li><p><a href="http://www.igvita.com/2012/08/28/web-performance-power-tool-http-archive-har/">http://www.igvita.com/2012/08/28/web-performance-power-tool-http-archive-har/</a></p></li>
<li><p><a href="http://fr.slideshare.net/watsonmw/performance-monitoring-in-a-day">http://fr.slideshare.net/watsonmw/performance-monitoring-in-a-day</a></p></li>
<li><p>code du POC : <a href="https://github.com/jetoile/fluentlenium-cucumber/tree/harStorage">https://github.com/jetoile/fluentlenium-cucumber/tree/harStorage</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FluentLenium et Cucumber JVM... complément et precision]]></title>
    <link href="https://blog.jetoile.fr/2013/04/fluentlenium-et-cucumber-jvm-complement.html"/>
    <updated>2013-04-11T21:38:54+02:00</updated>
    <id>https://blog.jetoile.fr/2013/04/fluentlenium-et-cucumber-jvm-complement</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-R3ORi15Ei3Y/UTmwoq5A2II/AAAAAAAAA3o/uaIMSSZlq38/s1600/logo.png" alt="left-small" /></p>

<p>Dans mon article précédent, j'avais tenté d'expliquer comment il était possible d'intégrer les frameworks <a href="https://github.com/cucumber/cucumber-jvm">Cucumber JVM</a> et <a href="http://docs.seleniumhq.org/">Selenium</a> au travers de <a href="https://github.com/FluentLenium/FluentLenium">FluentLenium</a>.</p>

<p>En effet, pour rappel, FluentLenium permettait d'abstraire Selenium en lui offrant une API plus <em>fluent</em> mais également en lui apportant nativement ce qu'il préconise, à savoir le <a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a>.</p>

<p>Pour ce faire, j'avais proposé d'utiliser la délégation de l'initialisation de FluentLenium à une classe tierce injectée via le mécanisme d'injection de Cucumber JVM.</p>

<p>Cependant, suite à discussion avec la créatrice de FluentLenium (à savoir <a href="https://twitter.com/mathildelemee">Mathilde</a>), on s'est rendu compte que l'axe utilisé était légèrement biaisé (même s'il fonctionnait&hellip;).</p>

<p>Cet article revient donc sur ce point en proposant une solution plus simple mais présentera également comment il est possible de tester le scénario Cucumber avec différents navigateurs et il y aura un petit mot sur l'utilisation de navigateurs déportés (via les RemoteWebDriver de Selenium 2).</p>

<p>Pour ce faire, il sera découpé en 3 parties qui couvriront des usecases différents se traduisant donc par des implémentations différentes :</p>

<ul>
<li>cas de tests pour un site simple,</li>
<li>cas de tests pour un site complet,</li>
<li>cas de tests multi-navigateurs pour un site complet.</li>
</ul>


<p>A noter que je ne reviendrai pas sur les principes des différents frameworks/concepts mais juste sur comment il est possible d'implémenter ces différents usecases.</p>

<p>A noter également que l'article précédent aurait pu être modifié mais qu'en raison du nombre important de changements, il était plus simple d'en initier un autre&hellip;</p>

<!-- more -->


<h1>Cas de tests pour un site simple</h1>

<h2>Présentation et proposition d'implémentation</h2>

<p>Ce premier cas d'usage couvre le cas : &ldquo;j'ai un site que je veux tester avec Cucumber JVM et l'ensemble des steps peut être réuni dans une seule et même classe.&rdquo;</p>

<p>Bon je vois déjà la levée de bouclier : pourquoi réunir toutes les steps dans une seule et même classe. En fait, la raison du pourquoi sera expliquée un peu plus tard dans le paragraphe <em>Limites</em> de ce chapitre donc patience&hellip; ;&ndash;)</p>

<p>Contrairement à la façon que j'avais présentée dans mon article précédent, il n'est pas obligatoire de déléguer la déclaration des pages <code>FluentPage</code> à une autre classe étendant <code>FluentTest</code>. En fait, il suffit juste de faire étendre la classe contenant les steps cucumber de <code>FluentAdapter</code>, d'y déclarer les pages et d'appeler dans la méthode annotée par @Before (celui de Cucumber JVM bien sûr) les méthode d'initialisation du contexte de FluentLenium.</p>

<p>Pour rappel, cette initialisation instancie le WebDriver utilisé par Selenium 2 mais également les pages (annotées par l'annotation <code>@Page</code>) présentes dans la classe courante (ou ses parentes) qui doit, au minimum, étendre de <code>FluentAdapter</code>. Cela se fait au travers des méthodes <code>initFluent()</code> et <code>initTest()</code>.</p>

<p>Le code est donc extrêmement simple puisqu'il suffit de faire quelque chose du style :</p>

<p>```java
import cucumber.api.java.After;
import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;
import org.fluentlenium.core.FluentAdapter;
import org.fluentlenium.core.annotation.Page;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;</p>

<p>import static org.fest.assertions.api.Assertions.assertThat;</p>

<p>public class SimpleStep extends FluentAdapter {</p>

<p> @Page
 BingPage page;</p>

<p> @Before
 public void before() {
  this.initFluent(new HtmlUnitDriver());
  this.initTest();
 }</p>

<p> @Given(value = &ldquo;j accede a bing&rdquo;)
 public void step1() {
  goTo(page);
 }</p>

<p> @When(value = &ldquo;je recherche ([^ ]*) &rdquo;)
 public void step2(String keyword) {
  fill(&ldquo;#sb_form_q&rdquo;).with(keyword);
  submit(&ldquo;#sb_form_go&rdquo;);
 }</p>

<p> @Then(value = &ldquo;le titre est ([^ ]*) &rdquo;)
 public void step3(String keyword) {
  assertThat(title()).contains(keyword);
 }</p>

<p> @After
 public void after(){
  this.quit();
 }
}
```</p>

<p>où BingPage est :</p>

<p>```java
import org.fluentlenium.core.FluentPage;</p>

<p>public class BingPage extends FluentPage {</p>

<p> @Override
 public String getUrl() {
  return &ldquo;<a href="http://www.bing.com">http://www.bing.com</a>&rdquo;;
 }
}
```</p>

<p>et la feature, la suivante :</p>

<p>```text
Feature: basic</p>

<p>  Scenario: scenar1</p>

<pre><code>Given j accede a bing
When je recherche toto
Then le titre est toto 
</code></pre>

<p>```</p>

<p>Il est intéressant de remarquer la simplicité de la chose (et rien à voir avec l'implémentation que j'avais proposé précédemment!).</p>

<p>A part cela, peu de choses à ajouter : le code parle de lui même&hellip;</p>

<h2>Limites</h2>

<p>On vient de voir comme il était simple de faire cohabiter FluentLenium et Cucumber JVM.</p>

<p>Bien sûr, il y a un mais&hellip; (ça serait trop simple sinon) : comme on peut le constater, actuellement, toutes les steps se trouvent être dans la même classe. Cependant, dans le cas d'un site web un peu plus complexe, il est courant et même encouragé de séparer les steps dans différentes classes.</p>

<p>Dans l'implémentation précédente, l'annotation <code>@Before</code> a été utilisée pour initialiser le contexte (et plus particulièrement le webDriver et les pages pour ensuite injecter le webDriver dans ces dernières).</p>

<p>Cependant, dans le cas où les steps se trouvent être dans plusieurs classes, cela pose potentiellement un problème.</p>

<p>En effet, Cucumber JVM instancie la classe qui contient la définition de la step dès qu'il en a besoin et appelle la méthode annotée par <code>@Before</code> à l'instanciation de cette classe. Ainsi, dans notre cas, si les steps s'étaient trouvées dans deux classes, chacune étendant <code>FluentAdapter</code> et appelant <code>initFluent()</code> et <code>initTest()</code> dans la méthode annotée par @Before, alors cette instanciation aurait été faite deux fois et non une seule fois comme on aurait pu s'y attendre pour un même scénario donné&hellip;</p>

<p>Pire, les pages déclarées dans les classes n'auraient pas eu la même instance du webDriver et elles ne se seraient pas vu l'une l'autre&hellip;</p>

<p>Pas glop tout ça&hellip; :&lsquo;(</p>

<p>Ainsi, l'implémentation précédente fonctionne pour des cas &ldquo;simples&rdquo; mais si la partie test d’acceptante/intégration avait été plus complexe, alors cela aurait empêché la réutilisation et le découplage.</p>

<h1>Cas de tests pour un site complet</h1>

<h2>Présentation et proposition d'implémentation</h2>

<p>Il a été vu dans le paragraphe précédent qu'il pouvait être utile de disposer de plusieurs classes disposant des implémentations des fixtures.
Cependant, la question principale est de trouver comment il est possible de n'instancier qu'une seule fois par scénario le webDriver et de l'injecter dans des instances de pages propres au scénario.</p>

<p>La proposition présentée dans l'article précédent (modulo qu'il ne faut pas étendre de <code>FluentTest</code> mais de <code>FluentAdapter</code>) reste viable, mais il y a plus simple.</p>

<p>En effet, dans la proposition faite précédemment, la classe <code>FluentTestDelegator</code> avait à sa charge, à la fois la déclaration des pages, et l'instanciation et l'initialisation du contexte de FluentLenium. Pour rappel, cette instanciation/initialisation était réalisée par <a href="http://picocontainer.codehaus.org/">Pico Container</a> lors de l'injection de l'instance de cette classe dans la classe contenant les fixtures.</p>

<p>En fait, il est plus propre, d'un point de vue séparation des concepts, de laisser à cette classe le soin de proposer les fixtures d'initialisation du webDriver tout en séparant la déclaration des pages.</p>

<p>Cela peut être réalisé en créant une classe (<code>FluentPageInjector</code>) étendant de <code>FluentAdapter</code> qui définit les pages et de la faire étendre d'une classe (<code>FluentLeniumStepInitilizer</code>) qui définit les fixtures d'instanciation du webDriver.</p>

<p>Cela offre deux avantages : les classes qui définissent les steps de navigation n'ont qu'à étendre de <code>FluentPageInjector</code> pour avoir une visibilité sur les pages (tout en continuant d'injecter via pico l'instance de <code>FluentLeniumStepInitilizer</code>) et il devient alors possible de variabiliser le webDriver à utiliser.</p>

<p>```text
Feature: browser</p>

<p>  Scenario: navigation version firefox</p>

<pre><code>Given I connect on url http://localhost:8080 with firefox
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
And driver is closed
</code></pre>

<p>  Scenario: navigation version chrome</p>

<pre><code>Given I connect on url http://localhost:8080 with chrome with parameters webdriver.chrome.driver:/opt/chromedriver/chromedriver
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
And driver is closed
</code></pre>

<p>  Scenario: navigation version phantomjs</p>

<pre><code>Given I connect on url http://localhost:8080 with phantomjs with parameters phantomjs.binary.path:/opt/phantomjs-1.9.0-linux-x86_64/bin/phantomjs 
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
And driver is closed
</code></pre>

<p>```</p>

<br/>


<p>```java
package step;</p>

<p>import org.fluentlenium.core.FluentAdapter;
import org.fluentlenium.core.annotation.Page;
import page.HomePage;
import page.ResultPage;</p>

<p>public class FluentPageInjector extends FluentAdapter {</p>

<pre><code>@Page
protected HomePage homePage;

@Page
protected ResultPage resultPage;
</code></pre>

<p>}
```</p>

<p>On remarque, comme dit plus haut, que cette classe n'a qu'un seul rôle qui est de déclarer les pages tout en étendant de <code>FluentAdapter</code>.</p>

<p>```java
public class HomePageStep extends FluentPageInjector {</p>

<pre><code> public HomePageStep(FluentLeniumStepInitilizer delegator) {
  this.homePage = delegator.homePage;
  this.resultPage = delegator.resultPage;
 }


 @Given("^j accede a la homePage$")
 public void j_accede_a_homePage() {
  goTo(homePage);
 }

 @Given("^je suis sur homePage$")
 public void je_suis_sur_homePage() {
  homePage.isAt();
 }

 @When("^je submit$")
 public void je_submit() throws Throwable {
  homePage.submit();
 }
</code></pre>

<p>}
```</p>

<br/>


<p>```java
public class ResultPageStep extends FluentPageInjector {</p>

<pre><code>public ResultPageStep(FluentLeniumStepInitilizer delegator) {
    this.resultPage = delegator.resultPage;
}

@When("^je suis sur la page result$")
public void je_suis_sur_la_page_result() throws Throwable {
    resultPage.isAt();
}
</code></pre>

<p>}
```</p>

<p>Ces classes correspondent aux classes qui définissent les fixtures. Elles étendent de <code>FluentPageInjector</code> de façon à pouvoir bénéficier de la visibilité sur les pages. Par contre, il est intéressant de constater que, dans son constructeur, la classe <code>FluentLeniumStepInitializer</code> est injecté via Pico Container. Cela permet d'affecter la valeur des pages.</p>

<p>```java
public class FluentLeniumStepInitilizer extends FluentPageInjector {</p>

<pre><code>@Given("^I connect on url ([^ ]*) with ([^ ]*) with parameters ([^ ]*)$")
public void browser_connect(String host, String browser, String parameters) {
    init(host, browser, parameters);
}

@Then("^drivers are closed")
public void close() {
    this.quit();
}

@After
public void afterClose() {
    this.quit();
}

private void init(String host, String browserName, String parametersLine) {
    Browser browser = null;

    DesiredCapabilities capabilities = new DesiredCapabilities();

    String[] parameters = parametersLine.slip(";");
    for (String parameter : parameters) {
        if (!parameter.isEmpty()) {
            String[] key_value = parameter.split(":");
            capabilities.setCapability(key_value[0], key_value[1]);
        }
    }

    browser = Browser.getBrowser(browserLine.get(0));
    capabilities.setBrowserName(browser.getName());

    initWebDriver(host, browserHost, browser, capabilities);
}

private void initWebDriver(String host, String browserHost, Browser browser, DesiredCapabilities capabilities) {
    Fluent fluent = null;
    WebDriver driver = null;
    if (browser != null) {
        driver = BrowserMapper.getDriver(browser, capabilities);
        fluent = this.initFluent(driver);
    }

    fluent.withDefaultUrl(host);
    this.initTest();
}
</code></pre>

<p>}
```</p>

<p>Cette classe étend par transitivité <code>FluentAdapter</code> et dispose donc de la visibilité sur les méthodes d'initialisation de <code>FluentLenium</code>. En outre, en étendant <code>FluentPageInjector</code> (qui étend de <code>FluentAdapter</code>), cela lui permet, à l'appel de <code>initTest()</code>, d'initialiser les pages.
Concernant l'initialisation des webDriver, cela est fait au niveau de la classe <code>BrowserMapper</code>.</p>

<p>```java
public enum Browser {</p>

<pre><code>HTMLUNIT("default"),
FIREFOX("firefox"),
CHROME("chrome"),
PHANTOMJS("phantomjs");

private String name;

Browser(String name) {
    this.name = name;
}

public String getName() {
    return this.name;
}

public static Browser getBrowser(String name) {
    for (Browser browser : values()) {
        if (browser.getName().equalsIgnoreCase(name)) {
            return browser;
        }
    }
    return HTMLUNIT;
}
</code></pre>

<p>}
```</p>

<br/>


<p>```java
import org.openqa.selenium.Capabilities;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;
import org.openqa.selenium.phantomjs.PhantomJSDriver;</p>

<p>import java.util.HashMap;
import java.util.Map;</p>

<p>public class BrowserMapper {
 private String name;</p>

<p> private static Map&lt;Browser, WebDriverLazyLoader> browserMapper = new HashMap&lt;Browser, WebDriverLazyLoader>();</p>

<p> static {
  browserMapper.put(Browser.CHROME, new WebDriverLazyLoader(ChromeDriver.class));
  browserMapper.put(Browser.FIREFOX, new WebDriverLazyLoader(FirefoxDriver.class));
  browserMapper.put(Browser.HTMLUNIT, new WebDriverLazyLoader(HtmlUnitDriver.class));
  browserMapper.put(Browser.PHANTOMJS, new WebDriverLazyLoader(PhantomJSDriver.class));
 }</p>

<p> public static WebDriver getDriver(Browser browser, Capabilities capabilities) {
  WebDriverLazyLoader webDriverLazyLoader = browserMapper.get(browser);
  if (webDriverLazyLoader != null) {</p>

<pre><code>        if (browser == Browser.PHANTOMJS) {
            return webDriverLazyLoader.getWebDriverClass(capabilities);

        } else if (browser == Browser.CHROME) {
            System.setProperty("webdriver.chrome.driver", (String) capabilities.getCapability("webdriver.chrome.driver"));
            return webDriverLazyLoader.getWebDriverClass(capabilities);

        } else {
            return webDriverLazyLoader.getWebDriverClass();
        }
</code></pre>

<p>  }
  return browserMapper.get(Browser.HTMLUNIT).getWebDriverClass();
 }
}
```</p>

<p>Cette classe permet de faire le pont avec les webDriver qu'il est possible d'utiliser. Cependant, la petite astuce consiste à instancier de manière &ldquo;Lazy&rdquo; ces derniers.</p>

<p>En effet, appeler le constructeur d'un webDriver l'instancie mais le démarre également (ie. que la fenêtre du navigateur s'ouvre réellement). Du coup, la petite classe présentée ci-dessous a été utilisée.</p>

<p>```java
import org.openqa.selenium.Capabilities;
import org.openqa.selenium.WebDriver;</p>

<p>class WebDriverLazyLoader {</p>

<pre><code>private Class webDriverClass;


public WebDriverLazyLoader(Class webDriverClass) {
    this.webDriverClass = webDriverClass;
}

public WebDriver getWebDriverClass() {
    try {
        return (WebDriver)this.webDriverClass.newInstance();
    } catch (ReflectiveOperationException e) {
        e.printStackTrace();
    }
    return null;
}

public WebDriver getWebDriverClass(Capabilities capabilities) {
    try {
        return (WebDriver)this.webDriverClass.getConstructor(Capabilities.class).newInstance(capabilities);
    } catch (ReflectiveOperationException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>}
```</p>

<h2>Limites</h2>

<p>Comme on a pu le voir dans ce chapitre, il est aisé de partager les fixtures Cucumber JVM dans des classes différentes tout en bénéficiant de FluentLenium.</p>

<p>Cependant, pour certains besoins, il peut être utile de vouloir lancer les tests d'acceptance/intégration sur différents navigateurs.</p>

<p>Bien sûr, chaque step pourrait boucler sur l'ensemble des navigateurs sur lesquels les tests doivent être exécutés, mais cela induirait des problématiques d'entrelacement des actions et donc soulèverait des problématiques comme la gestion d'un contexte par webDriver, l'accès à un rapport &ldquo;illisible&rdquo; ou un manque de contrôle sur les préconditions du test qui sont, généralement, lié au scénario et non à une Step.</p>

<p>Le chapitre suivant tentera de répondre à cette problématique en proposant un moyen de &ldquo;boucler&rdquo; sur le scénario avec différents navigateurs.</p>

<h1>Cas de tests multi-navigateurs pour un site complet</h1>

<h2>Présentation et proposition d'implémentation</h2>

<p>Il a été vu dans le chapitre précédent comment il était possible d'exécuter des tests d'acceptances/intégration sur un navigateur donné.</p>

<p>Ce chapitre présentera, pour sa part, une façon de les lancer sur différents navigateurs sans avoir à faire de copier/coller ;&ndash;).</p>

<p>En fait, Cucumber JVM permet nativement de boucler sur un scénario en utilisant différents paramètres. Cela se fait par le mécanisme de <code>scenario outline</code>.</p>

<p>```text</p>

<p>Feature: multibrowser</p>

<p>  Scenario Outline: multi browser navigation version 1:</p>

<pre><code>Given I connect on url http://localhost:8080 with &lt;browser&gt; with parameters &lt;parameters&gt;
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
And driver is closed
</code></pre>

<p>  Examples:</p>

<pre><code>| browser | parameters                                             | 
| firefox |                                                        | 
| default |                                                        | 
| chrome  | webdriver.chrome.driver:/opt/chromedriver/chromedriver | 
</code></pre>

<p>```</p>

<p>Et&hellip; c'est tout!</p>

<p>Le code n'a pas à être modifié : Cucumber JVM s'occupe de tout! ;&ndash;)</p>

<h2>Limites</h2>

<p>On a vu dans le paragraphe précédent comment il était possible d'exécuter facilement des tests d'acceptance/intégration en s'appuyant sur la notion de scénario outline offerte nativement par Cucumber JVM.</p>

<p>Coté limitation, je n'en vois pas trop&hellip;</p>

<p>Peut être le fait de ne pas instancier le webDriver pour chaque scénario (opération assez coûteuse en temps) mais cela est aisément résolvable en utilisant une sorte de cache de webDriver fonctionnant sur le principe de singleton qui serait réinialisé lors de l'appel à la step drivers are closed qui serait isolée dans son propre <code>scenario outline</code> :</p>

<p>```text
  Scenario Outline: browsers are closed:</p>

<pre><code>Then driver is closed
</code></pre>

<p>  Examples:</p>

<pre><code>| browser   | parameters                                                            | 
| firefox   |                                                                       | 
| default   |                                                                       | 
| phantomjs | phantomjs.binary.path:/opt/phantomjs-1.9.0-linux-x86_64/bin/phantomjs | 
| chrome    | webdriver.chrome.driver:/opt/chromedriver/chromedriver                |     
</code></pre>

<p>```</p>

<h1>Conclusion</h1>

<p>Il a été présenté dans cet article comment il était possible d'implémenter l'intégration de Cucumber JVM et de Selenium à l'aide de FluentLenium.</p>

<p>Cet article n'a, cependant, pas fait mention de l'exécution des tests sur des navigateurs distants via les <strong>RemoteWebDriver</strong> mais cela est tout à fait possible (même si le code montré ici ne le présente pas) et est même totalement fonctionnel : pour ce faire (code disponible <a href="https://github.com/jetoile/fluentlenium-cucumber/tree/multiNav">ici</a>), il suffit de fournir, entre autre, des paramètres supplémentaires comme l'url de connexion au hub Selenium et d'instancier un <code>RemoteWebDriver</code> plutôt que le webDriver.</p>

<p>De même, le code permettant d'instancier à la mode singleton les webDriver est disponible <a href="https://github.com/jetoile/fluentlenium-cucumber/blob/multiNav/src/test/java/step/FluentLeniumStepInitilizer.java">ici</a> (voir la méthode <code>initCachedWebDriver()</code> de la classe <code>FluentLeniumStepInitilizer</code>).</p>

<p>Enfin, un dernier mot sur la façon dont il est possible d'exécuter tout ce beau monde (comme ça, je réponds à la remarque très pertinente de <a href="https://twitter.com/josepaumard">José</a> ;&ndash;) ) parce que faire des tests, c'est bien, les jouer, c'est mieux!</p>

<p>Il est possible de jouer les tests d'au moins trois manières distinctes : une orienté &ldquo;vraie vie&rdquo; (ie. utilisable au sein d'un build maven et donc exécutable via une usine d'intégration continue) et deux autres plutôt orientés développement.</p>

<p>Ainsi, pour jouer les tests via maven, il suffit de le déclarer dans le <code>pom.xml</code> le plugin failsafe en le branchant sur la &ldquo;bonne phase&rdquo;, à savoir le runner Cucumber JVM :</p>

<p>```xml
<plugin></p>

<pre><code>&lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;goals&gt;
            &lt;goal&gt;integration-test&lt;/goal&gt;
            &lt;goal&gt;verify&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;
    &lt;includes&gt;
        &lt;include&gt;**/BasicRunner.java&lt;/include&gt;
    &lt;/includes&gt;
&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<p>Coté jouabilité des tests sur un environnement de développement  il est possible d'exécuter le <strong>Runner</strong> Cucumber JVM directement (comme lors de l'exécution d'une classe de test unitaire) ou d'utiliser le plugin Cucumber JVM proposé par notre IDE préféré (pour moi IntelliJ, pour les autres, je ne sais pas&hellip;).</p>

<p>```java
import cucumber.api.junit.Cucumber;
import org.junit.runner.RunWith;</p>

<p>@RunWith(Cucumber.class)
@Cucumber.Options(features = &ldquo;classpath:fr/jetoile/webapp/acceptance&rdquo;, format = {&ldquo;pretty&rdquo;, &ldquo;html:target/cucumber&rdquo;, &ldquo;json:target/cucumber.json&rdquo;})
public class RunCucumberFeatures {
}
```</p>

<p><img src="http://4.bp.blogspot.com/-RGW7oSAChOQ/UWXmqPsYh6I/AAAAAAAAA4Y/cDH-YyVcpgs/s1600/screenshot01.png" alt="medium" /></p>

<br/>


<p><img src="http://3.bp.blogspot.com/-FkF8ZO6r6co/UWXnUNjqjII/AAAAAAAAA4g/obtSC7BS6kI/s1600/screenshot02.png" alt="medium" /></p>

<p>Enfin, pour rappel, mon usecase étant de tester mon application web en boite noire, un prérequis était que mon application web soit démarrée au préalable.</p>

<p>Pour ce faire, le plugin maven Jetty (ou Tomcat au choix) a été utilisé et branché sur la phase de pré-integration.</p>

<p>Lors de l'exécution des tests en mode développement (ie. en les lançant comme un TU ou à l'aide du plugin Cucumber JVM via l'IDE), un profil n'exécutant pas le plugin failsafe mais uniquement le démarrage du jetty/tomcat embarqué a été utilisé.</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li>article sur les limitations de Cucumber JVM pour le partage de données entre steps : <a href="http://zsoltfabok.com/blog/2012/09/cucumber-jvm-hooks/">http://zsoltfabok.com/blog/2012/09/cucumber-jvm-hooks/</a></li>
<li>page de fluentLenium : <a href="https://github.com/FluentLenium/FluentLenium">https://github.com/FluentLenium/FluentLenium</a></li>
<li>page des webDriver de Selenium : <a href="http://docs.seleniumhq.org/docs/03_webdriver.jsp">http://docs.seleniumhq.org/docs/03_webdriver.jsp</a></li>
<li>code : <a href="http://github.com/jetoile/fluentlenium-cucumber/">http://github.com/jetoile/fluentlenium-cucumber/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FluentLenium et Cucumber JVM sont sur un bateau...]]></title>
    <link href="https://blog.jetoile.fr/2013/03/fluentlenium-et-cucumber-jvm-sont-sur.html"/>
    <updated>2013-03-14T16:39:36+01:00</updated>
    <id>https://blog.jetoile.fr/2013/03/fluentlenium-et-cucumber-jvm-sont-sur</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-R3ORi15Ei3Y/UTmwoq5A2II/AAAAAAAAA3o/uaIMSSZlq38/s1600/logo.png" alt="left-small" /></p>

<p>Dans un <a href="/2013/03/demarrer-une-webapp-en-mode-embedded.html">article précédent</a>, j'avais abordé comment il était possible de démarrer une application web dans un conteneur de Servlet de manière embedded au sein de la phase integration de Maven. Bien sûr, cela n'a pas été fait que pour l'exercice de style et il y avait une petite idée derrière : pouvoir exécuter des tests d'acceptance en mode boite noire sur l'application.</p>

<p>Pour faire les tests d'acceptance, le choix de Cucumber JVM a été fait afin de permettre l'expression de tests d'acceptance avec une sémantique utilisant le pattern <strong>Given/When/Then</strong> mais également afin de permettre à des non développeurs de comprendre/écrire les scénarii de test à exécuter.</p>

<p>L'application à tester étant une application web, un besoin s'est fait sentir de tester la partie rendue. Dans cet article, lorsque l'on parlera de tester la partie rendue, il sera question de vérifier que l'élément recherché se trouve bien dans le document html remonté dans le navigateur web. Pour rappel (cf. le paragraphe Contexte de ce <a href="2013/03/demarrer-une-webapp-en-mode-embedded.html">post</a>), l'application testée s'appuie sur un framework web java de type Struts2.</p>

<p>Aussi, il ne sera pas question, ici, de tester le rendu dans différents navigateurs.</p>

<p>Il a été décidé de partir sur une solution s'appuyant sur un runtime à base de Selenium : en effet, un besoin latent étant, à terme, de tester le rendu de l'application web sur les différents navigateurs, cette solution semblait correspondre le mieux aux besoins.</p>

<p>Bref, passons ce besoin pour revenir à notre objectif premier, à savoir, vérifier la présence des éléments dans l'arbre DOM remonté par l'application web.</p>

<p>Pour résumer, il a été décidé de partir sur :</p>

<ul>
<li>Cucumber JVM pour la partie représentation/écriture des scénarii,</li>
<li>Selenium pour la partie exécution des tests.</li>
</ul>


<p>Cependant, la syntaxe sur la partie WebDriver de Selenium 2 étant assez verbeuse, il a été décidé d'utiliser le framework FluentLenium qui offre une API plus simple et plus naturelle (enfin plus fluent quoi! ;&ndash;) ). En outre, en plus d'une API plus facile d'utilisation, la notion native de Page de FluentLenium poussant à mieux découpler la représentation d'une page et son test, cela a joué en sa faveur ;&ndash;)</p>

<p>Ainsi, cet article présentera comment il a été possible d'intégrer Cucumber JVM avec FluentLenium afin de pouvoir faire tourner des tests avec Selenium.</p>

<p>A noter que je ne m'attarderai pas, dans cet article, à présenter exhaustivement les différents protagonistes mais seulement les quelques points qu'il est nécessaires de connaitre afin d'intégrer ensemble ces différents framework.</p>

<p>[update] Suite à discussion avec la créatrice de FluentLenium, un autre article a été initié et apporte de nombreux compléments mais également correction à cet article. Pour en savoir, plus, rendez vous <a href="/2013/04/fluentlenium-et-cucumber-jvm-complement.html">ici</a>&hellip;</p>

<!-- more -->


<h1>Présentation des protagonistes</h1>

<h2>Cucumber JVM</h2>

<p><img src="http://2.bp.blogspot.com/-vb7zd_BqITk/UTmwyd4yWsI/AAAAAAAAA3w/tYVxH4hxlig/s1600/cucumber2.jpg" alt="center" /></p>

<p><a href="https://github.com/cucumber/cucumber-jvm">Cucumber JVM</a> est un fork Java de <a href="http://cukes.info/">Cucumber</a> inialement développé en Ruby.</p>

<p>Tout comme <a href="http://jbehave.org/">JBehave</a>, il est orienté BDD (<em>Behaviour Driven Development</em>) et il permet d'écrire ses <strong>scénarii</strong> de tests en suivant le pattern <strong>Given/When/Then</strong> qui correspond à déterminer un ensemble de <a href="https://github.com/cucumber/cucumber/wiki/Step-Definitions">Step</a>.</p>

<p>Ces scénarii s'écrivent dans des fichiers <strong>features</strong> qui sont lus par Cucumber JVM. Ce dernier se charge alors de faire correspondre les <strong>Steps</strong> avec les fixtures associés. Ces <strong>steps</strong> sont des méthodes Java annotées par :</p>

<ul>
<li>@Given(value = &ldquo;&rdquo;)</li>
<li>@When(value = &ldquo;&rdquo;)</li>
<li>@Then(value = &ldquo;&rdquo;)</li>
</ul>


<p>A noter que seule la valeur de l'annotation est utilisée par Cucumber JVM.</p>

<p>Alors que les steps à la sémantique Given permettront de poser les conditions nécessaires à l'exécution du scénario, les steps When exécuteront l'action à tester et les steps Then testeront que tout s'est bien passé en utilisant le framework d'assertion de son choix tels que JUnit, Fest-assert et/ou Harmcrest.</p>

<p>A noter également que pour passer un état d'une Step à une autre, Cucumber JVM nous oblige à stocker ces derniers dans des variables de classe ou à passer par son mécanisme d'injection à l'aide de framework IoC tels que <a href="http://picocontainer.codehaus.org/">Picocontainer</a>.</p>

<p>Ainsi, on peut résumer grossièrement en disant qu'un scénario est écrit dans un fichier <strong>feature</strong> et est composé d'un ensemble de Step qui sont associés à des méthodes qui correspondent aux différentes <strong>fixtures</strong>.</p>

<p>Pour plus d'informations sur le BDD, je vous renvoie sur un <a href="http://blog.soat.fr/2011/06/breizhcamp-behaviour-driven-development-par-olivier-billard-et-thierry-henrio/">compte rendu</a> d'une présentation d'Olivier Billard et de Thierry Henrio réalisé au BreizhCamp que j'avais fait à l'époque.</p>

<h2>Selenium 2</h2>

<p><img src="http://4.bp.blogspot.com/-xOJkyRycXEU/UTmxGd1a-nI/AAAAAAAAA4A/kMPuTOc5tpY/s1600/big-logo.png" alt="center" /></p>

<p>Dans notre cas d'usage, il y a assez peu de chose à dire sur <a href="http://docs.seleniumhq.org/">Selenium</a> si ce n'est qu'il permet, en fournissant différents <strong>WebDriver</strong>, de tester le rendu d'une page HTML en simulant différentes actions telles que le submit de formulaires, le clique d'un bouton et en allant chercher différents éléments dans la page rendue.</p>

<p>Il propose différentes implémentations de WebDriver tels que <strong>FirefoxDriver</strong> ou <strong>HtmlUnitDriver</strong>.</p>

<p>Selenium offre également la possibilité d'exécuter les navigateurs qu'il lance sur différentes machines via Selenium Server mais, dans notre cas, cette fonctionnalité ne sera pas utile. De même, il ne sera pas abordé la partie Selenium IDE qui est peu exploitable car difficilement maintenable. En effet, il est courant et même fortement recommandé de séparer, pour des raisons évidentes, les scénarii à tester du rendu de la page (par exemple en utilisant le <a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a>).</p>

<p>Les liens suivants détaillent plus précisément ces différents points :</p>

<ul>
<li><a href="http://fr.slideshare.net/MathildeLemee/selenium-testng-selenium-grid-best-practices">http://fr.slideshare.net/MathildeLemee/selenium-testng-selenium-grid-best-practices</a></li>
<li><a href="http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-api-commands-and-operations">http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-api-commands-and-operations</a></li>
</ul>


<h2>FluentLenium</h2>

<p><img src="http://1.bp.blogspot.com/-fyH1CNEBvIw/UTmxNk5WZTI/AAAAAAAAA4I/obgbEW5Ae6w/s1600/code.png" alt="center" /></p>

<p><a href="https://github.com/FluentLenium/FluentLenium">FluentLenium</a> est un framework utilisant Selenium mais proposant une API plus simple et plus naturelle que celle offerte par ce dernier.</p>

<p>Il a été pensé pour s'intégrer à des tests exécutés avec JUnit ou TestNG et se charge donc d'initialiser le <strong>WebDriver</strong> Selenium à chaque fois qu'il exécute un test.</p>

<p>Pour ce faire, il utilise, au moment de l'écriture de ces lignes, le mécanisme de <strong>Rule</strong> JUnit qui fait, grosso modo, comme le @Before de JUnit mais qui peut être partagé entre les différentes classes de test.</p>

<p>En outre, FluentLenium s'appuie sur la notion de <strong>FluentPage</strong> et de <strong>FluentTest</strong>. En fait, pour faire simple, les classes de tests doivent étendre FluentTest, ce qui permet à toutes les méthodes annotées par @Test d'initialiser le WebDriver Selenium. La classe peut, de plus, bénéficier des méthodes portées par FluentTest.</p>

<p>La notion de FluentPage permet, quant à elle, de représenter une page (au sens HTML). Cette implémentation du <a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a> incite ainsi l'utilisateur à découpler le test du contenu de la page qui sera alors la seule à être garante du rendu.</p>

<p>Enfin, via l'annotation <strong>Page</strong>, les classes qui étendent FluentPage peuvent être injectées directement dans l'implémentation du FluentTest. Les liens suivants détaillent plus précisément ces différents points :</p>

<ul>
<li><a href="http://fr.slideshare.net/MathildeLemee/fluentlenium">http://fr.slideshare.net/MathildeLemee/fluentlenium</a></li>
<li><a href="https://github.com/FluentLenium/FluentLenium">https://github.com/FluentLenium/FluentLenium</a></li>
</ul>


<h1>Etude sur la mise en oeuvre</h1>

<p>On a vu dans le paragraphe précédent quelques-unes des notions nécessaires à l'intégration de nos trois comparses.</p>

<p>Cependant, il est intéressant de noter que Cucumber JVM et FluentLenium s'appuient sur deux paradigmes potentiellement opposés. En effet, alors que Cucumber JVM dispose d'une représentation par Step formalisé par des méthodes java, FluentLenium propose une granularité par méthode.</p>

<p>En outre, deux points sont primordiaux :</p>

<ul>
<li>FluentLenium s'appuie sur la notion de Rule JUnit pour instancier, démarrer puis stopper le webDriver,</li>
<li>Cucumber JVM ne supporte pas la <a href="https://github.com/cucumber/cucumber-jvm/issues/393">notion de Rule</a> et refuse tout autre Runner différent que le sien.</li>
</ul>


<p>Bien sûr, on peut se douter qu'il est possible de contourner le problème sinon cet article serait un peu mensongé&hellip; ;&ndash;)</p>

<p>En fait, la solution qui a été mise en place pour faire fonctionner conjointement ces deux framework est assez simple : faire que les classes déclarant les <strong>Steps</strong> Cucumber JVM délèguent à une classe étendant FluentTest les différentes actions et vérifications.</p>

<p>Cette classe pourra porter les différentes pages (au sens FluentLenium) et devra exposer les méthodes adéquates qui initialiseront et arrêteront le webDriver cible (méthodes fournies par FluentTest).</p>

<p>A titre informatif, le fait d'utiliser l'<em>Autocloseable</em> (et plus précisément le <em>try-with-resources</em>) de Java 7 s'est traduit par un échec puisque le driver doit rester actif entre les différentes Steps.</p>

<p>De même, essayer d'injecter via Picocontainer les pages ne fonctionne pas car, à ce jour, l'implémentation même de FluentLenium fait que les annotations @Page qui permettent d'initialiser et d'instancier les <strong>FluentPages</strong> doivent être dans une implémentation de <strong>FluentTest</strong>.</p>

<p>Ainsi, cela pourrait se traduire par le code suivant :</p>

<p><code>HomePageStep.java</code></p>

<p>```java
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;
import org.fest.assertions.fluentlenium.FluentLeniumAssertions;</p>

<p>public class HomePageStep {</p>

<pre><code>private FluentTestDelegator fluentLeniumDelegate;

/**
 * injection par pico donc pas besoin d'initialiser le driver (deja fait par le delegator)
 * @param fluentLeniumDelegate
 */
public HomePageStep(FluentTestDelegator fluentLeniumDelegate) {
    this.fluentLeniumDelegate = fluentLeniumDelegate;
}

@When(value = "I go on home page")
public void homePageIsDisplayed() {
        fluentLeniumDelegate.goTo(fluentLeniumDelegate.homePage).await().untilPage();
}

@Then(value = "home page is displayed")
public void homePageIsDisplayed() {
    FluentLeniumAssertions.assertThat(fluentLeniumDelegate.homePage).isAt();
}

@When(value = "I submit the form")
public void submitForm() {
    fluentLeniumDelegate.homePage.submit();
}
</code></pre>

<p>}
```</p>

<p><code>ResultPageStep.java</code></p>

<p>```java
public class ResultPageStep {</p>

<pre><code>private FluentTestDelegator fluentLeniumDelegate;

/**
 * injection par pico donc pas besoin d'initialiser le driver (deja fait par le delegator)
 * @param fluentLeniumDelegate
 */
public ResultPageStep(FluentTestDelegator fluentLeniumDelegate) {
    this.fluentLeniumDelegate = fluentLeniumDelegate;
}

@Then(value = "I am on result page")
public void isOnPage() {
    FluentLeniumAssertions.assertThat(fluentLeniumDelegate.resultPage).isAt();
}
</code></pre>

<p>}
```</p>

<p><code>CommonStep.java</code>
```java
import cucumber.api.java.en.When;</p>

<p>public class CommonStep {</p>

<pre><code>private FluentTestDelegator fluentLeniumDelegate;

public StepHelper(FluentTestDelegator fluentLeniumDelegate) {
    this.fluentLeniumDelegate = fluentLeniumDelegate;
}

@When(value = "I stop my driver")
public void webDrivercloser() {
    fluentLeniumDelegate.close();
}
</code></pre>

<p>}
```</p>

<p><code>FluentTestDelegator.java</code>
```java
import cucumber.api.java.en.When;
import org.fluentlenium.adapter.FluentTest;
import org.fluentlenium.core.annotation.Page;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;
import org.openqa.selenium.remote.DesiredCapabilities;</p>

<p>import java.io.File;
import java.io.IOException;</p>

<p>public class FluentTestDelegator extends FluentTest implements AutoCloseable {</p>

<pre><code>@Page
public HomePage homePage;

@Page
public ResultPage resultPage;

public FluentTestDelegator() throws IOException {
    init();
}

/**
* Appel des operations faites par le Rule Junit de FluentTest
*/
public void init() throws IOException {
    initFluent(new HtmlUnitDriver()).withDefaultUrl("http://localhost:9090");
</code></pre>

<p>//        initFluent(getDefaultDriver()).withDefaultUrl(&ldquo;<a href="http://localhost:9090">http://localhost:9090</a>&rdquo;);</p>

<pre><code>    initTest();
    setDefaultConfig();
}

@Override
public void close() {
    if (getDriver() != null) {
        quit();
    }
}
</code></pre>

<p>}
```</p>

<p><code>HomePage.jave</code>
```java
import cucumber.api.DataTable;
import org.fluentlenium.core.FluentPage;
import org.fluentlenium.core.domain.FluentList;
import org.fluentlenium.core.domain.FluentWebElement;</p>

<p>import java.util.List;</p>

<p>import static org.fest.assertions.Assertions.assertThat;
import static org.fluentlenium.core.filter.FilterConstructor.withText;
import static org.junit.Assert.assertEquals;</p>

<p>public class HomePage extends FluentPage {</p>

<pre><code>@Override
public String getUrl() {
    return "/webapp/home";
}

@Override
public void isAt() {
    assertThat(title()).containsIgnoringCase("homePage");
}

public void submit() {
    submit("#searchForm &gt; form").await().untilPage();
}
</code></pre>

<p>}
```</p>

<p><code>ResultPage.java</code>
```java
public class ResultPage extends FluentPage {</p>

<pre><code>@Override
public String getUrl() {
    return "/webapp/result";
}

@Override
public void isAt() {
    assertThat(title()).containsIgnoringCase("resultPage");
}
</code></pre>

<p>}
```</p>

<p><code>scenario1.feature</code>
```text</p>

<h1>encoding: iso-8859-1</h1>

<p>Feature: homepage test</p>

<p>  Scenario: homePage should be displayed</p>

<pre><code>When I go on home page
Then home page is displayed
Then I stop my driver
</code></pre>

<p>  Scenario: a submit on homePage should redirect to resultPage</p>

<pre><code>When I go on home page
And I submit the form
Then I am on result page
Then I stop my driver
</code></pre>

<p>```</p>

<p>On constate que le code est un peu plus verbeux que ce qu'on aurait souhaité avoir mais cela fonctionne sans soucis.
A noter que via la méthode init de <strong>FluentTestDelegator</strong>, il est possible de préciser le <strong>webDriver</strong> à utiliser (dans notre cas, HtmlUnitDriver).</p>

<h1>Mise en oeuvre</h1>

<p>On a vu dans le paragraphe précédent comment il était possible de faire fonctionner conjointement Cucumber JVM et FluentLenium.</p>

<p>Du coup, il n'y a plus grand chose à rajouter dans ce paragraphe si ce n'est la configuration de notre chef d'orchestre (à savoir Maven) qui a été utilisé pour faire fonctionner tout ce beau monde&hellip; ;&ndash;)</p>

<p>```xml</p>

<pre><code>&lt;dependencies&gt;        
    &lt;dependency&gt;
        &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
        &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;
        &lt;version&gt;1.3&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;batik&lt;/groupId&gt;
        &lt;artifactId&gt;batik-ext&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;        
    &lt;!-- pas de montee de version de junit pour cause de conflit avec hamcrest --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
                &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;info.cukes&lt;/groupId&gt;
        &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;info.cukes&lt;/groupId&gt;
        &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;info.cukes&lt;/groupId&gt;
        &lt;artifactId&gt;cucumber-picocontainer&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;
        &lt;artifactId&gt;fluentlenium-festassert&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;junit&lt;/groupId&gt;
                &lt;artifactId&gt;junit-dep&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.easytesting&lt;/groupId&gt;
        &lt;artifactId&gt;fest-assert&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>  <build>
   <plugins></p>

<pre><code>                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
                    &lt;executions&gt;
                        &lt;execution&gt;
                            &lt;goals&gt;
                                &lt;goal&gt;integration-test&lt;/goal&gt;
                                &lt;goal&gt;verify&lt;/goal&gt;
                            &lt;/goals&gt;
                        &lt;/execution&gt;
                    &lt;/executions&gt;
                    &lt;configuration&gt;
                        &lt;includes&gt;
                            &lt;include&gt;**/RunCucumberFeatures.java&lt;/include&gt;
                        &lt;/includes&gt;
                    &lt;/configuration&gt;
                &lt;/plugin&gt;

    &lt;/plugins&gt;             
</code></pre>

<p>  </build> <br/>
```</p>

<p>```java
import cucumber.api.junit.Cucumber;
import org.junit.runner.RunWith;</p>

<p>@RunWith(Cucumber.class)
@Cucumber.Options(features = &ldquo;classpath:fr/jetoile/webapp/acceptance&rdquo;, format = {&ldquo;pretty&rdquo;, &ldquo;html:target/cucumber&rdquo;, &ldquo;json:target/cucumber.json&rdquo;})
public class RunCucumberFeatures {
}
```</p>

<h1>Conclusion</h1>

<p>On a vu dans cet article (qui est la suite logique d'un <a href="/2013/03/demarrer-une-webapp-en-mode-embedded.html">article précédent</a>) comment il était possible de faire des tests d'acceptance en utilisant conjointement Cucumber JVM et FluentLenium.</p>

<p>A l'utilisation, cela s'avère agréable et rapide à écrire surtout avec quelques petits tweaks supplémentaires qui n'ont pas été exposés ici (profile Maven pour ne démarrer que le serveur embedded et exécution des scénarii Cucumber avec IntelliJ 12 avec possibilité de bénéficier du debugger que ce soit au niveau de l'exécution des tests (debugger ou utilisation d'un webDriver autre que HtmlUnitDriver) ou de l'application cible (via <code>mvnDebug</code>)).</p>

<p>Bref, en tout cas, même si la mise en oeuvre a été un peu galère, il a été possible de bénéficier du meilleur des deux framework sans avoir à se &ldquo;taper&rdquo; la lourdeux de Selenium&hellip; ;&ndash;).</p>

<p>Bien sûr, il est existe bien d'autres solutions mais je te laisse, précieux lecteur, le soin de les évaluer ;&ndash;)</p>
]]></content>
  </entry>
  
</feed>
