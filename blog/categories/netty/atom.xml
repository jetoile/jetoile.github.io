<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: netty | Jetoile]]></title>
  <link href="https://blog.jetoile.fr/blog/categories/netty/atom.xml" rel="self"/>
  <link href="https://blog.jetoile.fr/"/>
  <updated>2017-01-27T13:35:31+01:00</updated>
  <id>https://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty4 et Spring Integration : ils reviennent et ils ne sont pas content!]]></title>
    <link href="https://blog.jetoile.fr/2014/03/jaxrs-netty4-et-spring-integration-ils.html"/>
    <updated>2014-03-24T19:12:29+01:00</updated>
    <id>https://blog.jetoile.fr/2014/03/jaxrs-netty4-et-spring-integration-ils</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-XR47rmCwXK0/Ux8gpmR-TLI/AAAAAAAABR0/T1h_RtvDED0/s1600/resteasy_jolokia_metrics_orig3.png" alt="left-small" /></p>

<p>Pour faire suite à mes articles <a href="/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>, nous allons voir, dans cet article, comment il est possible de créer un service activator avec <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> qui exposera via resteasy-netty4 un service REST.</p>

<p>Ce service REST esposera simplement une opération en POST qui, via Spring Integration, écrira dans un fichier et qui, pour le fun, écrira également sur la console.</p>

<p>Pour ce faire, rien de plus simple, un <a href="http://www.eaipatterns.com/MessagingAdapter.html">Service Activator</a> de type <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">gateway</a> a été utilisé.</p>

<p>Cet article montrera donc comment il est possible d'intégrer Spring Integration à notre petite stack basé sur Resteasy-Netty4, Jackson, <a href="http://metrics.codahale.com/">Metrics</a>, <a href="https://helloreverb.com/developers/swagger">Swagger</a> et <a href="http://www.jolokia.org/">Jolokia</a>.</p>

<p>Le code se trouve sur Github <a href="https://github.com/jetoile/spring-integration-netty4">ici</a>.</p>

<!-- more -->


<h1>Présentation du usecase</h1>

<p>Le service qui est exposé est un service de type REST répondant à un appel de type POST et acceptant du JSON.</p>

<p>Il répondra à une requête de type :
<code>bash
curl -XPOST -H "Content-Type: application/json" -d '{"message": "hello", "time": "2014-03-05T10:55:39.835+01:00"}'  http://127.0.0.1:8081/sample/write
</code>
et écrira un fichier par requête reçue dans le répertoire <code>/tmp</code>. En outre, il loggera sur la console le message reçu.</p>

<p>Ainsi, avec la commande suivante, on devrait voir un incrément du nombre à chaque réception de message.
<code>bash
watch 'ls *.msg | wc -l'
</code></p>

<h1>Mise en oeuvre</h1>

<h2>Dépendances</h2>

<p>A titre informatif, les dépendances ainsi que leurs versions sont les suivantes (au format gradle) :
```text
dependencies {</p>

<pre><code>compile group: 'org.springframework.integration', name: 'spring-integration-core', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-jmx', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-http', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-file', version:'3.0.1.RELEASE'
compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-spring', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.ryantenney.metrics', name: 'metrics-spring', version:'3.0.0-RC4'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}
</code></pre>

<p>}
```</p>

<p>Pour le lecteur averti, il constatera que la version de Jackson utilisé ici est la 1 (ie. avec le groupId <strong>org.codehaus</strong>). En effet, Jackson 2 et JodaTime m'ont fait des misères et je n'ai pas réussi à les résoudre rapidement, donc, par flemme, je suis repassé en version 1&hellip; ;&ndash;)</p>

<h2>DTO</h2>

<p>Un DTO annoté JAX-B (compris par Jackson) sera utilisé pour représenter le JSON reçu dans le corps du POST.</p>

<p>Il se présente comme suit :
```java
@XmlRootElement
public class DtoRequest {</p>

<pre><code>private String message;
private DateTime time;

public String getMessage() { return message; }

public void setMessage(String message) { this.message = message; }

public DateTime getTime() { return time; }

public void setTime(DateTime time) { this.time = time; }

@Override
public String toString() {
    return "DtoRequest{" +
            "message='" + message + '\'' +
            ", time=" + time +
            '}';
}
</code></pre>

<p>}
```</p>

<p>Ici, la méthode <code>toString()</code> a été overridé car utilisé lors de l'affichage du message par le loggueur sur la console.</p>

<p>Jusque là, ça ne casse pas trois pattes à un canard ;&ndash;)</p>

<h2>Intégration complète de Spring Integration</h2>

<p>Pour rappel, Spring Integration est une implémentation des <a href="/2009/12/eip-quest-ce-que-cest.html">EIP</a> (<em>Enterprise Integration Patterns</em>) et propose donc une mise en oeuvre de l'architecture <strong>Pipes and Filters</strong>.</p>

<p><img src="http://3.bp.blogspot.com/-Pd_JIILTp_0/Ux8fIIRV-tI/AAAAAAAABRQ/hevpIqdQU4M/s1600/si-netty4-graph.png" alt="large" /></p>

<p>Au niveau écriture dans un répertoire, le <code>file-outbound-adapter</code> offert par Spring Integration sera utilisé :
```xml
file:outbound-channel-adapter id=&ldquo;fileAdapter&rdquo; auto-create-directory=&ldquo;true&rdquo;</p>

<pre><code>                                   directory="file:${out.directory}"
                                   channel="channel"/&gt;
</code></pre>

<p>```</p>

<p>Coté loggueur, ce sera le composant logging :
<code>xml
 &lt;int:logging-channel-adapter auto-startup="true" channel="channel" level="INFO" log-full-message="true"/&gt;
</code>
et où on aura un Pipe (channel) en mode <code>Publish-Subscribe</code> :
<code>xml
 &lt;int:publish-subscribe-channel id="channel"/&gt;
</code></p>

<p>Au niveau des namespaces et autres informations, on aura ce qui suit :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;
    &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
    &lt;property name="locations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/conf.properties&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
    &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
&lt;/bean&gt;

&lt;int-jmx:mbean-export default-domain="fr.jetoile.sample" server="mbeanServer"/&gt;

&lt;int:message-history/&gt;    
...
</code></pre>

<p></beans>
```</p>

<p>On y remarque la lecture du fichier de configuration, ainsi que les activations jmx adéquate afin d'avoir un peu d'informations ;&ndash;) Concernant l'élément message-history, cela permet de préciser à Spring Integration d'ajouter dans les headers du message (qui, pour rappel, transite via les Pipes entre les différents Filters) des informations de temps d'exécution.</p>

<p>En soit, il s'agit d'une configuration extrèmement simple pour toute personne connaissant un minimum Spring Integration, donc encore une fois, rien de compliqué&hellip; ;&ndash;)</p>

<h2>Gateway Spring Integration</h2>

<p>Afin de rentrer dans le vif du sujet, ce paragraphe montrera comment il est possible de transformer notre petit serveur Resteasy-Netty4 en une Gateway Spring Integration.</p>

<p>Pour ce faire, il suffit de définir une interface (NettyGateway) qui sera utilisée par Spring Integration.
Ci dessous un petit extract de la <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">documentation officielle</a> :</p>

<blockquote><p>Le rôle principale d'une Gateway est de chacher l'API de messaging fournit par Spring Integration. Cela permet à la logique business de l'application de s'abstraire complètement de l'API de Spring Integration et, en utilisant une Gateway générique, le code n'interagit qu'avec une simple interface.</p>

<p>&hellip;</p>

<p>En fait, Spring Integration fournit un GatewayProxyFactoryBean qui génère un proxy pour n'importe quelle interface et qui, en interne, invoque la méthode de la Gateway. Ainsi, en utilisant l'injection de dépendance, il est possible d'exposer l'interface aux méthodes business.</p></blockquote>

<p>```java
public interface NettyGateway {</p>

<pre><code>void send(DtoRequest msg);
</code></pre>

<p>}
```</p>

<p>Ainsi, notre service REST se présentera comme suit :
```java
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private NettyGateway messageProducer;

public void setGateway(NettyGateway messageProducer) {
    this.messageProducer = messageProducer;
}

@POST
@Path("/write")
@Consumes(MediaType.APPLICATION_JSON)
public Response write(DtoRequest message) {
    this.messageProducer.send(message);
    return Response.ok().build();
}
</code></pre>

<p>}
```</p>

<p>On y constatera que l'inteface NettyGateway lui a été injecté afin qu'il puisse servir de passe plat.</p>

<p>Coté Spring, la configuration est la suivante :
```xml
&lt;int:gateway id=&ldquo;nettyGateway&rdquo; service-interface=&ldquo;fr.jetoile.sample.gateway.NettyGateway&rdquo;</p>

<pre><code>             default-request-channel="channel"/&gt;
</code></pre>

<p><bean id="simpleService" class="fr.jetoile.sample.service.SimpleService"></p>

<pre><code>&lt;property name="gateway" ref="nettyGateway"/&gt;
</code></pre>

<p></bean>
<code>
Du coté de démarrage de notre serveur Resteasy-Netty4, cela ne sera, bien sûr, plus fait dans le `main()`, mais dans notre bean Spring à qui sera injectée notre classe implémentant notre service REST :
</code>xml
<bean id="nettyContainer" class="fr.jetoile.sample.gateway.NettyContainer"></p>

<pre><code>&lt;constructor-arg ref="simpleService"/&gt;
</code></pre>

<p></bean>
```</p>

<p>Avec :
```java
public class NettyContainer {</p>

<pre><code>private static final Logger LOGGER = LoggerFactory.getLogger(NettyContainer.class);

public static final String CONF_PROPERTIES = "conf.properties";

private static Configuration config;

private SimpleService simpleService;

public NettyContainer(SimpleService simpleService) {
    try {
        config = new PropertiesConfiguration(CONF_PROPERTIES);

    } catch (ConfigurationException e) {
        throw new IllegalArgumentException("bad config");
    }
    this.simpleService = simpleService;
    initServer();
}


private void initServer() {
    ResteasyDeployment deployment = new ResteasyDeployment();

    int nettyPort = 8081;

    if (config != null) {
        deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));
        deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));
        deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));
        deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));

        nettyPort = config.getInt("netty.port", TestPortProvider.getPort());
    } else {
        LOGGER.warn("is going to use default netty config");
    }

    deployment.setResources(Arrays.&lt;Object&gt;asList(simpleService));

    MyNettyJaxrsServer netty = new MyNettyJaxrsServer();

    netty.setDeployment(deployment);
    netty.setPort(nettyPort);
    netty.setRootResourcePath("");
    netty.setSecurityDomain(null);
    netty.start();
}
</code></pre>

<p>}
```</p>

<p>Et voilà&hellip; c'est tout!</p>

<p>Ne reste plus que la classe implémentant notre main() qui ne fera que charger le contexte spring :
```java
public class Client {</p>

<pre><code>public static void main(String[] args) throws ConfigurationException {
    new ClassPathXmlApplicationContext("springintegration-config.xml");
}
</code></pre>

<p>}
```</p>

<p>Juste un dernier point : le lecteur un peu concentré aura remarqué qu'il y a, ici, un petit meli melo dans la lecture des fichiers de configuration (parfois chargé par Spring, parfois chargé via commons-configuration). Je laisse cependant ces points en suspens et à la discrétion de la personne qui utilisera et lira cet article (ou qui aura atteint ce point&hellip;) (s'il y en a&hellip; ;&ndash;) ).</p>

<h2>Intégration de Metrics</h2>

<p>L'objectif de cet article étant de monter une stack &ldquo;presque complète&rdquo;, il est, bien sûr, primordial de fournir les bonnes métriques.</p>

<p>Comme dans mon article précédent, ce sera Metrics qui sera utilisé.</p>

<p>Cependant, alors que cela avait été fait programmatiquement, ce coup-ci, cela sera fait via Spring (parce que sinon ce n'est pas drôle&hellip; ;&ndash;) ).</p>

<p>Pour ce faire, c'est très simple, en tirant la dépendance <strong>&lsquo;com.ryantenney.metrics&rsquo;, name: &lsquo;metrics-spring&rsquo;, version:&lsquo;3.0.0-RC4&rsquo;</strong> au lieu de <strong>&lsquo;com.codahale.metrics&rsquo;, name: &lsquo;metrics-core&rsquo;</strong>, il ne reste qu'à ajouter à notre service REST l'annotation <code>@Timed</code> et d'ajouter dans la configuration Spring les éléments suivants :</p>

<p>```java
@POST
@Path(&ldquo;/write&rdquo;)
@Consumes(MediaType.APPLICATION_JSON)
@Timed
public Response write(DtoRequest message) {</p>

<pre><code>this.messageProducer.send(message);
return Response.ok().build();
</code></pre>

<p>}
```</p>

<p>Avec la configuration Spring suivante :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:metrics="http://www.ryantenney.com/schema/metrics"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd
              http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;

&lt;metrics:metric-registry id="metrics" /&gt;

&lt;metrics:annotation-driven metric-registry="metrics" /&gt;

&lt;metrics:reporter type="jmx" metric-registry="metrics" /&gt;
...
</code></pre>

<p></beans>
```</p>

<p>Pour montrer que je ne mens pas, on a donc (ici, utilisation de Hawt.io via Jolokia) :</p>

<p><img src="http://4.bp.blogspot.com/-CZebCZS47aE/Ux8fk-EwKQI/AAAAAAAABRY/C7OwMBMZNEc/s1600/si-hawtio-connextion.png" alt="medium" /></p>

<p><img src="http://2.bp.blogspot.com/-H-LmsIrivjA/Ux8fo7ORYpI/AAAAAAAABRg/EIp_-F6LzF4/s1600/si-hawtio-metrics.png" alt="medium" /></p>

<p>On constate encore une fois la simplicité de la chose!</p>

<h2>Intégration de Jolokia</h2>

<p>De même que pour notre paragraphe précédent, l'intégration de Jolokia se fera ici par configuration Spring plutôt que de manière programmatique.</p>

<p>Pour ce faire, il suffit de tirer la dépendance <strong>&lsquo;org.jolokia&rsquo;, name: &lsquo;jolokia-spring&rsquo;, version:&lsquo;1.1.2&rsquo;</strong> au lieu de <strong>&lsquo;org.jolokia&rsquo;, name: &lsquo;jolokia-jvm&rsquo;</strong>, et d'ajouter le bon bean à Spring :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:metrics="http://www.ryantenney.com/schema/metrics"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xmlns:jolokia="http://www.jolokia.org/jolokia-spring/schema/config"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd
              http://www.jolokia.org/jolokia-spring/schema/config http://www.jolokia.org/jolokia-spring/schema/config/jolokia-config.xsd
              http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;
    &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
    &lt;property name="locations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/conf.properties&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;jolokia:agent lookupConfig="true" systemPropertiesMode="never"&gt;
    &lt;jolokia:config
            autoStart="true"
            host="${jolokia.host}"
            port="${jolokia.port}"
            user="${jolokia.user}"
            password="${jolokia.password}"/&gt;
&lt;/jolokia:agent&gt;
...
</code></pre>

<p></beans>
```</p>

<p>Et&hellip; c'est tout&hellip; Jolokia est intégré à notre petite stack.</p>

<h2>Intégration de Swagger</h2>

<p>Concernant l'intégration de Swagger, cela ne diffère en rien de mon article précédent. Même problème de CORS, même hack&hellip;</p>

<p><img src="http://4.bp.blogspot.com/-ev6GX1U7SEs/Ux8fxhWTl_I/AAAAAAAABRo/srY62BOqZS4/s1600/si-swagger.png" alt="medium" /></p>

<h2>Branchement des plugins Maven Appassembler et Assembly</h2>

<p>De même que pour Swagger, rien à signaler de particulier par rapport à mon article précédent&hellip; cela fonctionne sans problème ;&ndash;)</p>

<h1>Conclusion</h1>

<p>En conclusion, on peut constater que l'intégration de Spring integration dans notre petite stack est tout aussi trivial que le reste!</p>

<p>Encore une fois, simple et efficace ;&ndash;)</p>

<p>Ainsi, on peut bénéficier du meilleur des deux mondes.</p>

<p>Bien sûr, on peut se poser la question de l'intérêt de brancher quelques choses de véloce (Netty) avec un framework succeptible d'entrainer un Overhead (spring integration) et qui serait, alors, le point de contension. La question est légitime mais je n'y répondrai pas&hellip; ;&ndash;) (pour bien faire, il faudrait faire un benchmark).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty 4, Jackon 2... les mêmes mais en mieux...]]></title>
    <link href="https://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html"/>
    <updated>2014-03-17T08:43:12+01:00</updated>
    <id>https://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais</id>
    <content type="html"><![CDATA[<p><img src="http://3.bp.blogspot.com/-Vzol1CndcjY/Uxib17Rlf2I/AAAAAAAABQI/Qi4u0DWe2s4/s1600/resteasy_jolokia_metrics.png" alt="left-small" /></p>

<p>Pour faire suite à mon <a href="/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">article précédent</a> qui montrait comment il était possible de construire une <em>stack</em> légère basée sur Resteasy-Netty3, Jackson, <a href="http://www.jolokia.org/">Jolokia</a> et <a href="https://helloreverb.com/developers/swagger">Swagger</a>, cet article montrera comment il est possible de faire la même chose avec Resteasy-Netty4 et Jackson 2.</p>

<p>Même si les changements ne sont pas énormes, il y a quand même quelques variantes, et, histoire d'être exhaustif, cela permet de faire le tour complet&hellip; ;&ndash;)</p>

<p>En fait, les seuls points qui diffèrent, par rapport au code précédent, touchent :</p>

<ul>
<li>les dépendances,</li>
<li>l'intégration de Resteasy-netty4,</li>
<li>l'intégration du JacksonConfig (changement d'API coté Jackson),</li>
<li>le support de JodaTime dans Jackson 2,</li>
<li>et le support du CORS dans Resteasy-Netty4.</li>
</ul>


<p>C'est donc ces différents points qui seront abordés dans cet article.</p>

<p>Le code se trouve sur github sur la branche <a href="https://github.com/jetoile/resteasy-netty-sample/tree/netty4">netty4</a>.</p>

<!-- more -->


<h1>Les Dépendances</h1>

<p>Les dépendances utilisées sont les suivantes (au format gradle) :
<code>text
compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson2-provider', version:'3.0.6.Final'
compile group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-joda', version:'2.3.2'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}
</code></p>

<p>On peut y constater depuis la version précédente que netty est passé en version <strong>4.0.17.Final</strong> mais également c'est maintenant l'artefact <strong>resteasy-netty4</strong> qui est utilisé plutôt que <strong>resteasy-netty</strong>. De la même manière, c'est maintenant l'artefact <strong>resteasy-jackson2-provider</strong> plutôt que <strong>resteasy-jackson-provider</strong>.</p>

<p>En outre l'artefact <strong>jackson-datatype-joda</strong> a été ajouté (nous y reviendrons ultérieurement).</p>

<h1>Intégration de Resteasy-netty4</h1>

<p>Afin de remplacer Resteasy-netty 3 par Resteasy-Netty4, il suffit de modifier les dépendances et de supprimer le hack fait précédemment concernant le CORS (ie. la classe <code>RequestHandler</code>) qui est incompatible avec cette nouvelle version.</p>

<p>Une fois cela fait, le programme devrait être de nouveau fonctionnel sans avoir à modifier quoique ce soit (modulo Swagger-UI mais nous y reviendrons ultérieurement.)</p>

<h1>Intégration de Jackson 2</h1>

<p>Comme il a été vu précédemment, c'est maintenant la version de Jackson 2 qui est utilisé plutôt que la 1.</p>

<p>Aussi, il est nécessaire de modifier les packages de Jackson importés : cela n'est à faire que dans la classe <code>JacksonConfig</code>.</p>

<p>Certaines des API ayant également évoluées, la classe <code>JacksonConfig</code> devient :
```java
public class JacksonConfig implements ContextResolver<ObjectMapper> {</p>

<pre><code>private final ObjectMapper objectMapper;

public JacksonConfig() {
    objectMapper = new ObjectMapper();
    objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
}

@Override
public ObjectMapper getContext(Class&lt;?&gt; objectType) {
    return objectMapper;
}
</code></pre>

<p>}
```</p>

<h1>Support de JodaTime dans Jackson 2</h1>

<p>On a vu dans le paragraphe précédent comment il fallait modifier notre code pour utiliser Jackson 2 à la place de Jackson 1.</p>

<p>Cependant, lors d'un :
<code>bash
curl -XGET http://localhost:8081/sample/say/hello
</code></p>

<p>On obtient :
```javascript
{</p>

<pre><code>"message": "hello",
"time": {
    "era": 1,
    "dayOfMonth": 6,
    "dayOfWeek": 4,
    "dayOfYear": 65,
    "weekyear": 2014,
    "weekOfWeekyear": 10,
    "monthOfYear": 3,
    "yearOfEra": 2014,
    "yearOfCentury": 14,
    "centuryOfEra": 20,
    "millisOfSecond": 173,
    "millisOfDay": 53370173,
    "secondOfMinute": 30,
    "secondOfDay": 53370,
    "minuteOfHour": 49,
    "minuteOfDay": 889,
    "hourOfDay": 14,
    "year": 2014,
    "zone": {
        "fixed": false,
        "uncachedZone": {
            "cachable": true,
            "fixed": false,
            "id": "Europe/Paris"
        },
        "id": "Europe/Paris"
    },
    "millis": 1394113770173,
    "chronology": {
        "zone": {
            "fixed": false,
            "uncachedZone": {
                "cachable": true,
                "fixed": false,
                "id": "Europe/Paris"
            },
            "id": "Europe/Paris"
        }
    },
    "afterNow": false,
    "beforeNow": false,
    "equalNow": true
}
</code></pre>

<p>}
```</p>

<p>Pour corriger cela, il suffit d'importer la dépendance <strong>&lsquo;com.fasterxml.jackson.datatype&rsquo;, name: &lsquo;jackson-datatype-joda&rsquo;</strong> et d'ajouter à l'<code>objectMapper</code> le module <code>JodaModule</code> :
<code>java
objectMapper = new ObjectMapper();
objectMapper.registerModule(new JodaModule());
objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  
</code></p>

<p>Ainsi, on obtient bien :
```javascript
{</p>

<pre><code>"message": "hello",
"time": "2014-03-06T13:53:38.714Z"
</code></pre>

<p>}
```</p>

<h1>Support du CORS dans Resteasy-Netty4</h1>

<p>Précédemment, avec Resteast-netty 3, nous avions remarqué un problème de CORS avec Swagger-UI.
Pour en venir à bout, un <em>hack</em> avait été fait mais ce n'était pas très propre&hellip;</p>

<p>Malheureusement, Resteasy-netty4 n'offre pas, non plus, de manière simple pour surmonter ce problème. Heureusement, en fouillant un peu sur internet, un <a href="http://stackoverflow.com/questions/18857546/implement-cross-origin-resource-sharing-cors-on-resteasy-netty-server">article</a> propose de rajouter un <code>ChannelInboundHandler</code> au <em>pipeline</em> Netty.</p>

<p>Cependant, je n'ai pas trouvé de moyen simple de le faire mis à part la surcharge de la méthode&hellip;</p>

<p>Le code obtenu est donc le suivant :</p>

<p>La classe <code>ChannedInboundHandler</code> :
```java
public class CorsHeadersChannelHandler extends SimpleChannelInboundHandler<NettyHttpRequest> {</p>

<pre><code>protected void channelRead0(ChannelHandlerContext ctx, NettyHttpRequest request) throws Exception {
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");

    ctx.fireChannelRead(request);
}
</code></pre>

<p>}
```</p>

<p>La surcharge de la méthode <code>start()</code> pour ajouter le <em>handler</em> au pipeline Netty (désolé pour le nom&hellip;) :</p>

<p>```java
public class MyNettyJaxrsServer extends NettyJaxrsServer {</p>

<pre><code>private EventLoopGroup eventLoopGroup;
private EventLoopGroup eventExecutor;
private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
private int executorThreadCount = 16;
private SSLContext sslContext;
private int maxRequestSize = 1024 * 1024 * 10;
private int backlog = 128;

@Override
public void setSSLContext(SSLContext sslContext) { this.sslContext = sslContext; }

@Override
public void setIoWorkerCount(int ioWorkerCount) { this.ioWorkerCount = ioWorkerCount; }

@Override
public void setExecutorThreadCount(int executorThreadCount) { this.executorThreadCount =  executorThreadCount; }

@Override
public void setMaxRequestSize(int maxRequestSize) { this.maxRequestSize  = maxRequestSize; }

public void setBacklog(int backlog) { this.backlog = backlog; }

@Override
public void start() {
    eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);
    eventExecutor = new NioEventLoopGroup(executorThreadCount);
    deployment.start();
    final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
    // Configure the server.
    if (sslContext == null) {
        bootstrap.group(eventLoopGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline().addLast(new HttpRequestDecoder());
                        ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
                        ch.pipeline().addLast(new HttpResponseEncoder());
                        ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTP));
                        ch.pipeline().addLast(new CorsHeadersChannelHandler());
                        ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
                        ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
                    }
                })
                .option(ChannelOption.SO_BACKLOG, backlog)
                .childOption(ChannelOption.SO_KEEPALIVE, true);
    } else {
        final SSLEngine engine = sslContext.createSSLEngine();
        engine.setUseClientMode(false);
        bootstrap.group(eventLoopGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline().addFirst(new SslHandler(engine));
                        ch.pipeline().addLast(new HttpRequestDecoder());
                        ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
                        ch.pipeline().addLast(new HttpResponseEncoder());
                        ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTPS));
                        ch.pipeline().addLast(new CorsHeadersChannelHandler());
                        ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
                        ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
                    }
                })
                .option(ChannelOption.SO_BACKLOG, backlog)
                .childOption(ChannelOption.SO_KEEPALIVE, true);
    }
    bootstrap.bind(port).syncUninterruptibly();
}
</code></pre>

<p>}
```</p>

<p>On y observe le rajout du <em>handler</em> :
<code>java
ch.pipeline().addLast(new CorsHeadersChannelHandler());
</code></p>

<p>Enfin, l'initialisation du serveur Resteasy-netty :
<code>java
MyNettyJaxrsServer netty = new MyNettyJaxrsServer();
</code></p>

<h1>Conclusion</h1>

<p>On a vu, dans cet article, comment il était possible d'intégrer JAX-RS avec Netty 4 à l'aide de Resteasy tout en ayant une intégration de Jackson 2.</p>

<p>On a également montré qu'il était possible d'y intégrer très simplement Swagger et Jolokia.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty et bien plus encore... mode d'emploi...]]></title>
    <link href="https://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html"/>
    <updated>2014-03-10T08:03:49+01:00</updated>
    <id>https://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode</id>
    <content type="html"><![CDATA[<p><img src="http://1.bp.blogspot.com/-HYBTn5anFdE/Uxdv3cRgu_I/AAAAAAAABP4/gsCZjUIxDyQ/s1600/resteasy_jolokia_metrics.png" alt="left-small" /></p>

<p>L'informatique évolue constamment et c'est également le cas des architectures qui ont tendance à s'orienter de plus en plus vers l'utilisation de services REST. Ces services REST doivent, en outre, être de plus en plus véloces afin de pouvoir répondre à une charge de plus en plus forte (que ce soit d'un point de vue temps de réponse mais également d'un point de vue charge suportée). C'est dans ce contexte que des solutions comme <a href="http://restlet.org/">Restlet</a> ou <a href="http://restx.io/">RestX</a> (pour n'en citer que quelques-unes) ont vu le jour.</p>

<p>En effet, en plus d'offrir la possibilité de servir des services REST, elles s'appuient sur des framework dont la particularité est d'offrir des traitements non bloquant sur les entrées/sorties (NIO).</p>

<p>C'est dans ce contexte que cet article parlera principalement de Resteasy-Netty 3 (la version 3 a été utilisé en raison de contraintes techniques (connexion à <a href="http://cassandra.apache.org/">Apache Cassandra</a> dont le <a href="https://github.com/datastax/java-driver">driver</a> utilise Netty 3)).</p>

<p>Cependant, ce ne sera pas le seul protagoniste car, comme on verra par la suite, il est très simple à utiliser&hellip;</p>

<p>Le vrai sujet de cet article est, en fait, comment il a été possible d'ajouter d'autres framework comme Swagger ou Jolokia à Resteasy-Netty 3.</p>

<p>Cet article sera découpé en deux parties :</p>

<ul>
<li>Besoin et conception</li>
<li>Mise en oeuvre</li>
</ul>


<p>Le code se trouve sur Github <a href="https://github.com/jetoile/resteasy-netty-sample">ici</a>.</p>

<!-- more -->


<h1>Besoin et conception</h1>

<p>Le besoin était d'offrir un ensemble de services REST qui devait être suffisamment véloce pour répondre au besoin de performance en terme de charge mais également en terme de temps de réponse.</p>

<p>Venant du monde Java et plus précisément de Java EE, il aurait été pertinent de partir sur une solution classique à base de <a href="https://jcp.org/en/jsr/detail?id=311">JAX-RS</a> (<a href="https://jersey.java.net/">Jersey</a> ou <a href="http://www.jboss.org/resteasy">RestEasy</a>) hébergée par un <a href="http://tomcat.apache.org/">Tomcat</a> ou un <a href="http://www.eclipse.org/jetty/">Jetty</a>.</p>

<p>Cependant, une crainte était que le mode de fonctionnement des Servlets soit limitant concernant les entrées/sorties. Bien sûr, il était possible d'utiliser le connecteur NIO de Tomcat mais ce n'est pas cette solution qui a été retenue&hellip; ;&ndash;)</p>

<p>Suite à la lecture de l'excellent <a href="http://blog.xebia.fr/2011/11/09/java-nio-et-framework-web-haute-performance/">article</a> sur le retour d'expérience de <a href="https://twitter.com/slemesle">Séven</a> et de <a href="https://twitter.com/julienBuret">Julien</a> lors du challenge USI 2011, le choix a été fait de partir sur une solution basée sur <a href="http://netty.io/">Netty</a>.</p>

<p>Par contre, développer des services directement sur Netty était embêtant et risquait surtout de rebuter l'équipe de développement. De la même manière, introduire un nouveau framework disposant de ses propres API n'était pas préconisé (NDLR : les standards c'est bien ! ;&ndash;) ).</p>

<p>C'est pour cette raison qu'il était préférable de trouver une solution alliant à la fois les avantages de NIO (et si possible s'appuyant sur Netty) et de JAX-RS.</p>

<p>Ainsi, il a été décidé de partir sur Resteasy-Netty 3 qui semblait offrir le meilleur des deux mondes (je dis &ldquo;semblais&rdquo; car aucun comparatif en charge des différents protagonistes n'a été réalisé et les résultats obtenus ont été suffisamment satisfaisant pour n'avoir pas à pousser plus loin l'expérimentation).</p>

<p>L'un des autres avantages de n'avoir pas utiliser un conteneur de Servlet classique était qu'il permettait de rendre le livrable auto-porteur et légé (il aurait bien sûr été possible d'embarquer un Tomcat ou Jetty embedded ou de &ldquo;s'embeddé&rdquo; dans un Tomcat via le goal exec-war de Tomcat7-maven-plugin).</p>

<p>Bien sûr, l'application devait être administrable et supervisable.</p>

<p>Enfin, cerise sur le gateau, intégrer une solution comme <a href="https://helloreverb.com/developers/swagger">Swagger</a> pour documenter les API REST était un <em>&ldquo;nice to have&rdquo;</em>.</p>

<p>Pour notre cas d'exemple, le seul service exposé sera le classique service qui répète ce qu'on lui demande&hellip;</p>

<p>Il répondra donc à une requête de type GET du type :
<code>http://localhost:8081/sample/say/&lt;message&gt;</code></p>

<p>Du coté de la réponse, elle aura la forme suivante :
```javascript
{</p>

<pre><code>"message": &lt;message&gt;,
"time": "2014-03-05T10:55:39.835+01:00"
</code></pre>

<p>}
```</p>

<p>La date de la réponse sera ajoutée juste pour le &ldquo;fun&rdquo; ;&ndash;)</p>

<h1>Mise en oeuvre</h1>

<p>A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :
<code>text
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'
compile group: 'org.codehaus.jackson', name: 'jackson-core-asl', version:'1.9.13'
compile group: 'org.codehaus.jackson', name: 'jackson-mapper-asl', version:'1.9.13'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') { exclude(module: 'jsr305') }
</code></p>

<h2>Implémentation du service REST</h2>

<p>Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial&hellip; et la classe ci-dessous fait humblement l'affaire :</p>

<p>```java
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);

@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortDataSet(@PathParam("msg") String message) {
    DtoResponse response = new DtoResponse();
    try {
        response.setMessage(message);
        response.setTime(DateTime.now());
    } catch (Exception e) {
        log.error("internal error: {}", e);
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
    return Response.ok(response).build();
}
</code></pre>

<p>}
```</p>

<p>Du coté de l'objet retourné par la réponse au format JSON, Jackson intégré à Resteasy a été utilisé pour la partie marshalling/unmarshalling.</p>

<p>Coté gestion des dates, ce sera JodaTime (l'application tourne avec Java 7).</p>

<p>Du coup, un objet DTO a été écrit et annoté à l'aide d'annotations JAXB :</p>

<p>```java
@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
private DateTime time;

public DtoResponse() {}

public String getMessage() { return message;}

public void setMessage(String message) { this.message = message; }

public DateTime getTime() { return time; }

public void setTime(DateTime time) { this.time = time; }
</code></pre>

<p>}
```</p>

<h2>Mise en oeuvre de Resteasy-Netty 3</h2>

<p>Mettre en place Resteasy-Netty 3 est très simple, d'après la <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/pdf/resteasy-reference-guide-en-US.pdf">documnentation</a>, il suffit de faire :</p>

<p><code>java
public static void start(ResteasyDeployment deployment) throws Exception {
  netty = new NettyJaxrsServer();
  netty.setDeployment(deployment);
  netty.setPort(TestPortProvider.getPort());
  netty.setRootResourcePath("");
  netty.setSecurityDomain(null);
  netty.start();
 }
</code></p>

<p>et c'est donc ce que l'on va faire&hellip; ;&ndash;)</p>

<p><a href="http://commons.apache.org/proper/commons-configuration/">Apache commons-configuration</a> a été utilisé afin de déporter la configuration dans un fichier <em>properties</em>.</p>

<p>```java
public class Client {</p>

<pre><code>private final static Logger LOGGER = LoggerFactory.getLogger(Client.class);
private static final String CONF_PROPERTIES = "conf.properties";
private static Configuration config;

public static void main(String[] args) throws ConfigurationException, BootstrapException {
    try {
        config = new PropertiesConfiguration(CONF_PROPERTIES);
    } catch (ConfigurationException e) {
        throw new BootstrapException("bad config", e);
    }
    initServer();
}

private static void initServer() {
    SimpleService service = new SimpleService();
    ResteasyDeployment deployment = new ResteasyDeployment();

    int nettyPort = 8081;

    if (config != null) {
        deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));
        deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));
        deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));
        deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));

        nettyPort = config.getInt("netty.port", TestPortProvider.getPort());
    } else {
        LOGGER.warn("is going to use default netty config");
    }

    deployment.setResources(Arrays.&lt;Object&gt;asList(service));

    NettyJaxrsServer netty = new NettyJaxrsServer();
    netty.setDeployment(deployment);
    netty.setPort(nettyPort);
    netty.setRootResourcePath("");
    netty.setSecurityDomain(null);
    netty.start();
}    
</code></pre>

<p>}
```</p>

<p>On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <code>setResources()</code> sur l'instance de <code>ResteasyDeployment</code> fournit au serveur <strong>NettyJaxrs</strong> :</p>

<p><code>java
SimpleService service = new SimpleService();
ResteasyDeployment deployment = new ResteasyDeployment();
deployment.setResources(Arrays.&lt;Object&gt;asList(service));
NettyJaxrsServer netty = new NettyJaxrsServer();
netty.setDeployment(deployment);
...
netty.start();
</code></p>

<p>Et voilà! On dispose désormais d'un programme exécutable qui démarre un serveur REST basé sur Netty.</p>

<p>Plutôt simple non? ;&ndash;)</p>

<h2>Configuration de Jackson</h2>

<p>Avec le code précédent, si la commande suivante est exécutée :</p>

<p><code>bash
 curl -XGET  http://localhost:8081/sample/say/hello
</code></p>

<p>Le résultat suivant est obtenu :
```javascript
{</p>

<pre><code>"message": "hello",
"time": 1402560438128
</code></pre>

<p>}
```</p>

<p>Hum&hellip; la date n'est pas formatté comme il faut&hellip; pas glop&hellip; :&lsquo;(</p>

<p>En fait, il est possible de modifier la configuration de <a href="http://jackson.codehaus.org/">Jackson</a> et on trouve, dans la littérature, un moyen très simple de le faire en configurant l'<em>ObjectMapper</em> comme suit :
<code>java
objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);
</code></p>

<p>Bien sûr, le but n'étant pas de faire cette transformation manuellement à chaque fois, on préfère laisser Resteasy le gérer lui-même.</p>

<p>Ainsi, il existe <a href="http://stackoverflow.com/questions/19229341/changing-default-json-time-format-with-resteasy-3-x">deux autres</a> manières de faire :</p>

<ul>
<li>Le faire par annotation</li>
<li>Le faire par configuration dans le <code>web.xml</code></li>
</ul>


<p>Cependant, dans notre cas, nous ne disposons pas d'un conteneur de Servlet classique et il n'est donc pas possible de s'appuyer sur une configuration par web.xml. Pour le faire par annotation, j'avoue ne pas avoir testé mais je suis sceptique&hellip;</p>

<p>Du coup, il reste une possibilité qui est de déclarer un <code>JacksonConfig</code> et de demander à Resteasy-Netty de nous l'enregistrer en tant que <em>provider</em> (en gros de demander à Resteasy-Netty de faire manuellement ce qui est fait via le <code>web.xml</code>) :</p>

<p>```java
public class JacksonConfig implements ContextResolver<ObjectMapper> {</p>

<pre><code>private final ObjectMapper objectMapper;

public JacksonConfig() {
    objectMapper = new ObjectMapper();
    objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);
    objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);
}

@Override
public ObjectMapper getContext(Class&lt;?&gt; objectType) {
    return objectMapper;
}
</code></pre>

<p>}
```</p>

<p>Pour l'enregistrement, c'est très simple puisqu'il suffit d'ajouter la ligne suivante :
<code>deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig"));</code></p>

<p>Et voilà! C'est tout!</p>

<p>Encore une fois, simple et efficace et le résultat obtenu est bien celui escompté :
```javascript
{</p>

<pre><code>"message": "hello",
"time": "2014-06-12T10:06:54.553+02:00"
</code></pre>

<p>}
```</p>

<p>A noter que l'<em>ancienne</em> version de Jackson est utilisée ici car c'est celle qui est utilisé par défaut par Resteasy. Il aurait été possible de l'utiliser dans sa version plus récente mais j'avoue ne pas avoir fait l'exercice&hellip; (cf. <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/html/json.html#d4e1046">ici</a>)</p>

<h2>Intégration de Metrics</h2>

<p>Afin de permettre une mesure des temps d'invocation de différentes opérations, la librairie <a href="http://metrics.codahale.com/">Metrics</a> a été utilisée.</p>

<p>Pour plus d'information dessus, le sujet est très bien traité sur le blog de <a href="https://twitter.com/clescot">Charles</a> :</p>

<ul>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-les-bases/">Metrics : Les Bases</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-jee/">Metrics : Intégration Avec JEE</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-spring-et-guice/">Metrics : Intégration Avec Spring Et Guice</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-JDBC-logback-et-jersey/">Metrics : Intégration Avec JDBC, Logback Et Jersey</a></li>
</ul>


<p>Dans notre cas, bien sûr, pas de <em>Spring</em>, de <em>Guice</em> ou de <em>Servlet Listener</em>. Une simple variable de classe dans la classe portant la méthode <code>main()</code> suffit :
```java
public static MetricRegistry metricRegistry;</p>

<p>public static void main(String[] args) throws ConfigurationException, BootstrapException {
   &hellip;</p>

<pre><code>metricRegistry = new MetricRegistry();
final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();
reporter.start();
</code></pre>

<p>}
```</p>

<p>Concernant l'utilisation à proprement parler, cela se fait de cette manière (dans notre cas, utilisation du <strong>Timer</strong> qui représente un histogramme des durées et une mesure de la fréquence d’apparition) :
```java
@GET
@Path(&ldquo;/say/{msg}&rdquo;)
@Produces(MediaType.APPLICATION_JSON)
public Response getPortDataSet(@PathParam(&ldquo;msg&rdquo;) String message) {</p>

<pre><code>final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));
final Timer.Context context = timer.time();
try {
</code></pre>

<p>  &hellip;</p>

<pre><code>    return Response.ok(response).build();
} finally {
    if (context != null) context.stop();
}
</code></pre>

<p>}
```</p>

<p>Une fois l'application démarrée et après 1 ou 2 appels, l'ObjectName apparait dans la console JMX et il est alors possible de voir les différents résultats.</p>

<p><img src="http://1.bp.blogspot.com/-RMh6acQ8Qkc/UxdsRqymVkI/AAAAAAAABPk/r3rvWdgPNtg/s1600/metrics-hawtio.png" alt="medium" /></p>

<p>On constate encore une fois que la mise en place de Metrics n'a demandé aucun effort particulier.</p>

<h2>Intégration de Jolokia</h2>

<p>Une autre étape de notre périple consiste à activer Jolokia que j'ai déjà présenté dans un <a href="/2014/03/jolokia-le-piment-qui-vous-veut-du-bien.html">article précédent</a>.</p>

<p>Dans notre cas d'usage, cela sera fait de manière programmatique.</p>

<p>Pour ce faire, c'est encore une fois très simple et il suffit d'ajouter le code suivant dans notre classe principale :
```java
private static void initJolokiaServer() {</p>

<pre><code>try {
    JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());

    JolokiaServer jolokiaServer = new JolokiaServer(config, true);
    jolokiaServer.start();
} catch (Exception e) {
    LOGGER.error("unable to start jolokia server", e);
}
</code></pre>

<p>}
```</p>

<p>Concernant sa configuration, pour éviter d'avoir à aller chercher des properties et à repeupler une Map, le fichier par défaut (<code>default-jolokia-agent.properties</code>) a été copié (en renseignant certaines informations comme le user/password) dans le répertoire <code>src/main/resources</code> :
```text</p>

<h1>Configuration properties for the JVM jolokia-agent</h1>

<h1>Host address to bind to.</h1>

<h1>Default: localhost, determinated dynamically via InetAddress.getLocalHost()</h1>

<p>host=0.0.0.0</p>

<h1>Port to listen to</h1>

<p>port=7778</p>

<h1>Context path</h1>

<p>agentContext=/jolokia</p>

<h1>Backlog of request to keep when queue</h1>

<p>backlog=10</p>

<h1>Possible values:</h1>

<h1>* &ldquo;fixed&rdquo;  : Thread pool with at max nrThreads</h1>

<h1>* &ldquo;single&rdquo; : A single thread serves all requests (default)</h1>

<h1>* &ldquo;cached&rdquo; : A thread pool which reuses threads and creates threads on demand (unbounded)</h1>

<h1>executor=fixed</h1>

<h1>nrThreads=5</h1>

<h1>User and password for basic authentication</h1>

<p>user=jolokia
password=jolokia</p>

<h1>How many entroes to keep in the history</h1>

<p>historyMaxEntries=10</p>

<h1>Switch on debugging</h1>

<p>debug=false</p>

<h1>How many debug entries to keep on the server side which can be queried by JMX</h1>

<p>debugMaxEntries=100</p>

<h1>Maximum traversal depth for serialization of complex objects.</h1>

<p>maxDepth=15</p>

<h1>Maximum size of collections returned during serialization.</h1>

<p>maxCollectionSize=1000</p>

<h1>Maximum number of objects returned by serialization</h1>

<p>maxObjects=0
```</p>

<p>Un petit coup de (le user jolokia et le mot de passe jolokia ont été positionné dans le fichier <em>properties</em>) :
<code>bash
curl -XGET -u jolokia:jolokia http://localhost:7778/jolokia/version
</code></p>

<p>nous permet bien d'obtenir la réponse attendue :
```javascript
{</p>

<pre><code>"timestamp": 1394036344,
"status": 200,
"request": {
    "type": "version"
},
"value": {
    "protocol": "7.0",
    "agent": "1.1.2",
    "info": {}
}
</code></pre>

<p>}
```</p>

<p>A noter que les user/password ont été positionné car cela permet une connexion via <a href="http://hawt.io/">Hawt.io</a>.</p>

<h2>Intégration de Swagger</h2>

<p><a href="https://helloreverb.com/developers/swagger">Swagger</a> offre une manière très simple de documenter une API REST. En effet, en s'appuyant sur des annotations à mettre dans la classe de service, elle permet d'offrir une interface d'écrivant les API.</p>

<p><img src="http://4.bp.blogspot.com/-92lPQm1F_DM/UxdsgUK3bDI/AAAAAAAABPs/yWh6QRHKkFc/s1600/swagger.png" alt="medium" /></p>

<p>Pour le mettre en place, il suffit donc de rajouter les annotations adéquates à notre classe <code>SimpleService</code> :</p>

<p>```java
@Api(value = &ldquo;/sample&rdquo;, description = &ldquo;the sample api&rdquo;)
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);

@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
@ApiOperation(value = "repeat the word",
        notes = "response the word",
        response = DtoResponse.class)
@ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})
public Response getPortDataSet(@PathParam("msg") String message) {

    final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));
    final Timer.Context context = timer.time();
    try {
        DtoResponse response = new DtoResponse();
        try {
            response.setMessage(message);
            response.setTime(DateTime.now());
        } catch (Exception e) {
            log.error("internal error: {}", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(response).build();
    } finally {
        if (context != null) context.stop();
    }
}
</code></pre>

<p>}
```</p>

<p>Reste maintenant à ajouter Swagger à notre <code>main()</code> que l'on doit faire programmatiquement faute d'être dans un conteneur de Servlet standard&hellip;</p>

<p>Pour ce faire, il est nécessaire d'instancier un objet <code>BeanConfig</code> qui contient la configuration de Swagger mais surtout l'adresse et le port du serveur sur lequel tourne le service ainsi que le package où se trouve ce dernier. Ces informations sont renseignées, dans notre cas, dans notre fichier de configuration et positionnées programmatiquement dans notre <code>BeanConfig</code>.</p>

<p>Enfin, il faut trouver le moyen de faire le pendant de ce qui est déclaré sur <a href="https://github.com/wordnik/swagger-core/wiki/Servlet-Quickstart">cette page</a>&hellip; bien sûr, le tout sans Servlet&hellip; ouch&hellip; :&lsquo;( En fouillant un peu, on tombe rapidement sur le <a href="https://github.com/wordnik/swagger-core/wiki/Java-CXF-Quickstart">quickstart swagger/cxf</a> où les <em>providers</em> sont positionnés : il suffit de faire pareil avec Resteasy-Netty ;&ndash;)</p>

<p>```java
private static void initSwagger(ResteasyDeployment deployment) {</p>

<pre><code>BeanConfig swaggerConfig = new BeanConfig();
swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));
swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));
swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));
swaggerConfig.setScan(true);
swaggerConfig.setResourcePackage("fr.jetoile.sample.service");

deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig",
        "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",
        "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));
deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));
deployment.setSecurityEnabled(false);
</code></pre>

<p>}
```</p>

<p>Et voilà, ça fonctionne!</p>

<p>En exécutant la commande :
<code>bash
curl -XGET http://localhost:8081/api-docs/sample
</code></p>

<p>On obtient bien le JSON escompté :
```javascript
{</p>

<pre><code>"apiVersion": "1.0.0",
"swaggerVersion": "1.2",
"basePath": "http://localhost:8081",
"resourcePath": "/sample",
"apis": [
    {
        "path": "/sample/say/{msg}",
        "operations": [
            {
                "method": "GET",
                "summary": "repeat the word",
                "notes": "response the word",
                "type": "DtoResponse",
                "nickname": "getPortDataSet",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "msg",
                        "required": true,
                        "allowMultiple": false,
                        "type": "string",
                        "paramType": "path"
                    }
                ],
                "responseMessages": [
                    {
                        "code": 500,
                        "message": "Internal server error"
                    }
                ]
            }
        ]
    }
],
"models": {
    "DtoResponse": {
        "id": "DtoResponse",
        "properties": {
            "message": {
                "type": "string"
            },
            "time": {
                "$ref": "DateTime"
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Mais (car il y a un mais&hellip;) en utilisant <a href="https://github.com/wordnik/swagger-ui">Swagger-UI</a> (qu'il faut déployer sur un apache/nginx/tomcat ou autre), il peut arriver que cela ne fonctionne pas&hellip; )(ie. que Swagger-IU n'arrive pas à fetcher les ressources de notre service REST). Cela arrivera d'ailleurs sûrement si notre application est déployée sur une machine différente de celle où est déployée Swagger-UI (pour rappel, on ne dispose pas, ici, d'un conteneur de Servlet et exposer des pages statiques n'est pas l'objectif de notre petite application). Le problème vient de notre cher ami, le <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>&hellip; Du coup, il devient nécessaire d'ajouter des <em>headers</em> dans le requête de réponse.</p>

<p>Et c'est là que la tâche se gâte&hellip; En effet, pas de possibilité de positionner un filtre comme avec les Servlets. Pas non plus de possibilité de modifier la configuration de Resteasy-Netty 3 pour lui demander d'ajouter des headers (si cela existe, je n'ai pas trouvé)&hellip;</p>

<p>Du coup, la seule solution a été de patcher sauvagement notre ami Resteasy-Netty 3 en surchargeant une de ses classes pour y ajouter les bons headers&hellip; Pas très classe mais bon&hellip;</p>

<p>Pour ce faire, il suffit de créer dans notre application le package <code>org.jboss.resteasy.plugins.server.netty</code> et d'y copier la classe <code>RequestHandler</code> en y ajoutant les headers utiles :
```java
package org.jboss.resteasy.plugins.server.netty;</p>

<p>import org.jboss.netty.channel.*;
import org.jboss.netty.channel.ChannelHandler.Sharable;
import org.jboss.netty.handler.codec.frame.TooLongFrameException;
import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponseStatus;
import org.jboss.resteasy.logging.Logger;
import org.jboss.resteasy.spi.Failure;</p>

<p>import static org.jboss.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;</p>

<p>/<em>*
 * TODO : hack to add CORS into header
 *
 * {@link org.jboss.netty.channel.SimpleChannelUpstreamHandler} which handles the requests and dispatch them.
 *
 * This class is {@link org.jboss.netty.channel.ChannelHandler.Sharable}.
 *
 * @author The Netty Project
 * @author Andy Taylor (<a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x61;&#110;&#100;&#121;&#46;&#116;&#x61;&#x79;&#x6c;&#x6f;&#x72;&#64;&#106;&#98;&#x6f;&#115;&#x73;&#46;&#x6f;&#114;&#103;">&#97;&#x6e;&#100;&#121;&#46;&#116;&#97;&#121;&#x6c;&#111;&#x72;&#64;&#106;&#x62;&#111;&#115;&#x73;&#x2e;&#x6f;&#114;&#103;</a>)
 * @author Trustin Lee
 * @author Norman Maurer
 * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
 </em>/
@Sharable
public class RequestHandler extends SimpleChannelUpstreamHandler {</p>

<pre><code>protected final RequestDispatcher dispatcher;
private final static Logger logger = Logger.getLogger(org.jboss.resteasy.plugins.server.netty.RequestHandler.class);

public RequestHandler(RequestDispatcher dispatcher) { this.dispatcher = dispatcher; }

@Override
public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
    if (e.getMessage() instanceof NettyHttpRequest) {
        NettyHttpRequest request = (NettyHttpRequest) e.getMessage();

        //HACK ICI!!!
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");
        //FIN DU HACK

        if (request.is100ContinueExpected()) { send100Continue(e); }

        NettyHttpResponse response = request.getResponse();
        try {
            dispatcher.service(request, response, true);
        } catch (Failure e1) {
            response.reset();
            response.setStatus(e1.getErrorCode());
            return;
        } catch (Exception ex) {
            response.reset();
            response.setStatus(500);
            logger.error("Unexpected", ex);
            return;
        }

        // Write the response.
        ChannelFuture future = e.getChannel().write(response);

        // Close the non-keep-alive connection after the write operation is done.
        if (!request.isKeepAlive()) { future.addListener(ChannelFutureListener.CLOSE); }
    }
}

private void send100Continue(MessageEvent e) {
    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
    e.getChannel().write(response);
}

@Override
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
    // handle the case of to big requests.
    if (e.getCause() instanceof TooLongFrameException) {
        DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE);
        e.getChannel().write(response).addListener(ChannelFutureListener.CLOSE);
    } else {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}
</code></pre>

<p>}
```</p>

<p>Voilà, après ce petit tour de passe passe, notre swagger-UI fonctionne comme un charme ;&ndash;)</p>

<p>Au final, (presque?) simple non? ;&ndash;)</p>

<h2>Branchement des plugins Maven Appassembler et Assembly</h2>

<p>Afin de générer une application utilisable <em>out of the box</em>, le plugin maven <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/">appassembler</a> a été utilisé. Pour ceux qui ne saurait pas ce que c'est, je les invite à regarder soit la documentation officielle soit un article que j'avais fait <a href="/2012/02/petit-focus-sur-2-plugins-maven.html">précédemment</a> (#autopromo ;&ndash;) ).</p>

<p>Ainsi, ici, le goal <code>generate-daemons</code> du plugin a été utilisé :
```xml
<plugin></p>

<pre><code>&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
&lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;
&lt;executions&gt;

    &lt;execution&gt;
        &lt;id&gt;spring-integ-reader&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;generate-daemons&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
            &lt;target&gt;${project.build.directory}/appassembler-jsw&lt;/target&gt;

            &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt;

            &lt;daemons&gt;
                &lt;daemon&gt;
                    &lt;id&gt;${project.name}&lt;/id&gt;
                    &lt;mainClass&gt;fr.jetoile.sample.Client&lt;/mainClass&gt;
                    &lt;commandLineArguments&gt;
                    &lt;/commandLineArguments&gt;
                    &lt;platforms&gt;
                        &lt;platform&gt;jsw&lt;/platform&gt;
                    &lt;/platforms&gt;
                    &lt;generatorConfigurations&gt;
                        &lt;generatorConfiguration&gt;
                            &lt;generator&gt;jsw&lt;/generator&gt;
                            &lt;includes&gt;
                                &lt;include&gt;linux-x86-64&lt;/include&gt;
                                &lt;include&gt;linux-x86-32&lt;/include&gt;
                            &lt;/includes&gt;
                            &lt;configuration&gt;

                                &lt;property&gt;
                                    &lt;name&gt;configuration.directory.in.classpath.first&lt;/name&gt;
                                    &lt;value&gt;conf&lt;/value&gt;
                                &lt;/property&gt;

                            &lt;/configuration&gt;
                        &lt;/generatorConfiguration&gt;
                    &lt;/generatorConfigurations&gt;
                    &lt;jvmSettings&gt;
                        &lt;initialMemorySize&gt;256M&lt;/initialMemorySize&gt;
                        &lt;maxMemorySize&gt;2048M&lt;/maxMemorySize&gt;
                        &lt;systemProperties&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.port=8199&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.authenticate=false
                            &lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.ssl=false&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.local.only=false
                            &lt;/systemProperty&gt;
                        &lt;/systemProperties&gt;
                        &lt;extraArguments&gt;
                            &lt;extraArgument&gt;-Xdebug&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;
                                -Xrunjdwp:transport=dt_socket,address=9999,server=y,suspend=n
                            &lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-server&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+UnlockCommercialFeatures&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+FlightRecorder&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/extraArgument&gt;
                        &lt;/extraArguments&gt;
                    &lt;/jvmSettings&gt;
                &lt;/daemon&gt;
            &lt;/daemons&gt;
        &lt;/configuration&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;

&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<p>En outre, ce plugin ne créant pas le répertoire <code>logs</code> et ne positionnant pas les droits d'exécution sur les fichiers du répertoire bin, le plugin Maven <a href="https://maven.apache.org/plugins/maven-assembly-plugin/">assembly</a> a été utilisé conjointement :
```xml
<plugin></p>

<pre><code>&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
    &lt;descriptors&gt;
        &lt;descriptor&gt;src/main/assembly/descriptor.xml&lt;/descriptor&gt;
    &lt;/descriptors&gt;
    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;

&lt;/configuration&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;assembly&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;single&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
</code></pre>

<p></plugin>
```</p>

<p>Avec le descripteur simple suivant :
```xml
&lt;?xml version=&ldquo;1.0&rdquo;?>
&lt;assembly xmlns=&ldquo;<a href="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2">http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2</a>&rdquo;</p>

<pre><code>      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"&gt;
&lt;id&gt;reader&lt;/id&gt;
&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
&lt;formats&gt;&lt;format&gt;tar.gz&lt;/format&gt;&lt;/formats&gt;

&lt;fileSets&gt;
    &lt;fileSet&gt;
        &lt;directory&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}&lt;/directory&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;excludes&gt;
            &lt;exclude&gt;bin/${project.name}&lt;/exclude&gt;
            &lt;exclude&gt;bin/wrapper-linux-x86-32&lt;/exclude&gt;
            &lt;exclude&gt;bin/wrapper-linux-x86-64&lt;/exclude&gt;
        &lt;/excludes&gt;
        &lt;fileMode&gt;640&lt;/fileMode&gt;
        &lt;directoryMode&gt;750&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
    &lt;fileSet&gt;
        &lt;directory&gt;src/main/assembly&lt;/directory&gt;
        &lt;outputDirectory&gt;/logs&lt;/outputDirectory&gt;
        &lt;excludes&gt;&lt;exclude&gt;*&lt;/exclude&gt;&lt;/excludes&gt;
    &lt;/fileSet&gt;
&lt;/fileSets&gt;

&lt;files&gt;
    &lt;file&gt;
        &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/${project.name}&lt;/source&gt;
        &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;
        &lt;fileMode&gt;750&lt;/fileMode&gt;
    &lt;/file&gt;
    &lt;file&gt;
        &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/wrapper-linux-x86-64&lt;/source&gt;
        &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;
        &lt;fileMode&gt;750&lt;/fileMode&gt;
    &lt;/file&gt;
&lt;/files&gt;
</code></pre>

<p></assembly>
```</p>

<p>Ainsi, l'exécution de la commande suivante :
<code>bash
mvn package
</code></p>

<p>génère un livrable exploitable directement après sa décompression.</p>

<p>Lors d'un <code>mvn release</code>, il sera également automatiquement uploadé sur le <em>Repository Manager</em>.</p>

<h1>Conclusion</h1>

<p>En conclusion, je n'ai pas grand chose à ajouter si ce n'est que j'ai trouvé Resteasy-Netty simple à utiliser et qu'il a été aisé d'y ajouter tout ce qui était nécessaire à notre besoin.</p>

<p>Et le tout de manière simple et efficace pour une solution véloce et légère!</p>

<p>Pour faire encore plus simple, <a href="http://projectlombok.org/">Lombok</a> aurait pu être utilisé mais, de mémoire, en test de Java 8, une incompatibilité est apparue&hellip; à creuser donc pour cette partie&hellip; ;&ndash;)</p>
]]></content>
  </entry>
  
</feed>
