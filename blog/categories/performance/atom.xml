<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: performance | Jetoile]]></title>
  <link href="http://blog.jetoile.fr/blog/categories/performance/atom.xml" rel="self"/>
  <link href="http://blog.jetoile.fr/"/>
  <updated>2015-10-07T17:01:51+02:00</updated>
  <id>http://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Undertow pour booster vos services REST]]></title>
    <link href="http://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest.html"/>
    <updated>2015-06-23T14:51:56+02:00</updated>
    <id>http://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest</id>
    <content type="html"><![CDATA[<p><img src="/images/undertow.png" alt="left-small" />
Il y a quelques temps, j'avais fait une série d'articles sur <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>.</p>

<p>Cette article repart du même besoin, à savoir disposer d'une <em>stack</em> légère pour réaliser un service REST, mais en utilisant <a href="http://undertow.io/">Undertow</a> plutôt que Resteasy-Netty.</p>

<!-- more -->


<p>Au niveau des besoins, ils seront identiques ie. :</p>

<ul>
<li>utiliser JAX-RS,</li>
<li>intégrer Swagger,</li>
<li>intégrer Jolokia,</li>
<li>générer un livrable autoporteur.</li>
</ul>


<p>RestEasy-Netty, même s'il existe de nombreux points d'entrée, demande quelques phases de <em>hack</em> (gestion du <em>crossover domain</em> par exemple) et dispose d'un mécanisme un peu limité concernant la partie sécurité.</p>

<p>En outre, l'absence du mécanisme de Servlet reste un peu embêtant pour mettre en place certaines <em>features</em> comme le MDC ( <a href="http://logback.qos.ch/manual/mdc.html"><em>Mapped Diagnostic Context</em></a> ) bien pratique lorsque l'on est dans une architecture type microservice.</p>

<p>Le code complet est disponible <a href="https://github.com/jetoile/undertow-sample">ici</a>.</p>

<h1>Rappel du cahier des charges</h1>

<p>Comme je l'ai déjà indiqué dans les autres posts, l'objectif est seulement de montrer comme il peut être simple d'exposer un service REST à l'aide d'<a href="http://undertow.io/">Undertow</a>. Pour ce faire, un simple service sera exposé et il consistera à répèter ce qu’on lui demande…</p>

<p>Il répondra donc à une requête de type GET du type : <a href="http://localhost:8081/sample/say/">http://localhost:8081/sample/say/</a><message></p>

<p>Du coté de la réponse, elle aura la forme suivante :
```javascript
{</p>

<pre><code>"message": &lt;message&gt;,
"time":"2015-06-23T15:18:50.748"
</code></pre>

<p>}
```</p>

<h1>Mise en oeuvre</h1>

<p>A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :
```text</p>

<pre><code>compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.11.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.3.1'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.12'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'javax.servlet-api', version:'3.1.0'
compile group: 'io.dropwizard.metrics', name: 'metrics-core', version:'3.1.2'
compile group: 'io.undertow', name: 'undertow-core', version:'1.2.8.Final'
compile group: 'io.undertow', name: 'undertow-servlet', version:'1.2.8.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-undertow', version:'3.0.11.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson2-provider', version:'3.0.11.Final'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version:'2.5.4'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version:'2.5.4'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version:'2.5.4'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.10'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'org.slf4j', name: 'slf4j-api', version:'1.7.12'
compile group: 'ch.qos.logback', name: 'logback-classic', version:'1.1.3'
</code></pre>

<p>```</p>

<p>Concernant la version des différentes dépendances, on constate que ce n'est pas swagger2 qui est utilisé en raison d'une incapacité de ma part à l'intégrer&hellip; :&lsquo;(</p>

<h1>Implémentation du service REST</h1>

<p>Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial… et la classe ci-dessous fait humblement l’affaire :
```java
@Api(value = &ldquo;/sample&rdquo;,</p>

<pre><code>    description = "the sample api")
</code></pre>

<p>@Path(&ldquo;/sample&rdquo;)
@RolesAllowed(&ldquo;admin&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);


@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
@ApiOperation(value = "repeat the word",
        notes = "response the word",
        response = DtoResponse.class)
@ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})
public Response sayHello(@PathParam("msg") String message) {

    log.info("sample log");

    final Timer timer = Main.metricRegistry.timer(name(SimpleService.class, "say-service"));
    final Timer.Context context = timer.time();
    try {

        DtoResponse response = new DtoResponse();
        try {
            response.setMessage(message);
            response.setTime(LocalDateTime.now());
        } catch (Exception e) {
            log.error("internal error: {}", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(response).build();
    } finally {
        if (context != null) context.stop();
    }
}
</code></pre>

<p>}
<code>
Coté du DTO, il est le suivant :
</code>java
@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
private LocalDateTime time;

public DtoResponse() {
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

public LocalDateTime getTime() {
    return time;
}

public void setTime(LocalDateTime time) {
    this.time = time;
}
</code></pre>

<p>}
```</p>

<p>On remarquera l'utilisation de Java8 pour la gestion du temps plutôt que Joda-Time.</p>

<p>En outre, concernant les annotations Swagger et l'utilisation de metrics, nous y reviendrons plus tard.</p>

<p>Concernant le message de log, de même, nous y reviendrons plus tard avec l'intégration d'un MDC pour les logs.</p>

<h1>Mise en oeuvre avec Undertow</h1>

<p>Mettre en place Resteasy avec Undertow est très simple, d’après la documnentation, il suffit de faire :
```java
SimpleService simpleService = new SimpleService();
ResteasyDeployment deployment = new ResteasyDeployment();</p>

<p>deployment.setResources(Arrays.<Object>asList(simpleService));</p>

<p>int port = config.getInt(&ldquo;undertow.port&rdquo;, TestPortProvider.getPort());
String host = config.getString(&ldquo;undertow.host&rdquo;, String.valueOf(TestPortProvider.getHost()));
System.setProperty(&ldquo;org.jboss.resteasy.port&rdquo;, String.valueOf(TestPortProvider.getPort());
System.setProperty(&ldquo;org.jboss.resteasy.host&rdquo;, String.valueOf(TestPortProvider.getHost());</p>

<p>UndertowJaxrsServer server = new UndertowJaxrsServer();</p>

<p>DeploymentInfo deploymentInfo = server.undertowDeployment(deployment);
deploymentInfo.setDeploymentName(&ldquo;&rdquo;);
deploymentInfo.setContextPath(&ldquo;/&rdquo;);
deploymentInfo.setClassLoader(Main.class.getClassLoader());</p>

<p>deployment.setProviderFactory(new ResteasyProviderFactory());
server.deploy(deploymentInfo);
server.start(Undertow.builder().addHttpListener(port, host));
```</p>

<p>On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <code>setResources()</code> sur l’instance de <em>ResteasyDeployment</em> fournit au serveur <em>UndertowJaxrsServer</em> :</p>

<p>Et voilà! On dispose désormais d’un programme exécutable qui démarre un serveur REST basé sur Undertow.</p>

<p>Par contre, il semble que le service ne rende pas vraiment ce que l'on voulait :
<code>bash
curl 'http://localhost:8081/sample/say/&lt;message&gt;'
</code></p>

<p>```json
{</p>

<pre><code>"message": "&lt;message&gt;",
"time": {
    "hour": 15,
    "minute": 55,
    "second": 51,
    "nano": 225000000,
    "year": 2015,
    "month": "JUNE",
    "dayOfMonth": 23,
    "dayOfWeek": "TUESDAY",
    "dayOfYear": 174,
    "monthValue": 6,
    "chronology": {
        "calendarType": "iso8601",
        "id": "ISO"
    }
}
</code></pre>

<p>}
```</p>

<p>Pas de souci, il suffit de préciser comment on souhaite que LocalDateTime soit sérialisé par Jackson :</p>

<p>Ainsi, notre DTO devient :
```java</p>

<p>@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
@JsonSerialize(using = LocalDateTimeToStringSerializer.class)
private LocalDateTime time;

public DtoResponse() {
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

public LocalDateTime getTime() {
    return time;
}

public void setTime(LocalDateTime time) {
    this.time = time;
}
</code></pre>

<p>}
```</p>

<p>où :</p>

<p>```java
public class LocalDateTimeToStringSerializer extends JsonSerializer<LocalDateTime> {</p>

<pre><code>@Override
public void serialize(LocalDateTime value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
    jgen.writeObject(value.format(DateTimeFormatter.ISO_DATE_TIME));
}
</code></pre>

<p>}
```</p>

<p>Après ces modifications, on obtient bien :</p>

<p><code>json
{"message":"&lt;message&gt;","time":"2015-06-23T16:04:01.419"}
</code></p>

<h1>Intégration de Metrics</h1>

<p>Concernant l'intégration de Metrics, pas grand chose de nouveau et donc pas grand chose à dire ;&ndash;)</p>

<p>Déclarer le registry :
<code>java
metricRegistry = new MetricRegistry();
final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();
reporter.start();
</code></p>

<p>Et utiliser le dans vos classes :
```java
final Timer timer = Main.metricRegistry.timer(name(SimpleService.class, &ldquo;say-service&rdquo;));
final Timer.Context context = timer.time();
try {</p>

<pre><code>...
</code></pre>

<p>} finally {</p>

<pre><code>if (context != null) context.stop();
</code></pre>

<p>}
```</p>

<h1>Intégration de la sécurité</h1>

<p>Undertow permet une bien meilleur intégration de la sécurité que RestEasy-Netty. En effet, grâce au mécanisme de Servlet, il est possible de bénéficier de toute la puissance des conteneurs de Servlets.</p>

<p>Du coté du serveur Undertow, il suffit donc de définir un <em>ServletIdentityManager</em> et de lui fournir un <em>LoginConfig</em> :
```java
deployment.setSecurityEnabled(true);</p>

<p>ServletIdentityManager identityManager = new ServletIdentityManager();
identityManager.addUser(&ldquo;khanh&rdquo;, &ldquo;khanh&rdquo;, &ldquo;admin&rdquo;);</p>

<p>deploymentInfo = deploymentInfo.setIdentityManager(identityManager).setLoginConfig(new LoginConfig(&ldquo;BASIC&rdquo;, &ldquo;Test Realm&rdquo;));
```</p>

<p>où :
```java
public class ServletIdentityManager implements IdentityManager {</p>

<pre><code>private static final Charset UTF_8 = Charset.forName("UTF-8");
private final Map&lt;String, UserAccount&gt; users = new HashMap&lt;&gt;();

public void addUser(final String name, final String password, final String... roles) {
    UserAccount user = new UserAccount();
    user.name = name;
    user.password = password.toCharArray();
    user.roles = new HashSet&lt;&gt;(Arrays.asList(roles));
    users.put(name, user);
}

@Override
public Account verify(Account account) {
    // Just re-use the existing account.
    return account;
}

@Override
public Account verify(String id, Credential credential) {
    Account account = users.get(id);
    if (account != null &amp;&amp; verifyCredential(account, credential)) {
        return account;
    }

    return null;
}

@Override
public Account verify(Credential credential) {
    return null;
}

private boolean verifyCredential(Account account, Credential credential) {
    // This approach should never be copied in a realm IdentityManager.
    if (account instanceof UserAccount) {
        if (credential instanceof PasswordCredential) {
            char[] expectedPassword = ((UserAccount) account).password;
            char[] suppliedPassword = ((PasswordCredential) credential).getPassword();

            return Arrays.equals(expectedPassword, suppliedPassword);
        } else if (credential instanceof DigestCredential) {
            DigestCredential digCred = (DigestCredential) credential;
            MessageDigest digest = null;
            try {
                digest = digCred.getAlgorithm().getMessageDigest();

                digest.update(account.getPrincipal().getName().getBytes(UTF_8));
                digest.update((byte) ':');
                digest.update(digCred.getRealm().getBytes(UTF_8));
                digest.update((byte) ':');
                char[] expectedPassword = ((UserAccount) account).password;
                digest.update(new String(expectedPassword).getBytes(UTF_8));

                return digCred.verifyHA1(HexConverter.convertToHexBytes(digest.digest()));
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException("Unsupported Algorithm", e);
            } finally {
                digest.reset();
            }
        }
    }
    return false;
}

private static class UserAccount implements Account {
    // In no way whatsoever should a class like this be considered a good idea for a real IdentityManager implementation,
    // this is for testing only.

    String name;
    char[] password;
    Set&lt;String&gt; roles;

    private final Principal principal = new Principal() {
        @Override
        public String getName() {
            return name;
        }
    };

    @Override
    public Principal getPrincipal() {
        return principal;
    }

    @Override
    public Set&lt;String&gt; getRoles() {
        return roles;
    }
}
</code></pre>

<p>}
```</p>

<p>Il s'agit ici d'une Basic Authentification mais il est bien sûr possible d'en mettre en place d'autre.</p>

<p>Coté autorisation, il est alors possible de bénéficier de l'annotation <code>@RolesAllowed</code> de JAX-RS :
<code>java
@Path("/sample")
@RolesAllowed("admin")
public class SimpleService {
...
}
</code></p>

<h1>Intégration d'un MDC</h1>

<p>Concernant la mise en place d'un MDC (<em>Mapped Diagnostic Context</em>), le fait de bénéficier du mécanisme de <em>Filter</em> des Servlets rend la chose beaucoup plus simple.</p>

<p>En effet, une fois la couche sécurité branchée, il suffit de récupérer le <code>UserPrincipal</code> dans la requête et l'enregistrer dans le MDC.</p>

<p>La déclaration des Filters se fait de la manière suivante pour Undertow :
```java
FilterInfo mdcFilter = new FilterInfo(&ldquo;MDCFilter&rdquo;, MDCServletFilter.class);
deploymentInfo.addFilter(mdcFilter);
deploymentInfo.addFilterUrlMapping(&ldquo;MDCFilter&rdquo;, &ldquo;*&rdquo;, DispatcherType.REQUEST);</p>

<p>FilterInfo mdcInsertingFilter = new FilterInfo(&ldquo;MDCInsertingServletFilter&rdquo;, MDCInsertingServletFilter.class);
deploymentInfo.addFilter(mdcInsertingFilter);
deploymentInfo.addFilterUrlMapping(&ldquo;MDCInsertingServletFilter&rdquo;, &ldquo;*&rdquo;, DispatcherType.REQUEST);
```</p>

<p>Avec le filter ci-dessous :
```java
public class MDCServletFilter implements Filter {</p>

<pre><code>private final String USER_KEY = "username";

public void destroy() {
}

public void doFilter(ServletRequest request, ServletResponse response,
                     FilterChain chain) throws IOException, ServletException {

    boolean successfulRegistration = false;

    HttpServletRequest req = (HttpServletRequest) request;
    Principal principal = req.getUserPrincipal();
    // Please note that we could have also used a cookie to
    // retrieve the user name

    if (principal != null) {
        String username = principal.getName();
        successfulRegistration = registerUsername(username);
    }

    try {
        chain.doFilter(request, response);
    } finally {
        if (successfulRegistration) {
            MDC.remove(USER_KEY);
        }
    }
}

public void init(FilterConfig arg0) throws ServletException {
}


/**
 * Register the user in the MDC under USER_KEY.
 *
 * @param username
 * @return true id the user can be successfully registered
 */
private boolean registerUsername(String username) {
    if (username != null &amp;&amp; username.trim().length() &gt; 0) {
        MDC.put(USER_KEY, username);
        return true;
    }
    return false;
}
</code></pre>

<p>}
<code>
Ainsi, disposer d'un MDC permet d'ajouter automatiquement des informations dans les logs :
</code>xml
<configuration></p>

<pre><code>&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;%d{HH:mm:ss.SSS} %-5level %logger{36} %X{req.remoteHost} %X{req.requestURI} - C:%X{username} - %msg%n

        &lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;


&lt;root level="info"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
&lt;/root&gt;
</code></pre>

<p></configuration>
```</p>

<p>On obtient alors bien les logs voulues :
<code>text
17:15:11.466 INFO  f.j.sample.service.SimpleService 127.0.0.1 /sample/say/&lt;message&gt; - C:khanh - sample log
</code></p>

<h1>Intégration de Jolokia</h1>

<p>Coté Jolokia, pas grand chose à ajouter par rapport à ma série d'article précédent&hellip;
```java
try {</p>

<pre><code>        JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());

        JolokiaServer jolokiaServer = new JolokiaServer(config, true);
        jolokiaServer.start();
</code></pre>

<p>} catch (Exception e) {</p>

<pre><code>        LOGGER.error("unable to start jolokia server", e);
</code></pre>

<p>}
```</p>

<h1>Intégration de Swagger</h1>

<p>Concernant l'intégration de Swagger, le fait de disposer des <em>Filter</em> de Servlet permet de n'avoir pas à faire de <em>hack</em> immonde pour gérer le CORS (cf. <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">article précédent</a>) : il suffit de déclarer un <em>Filter</em> dans Undertow qui a, en outre, la chance d'exister :
```java
CorsFilter filter = new CorsFilter();
filter.setAllowedMethods(&ldquo;GET,POST,PUT,DELETE,OPTIONS&rdquo;);
filter.setAllowedHeaders(&ldquo;X-Requested-With, Content-Type, Content-Length, Authorization&rdquo;);
filter.getAllowedOrigins().add(&ldquo;*&rdquo;);</p>

<p>deployment.setProviderFactory(new ResteasyProviderFactory());
deployment.getProviderFactory().register(filter);
```</p>

<p>Concernant la déclaration dans Undertow, pas grand chose à ajouter :
```java</p>

<pre><code>private static void initSwagger(ResteasyDeployment deployment) {
    BeanConfig swaggerConfig = new BeanConfig();
    swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));
    swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));
    swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));
    swaggerConfig.setScan(true);
    swaggerConfig.setResourcePackage("fr.jetoile.sample.service");

    deployment.setProviderClasses(Lists.newArrayList(
            "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",
            "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));
    deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));
    deployment.setSecurityEnabled(false);
}
</code></pre>

<p>```</p>

<h1>Branchement des plugins Maven Appassembler et Assembly</h1>

<p>Coté génération du livrable, encore une fois, pas grand chose à ajouter par rapport à mon précédent article : l'utilisation des plugins assembly et appassembler est identique.</p>

<h1>Conclusion</h1>

<p>On avait vu dans les articles précédents que RestEasy-Netty était une solution intéressante pour la simplicité de sa mise en oeuvre ainsi que pour le faible overhead.</p>

<p>Cependant, certaines intégrations ressemblaient plus à du <em>hack</em> qu'à une solution configurable.</p>

<p>Undertow (enfin pour être plus précis RestEasy-Undertow) pour sa part offre la même simplicité que RestEasy-Netty mais il permet en plus de s'intégrer avec beaucoup d'autres choses et le fait de retrouver le mécanisme de <em>Filter</em> facilite énormément les choses (par exemple, je ne suis pas sûr que bénéficier du MDC avec RestEasy-Netty ait été aussi simple).</p>

<p>Coté performance, je reviendrai dessus dans un autre article mais je peux déjà dire que la solution RestEasy-Undertow n'a rien à envier à RestEasy-Netty.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty4 et Spring Integration : ils reviennent et ils ne sont pas content!]]></title>
    <link href="http://blog.jetoile.fr/2014/03/jaxrs-netty4-et-spring-integration-ils.html"/>
    <updated>2014-03-24T19:12:29+01:00</updated>
    <id>http://blog.jetoile.fr/2014/03/jaxrs-netty4-et-spring-integration-ils</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-XR47rmCwXK0/Ux8gpmR-TLI/AAAAAAAABR0/T1h_RtvDED0/s1600/resteasy_jolokia_metrics_orig3.png" alt="left-small" /></p>

<p>Pour faire suite à mes articles <a href="/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>, nous allons voir, dans cet article, comment il est possible de créer un service activator avec <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> qui exposera via resteasy-netty4 un service REST.</p>

<p>Ce service REST esposera simplement une opération en POST qui, via Spring Integration, écrira dans un fichier et qui, pour le fun, écrira également sur la console.</p>

<p>Pour ce faire, rien de plus simple, un <a href="http://www.eaipatterns.com/MessagingAdapter.html">Service Activator</a> de type <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">gateway</a> a été utilisé.</p>

<p>Cet article montrera donc comment il est possible d'intégrer Spring Integration à notre petite stack basé sur Resteasy-Netty4, Jackson, <a href="http://metrics.codahale.com/">Metrics</a>, <a href="https://helloreverb.com/developers/swagger">Swagger</a> et <a href="http://www.jolokia.org/">Jolokia</a>.</p>

<p>Le code se trouve sur Github <a href="https://github.com/jetoile/spring-integration-netty4">ici</a>.</p>

<!-- more -->


<h1>Présentation du usecase</h1>

<p>Le service qui est exposé est un service de type REST répondant à un appel de type POST et acceptant du JSON.</p>

<p>Il répondra à une requête de type :
<code>bash
curl -XPOST -H "Content-Type: application/json" -d '{"message": "hello", "time": "2014-03-05T10:55:39.835+01:00"}'  http://127.0.0.1:8081/sample/write
</code>
et écrira un fichier par requête reçue dans le répertoire <code>/tmp</code>. En outre, il loggera sur la console le message reçu.</p>

<p>Ainsi, avec la commande suivante, on devrait voir un incrément du nombre à chaque réception de message.
<code>bash
watch 'ls *.msg | wc -l'
</code></p>

<h1>Mise en oeuvre</h1>

<h2>Dépendances</h2>

<p>A titre informatif, les dépendances ainsi que leurs versions sont les suivantes (au format gradle) :
```text
dependencies {</p>

<pre><code>compile group: 'org.springframework.integration', name: 'spring-integration-core', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-jmx', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-http', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-file', version:'3.0.1.RELEASE'
compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-spring', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.ryantenney.metrics', name: 'metrics-spring', version:'3.0.0-RC4'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}
</code></pre>

<p>}
```</p>

<p>Pour le lecteur averti, il constatera que la version de Jackson utilisé ici est la 1 (ie. avec le groupId <strong>org.codehaus</strong>). En effet, Jackson 2 et JodaTime m'ont fait des misères et je n'ai pas réussi à les résoudre rapidement, donc, par flemme, je suis repassé en version 1&hellip; ;&ndash;)</p>

<h2>DTO</h2>

<p>Un DTO annoté JAX-B (compris par Jackson) sera utilisé pour représenter le JSON reçu dans le corps du POST.</p>

<p>Il se présente comme suit :
```java
@XmlRootElement
public class DtoRequest {</p>

<pre><code>private String message;
private DateTime time;

public String getMessage() { return message; }

public void setMessage(String message) { this.message = message; }

public DateTime getTime() { return time; }

public void setTime(DateTime time) { this.time = time; }

@Override
public String toString() {
    return "DtoRequest{" +
            "message='" + message + '\'' +
            ", time=" + time +
            '}';
}
</code></pre>

<p>}
```</p>

<p>Ici, la méthode <code>toString()</code> a été overridé car utilisé lors de l'affichage du message par le loggueur sur la console.</p>

<p>Jusque là, ça ne casse pas trois pattes à un canard ;&ndash;)</p>

<h2>Intégration complète de Spring Integration</h2>

<p>Pour rappel, Spring Integration est une implémentation des <a href="/2009/12/eip-quest-ce-que-cest.html">EIP</a> (<em>Enterprise Integration Patterns</em>) et propose donc une mise en oeuvre de l'architecture <strong>Pipes and Filters</strong>.</p>

<p><img src="http://3.bp.blogspot.com/-Pd_JIILTp_0/Ux8fIIRV-tI/AAAAAAAABRQ/hevpIqdQU4M/s1600/si-netty4-graph.png" alt="large" /></p>

<p>Au niveau écriture dans un répertoire, le <code>file-outbound-adapter</code> offert par Spring Integration sera utilisé :
```xml
file:outbound-channel-adapter id=&ldquo;fileAdapter&rdquo; auto-create-directory=&ldquo;true&rdquo;</p>

<pre><code>                                   directory="file:${out.directory}"
                                   channel="channel"/&gt;
</code></pre>

<p>```</p>

<p>Coté loggueur, ce sera le composant logging :
<code>xml
 &lt;int:logging-channel-adapter auto-startup="true" channel="channel" level="INFO" log-full-message="true"/&gt;
</code>
et où on aura un Pipe (channel) en mode <code>Publish-Subscribe</code> :
<code>xml
 &lt;int:publish-subscribe-channel id="channel"/&gt;
</code></p>

<p>Au niveau des namespaces et autres informations, on aura ce qui suit :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;
    &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
    &lt;property name="locations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/conf.properties&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
    &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
&lt;/bean&gt;

&lt;int-jmx:mbean-export default-domain="fr.jetoile.sample" server="mbeanServer"/&gt;

&lt;int:message-history/&gt;    
...
</code></pre>

<p></beans>
```</p>

<p>On y remarque la lecture du fichier de configuration, ainsi que les activations jmx adéquate afin d'avoir un peu d'informations ;&ndash;) Concernant l'élément message-history, cela permet de préciser à Spring Integration d'ajouter dans les headers du message (qui, pour rappel, transite via les Pipes entre les différents Filters) des informations de temps d'exécution.</p>

<p>En soit, il s'agit d'une configuration extrèmement simple pour toute personne connaissant un minimum Spring Integration, donc encore une fois, rien de compliqué&hellip; ;&ndash;)</p>

<h2>Gateway Spring Integration</h2>

<p>Afin de rentrer dans le vif du sujet, ce paragraphe montrera comment il est possible de transformer notre petit serveur Resteasy-Netty4 en une Gateway Spring Integration.</p>

<p>Pour ce faire, il suffit de définir une interface (NettyGateway) qui sera utilisée par Spring Integration.
Ci dessous un petit extract de la <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">documentation officielle</a> :</p>

<blockquote><p>Le rôle principale d'une Gateway est de chacher l'API de messaging fournit par Spring Integration. Cela permet à la logique business de l'application de s'abstraire complètement de l'API de Spring Integration et, en utilisant une Gateway générique, le code n'interagit qu'avec une simple interface.</p>

<p>&hellip;</p>

<p>En fait, Spring Integration fournit un GatewayProxyFactoryBean qui génère un proxy pour n'importe quelle interface et qui, en interne, invoque la méthode de la Gateway. Ainsi, en utilisant l'injection de dépendance, il est possible d'exposer l'interface aux méthodes business.</p></blockquote>

<p>```java
public interface NettyGateway {</p>

<pre><code>void send(DtoRequest msg);
</code></pre>

<p>}
```</p>

<p>Ainsi, notre service REST se présentera comme suit :
```java
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private NettyGateway messageProducer;

public void setGateway(NettyGateway messageProducer) {
    this.messageProducer = messageProducer;
}

@POST
@Path("/write")
@Consumes(MediaType.APPLICATION_JSON)
public Response write(DtoRequest message) {
    this.messageProducer.send(message);
    return Response.ok().build();
}
</code></pre>

<p>}
```</p>

<p>On y constatera que l'inteface NettyGateway lui a été injecté afin qu'il puisse servir de passe plat.</p>

<p>Coté Spring, la configuration est la suivante :
```xml
&lt;int:gateway id=&ldquo;nettyGateway&rdquo; service-interface=&ldquo;fr.jetoile.sample.gateway.NettyGateway&rdquo;</p>

<pre><code>             default-request-channel="channel"/&gt;
</code></pre>

<p><bean id="simpleService" class="fr.jetoile.sample.service.SimpleService"></p>

<pre><code>&lt;property name="gateway" ref="nettyGateway"/&gt;
</code></pre>

<p></bean>
<code>
Du coté de démarrage de notre serveur Resteasy-Netty4, cela ne sera, bien sûr, plus fait dans le `main()`, mais dans notre bean Spring à qui sera injectée notre classe implémentant notre service REST :
</code>xml
<bean id="nettyContainer" class="fr.jetoile.sample.gateway.NettyContainer"></p>

<pre><code>&lt;constructor-arg ref="simpleService"/&gt;
</code></pre>

<p></bean>
```</p>

<p>Avec :
```java
public class NettyContainer {</p>

<pre><code>private static final Logger LOGGER = LoggerFactory.getLogger(NettyContainer.class);

public static final String CONF_PROPERTIES = "conf.properties";

private static Configuration config;

private SimpleService simpleService;

public NettyContainer(SimpleService simpleService) {
    try {
        config = new PropertiesConfiguration(CONF_PROPERTIES);

    } catch (ConfigurationException e) {
        throw new IllegalArgumentException("bad config");
    }
    this.simpleService = simpleService;
    initServer();
}


private void initServer() {
    ResteasyDeployment deployment = new ResteasyDeployment();

    int nettyPort = 8081;

    if (config != null) {
        deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));
        deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));
        deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));
        deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));

        nettyPort = config.getInt("netty.port", TestPortProvider.getPort());
    } else {
        LOGGER.warn("is going to use default netty config");
    }

    deployment.setResources(Arrays.&lt;Object&gt;asList(simpleService));

    MyNettyJaxrsServer netty = new MyNettyJaxrsServer();

    netty.setDeployment(deployment);
    netty.setPort(nettyPort);
    netty.setRootResourcePath("");
    netty.setSecurityDomain(null);
    netty.start();
}
</code></pre>

<p>}
```</p>

<p>Et voilà&hellip; c'est tout!</p>

<p>Ne reste plus que la classe implémentant notre main() qui ne fera que charger le contexte spring :
```java
public class Client {</p>

<pre><code>public static void main(String[] args) throws ConfigurationException {
    new ClassPathXmlApplicationContext("springintegration-config.xml");
}
</code></pre>

<p>}
```</p>

<p>Juste un dernier point : le lecteur un peu concentré aura remarqué qu'il y a, ici, un petit meli melo dans la lecture des fichiers de configuration (parfois chargé par Spring, parfois chargé via commons-configuration). Je laisse cependant ces points en suspens et à la discrétion de la personne qui utilisera et lira cet article (ou qui aura atteint ce point&hellip;) (s'il y en a&hellip; ;&ndash;) ).</p>

<h2>Intégration de Metrics</h2>

<p>L'objectif de cet article étant de monter une stack &ldquo;presque complète&rdquo;, il est, bien sûr, primordial de fournir les bonnes métriques.</p>

<p>Comme dans mon article précédent, ce sera Metrics qui sera utilisé.</p>

<p>Cependant, alors que cela avait été fait programmatiquement, ce coup-ci, cela sera fait via Spring (parce que sinon ce n'est pas drôle&hellip; ;&ndash;) ).</p>

<p>Pour ce faire, c'est très simple, en tirant la dépendance <strong>&lsquo;com.ryantenney.metrics&rsquo;, name: &lsquo;metrics-spring&rsquo;, version:&lsquo;3.0.0-RC4&rsquo;</strong> au lieu de <strong>&lsquo;com.codahale.metrics&rsquo;, name: &lsquo;metrics-core&rsquo;</strong>, il ne reste qu'à ajouter à notre service REST l'annotation <code>@Timed</code> et d'ajouter dans la configuration Spring les éléments suivants :</p>

<p>```java
@POST
@Path(&ldquo;/write&rdquo;)
@Consumes(MediaType.APPLICATION_JSON)
@Timed
public Response write(DtoRequest message) {</p>

<pre><code>this.messageProducer.send(message);
return Response.ok().build();
</code></pre>

<p>}
```</p>

<p>Avec la configuration Spring suivante :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:metrics="http://www.ryantenney.com/schema/metrics"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd
              http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;

&lt;metrics:metric-registry id="metrics" /&gt;

&lt;metrics:annotation-driven metric-registry="metrics" /&gt;

&lt;metrics:reporter type="jmx" metric-registry="metrics" /&gt;
...
</code></pre>

<p></beans>
```</p>

<p>Pour montrer que je ne mens pas, on a donc (ici, utilisation de Hawt.io via Jolokia) :</p>

<p><img src="http://4.bp.blogspot.com/-CZebCZS47aE/Ux8fk-EwKQI/AAAAAAAABRY/C7OwMBMZNEc/s1600/si-hawtio-connextion.png" alt="medium" /></p>

<p><img src="http://2.bp.blogspot.com/-H-LmsIrivjA/Ux8fo7ORYpI/AAAAAAAABRg/EIp_-F6LzF4/s1600/si-hawtio-metrics.png" alt="medium" /></p>

<p>On constate encore une fois la simplicité de la chose!</p>

<h2>Intégration de Jolokia</h2>

<p>De même que pour notre paragraphe précédent, l'intégration de Jolokia se fera ici par configuration Spring plutôt que de manière programmatique.</p>

<p>Pour ce faire, il suffit de tirer la dépendance <strong>&lsquo;org.jolokia&rsquo;, name: &lsquo;jolokia-spring&rsquo;, version:&lsquo;1.1.2&rsquo;</strong> au lieu de <strong>&lsquo;org.jolokia&rsquo;, name: &lsquo;jolokia-jvm&rsquo;</strong>, et d'ajouter le bon bean à Spring :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:metrics="http://www.ryantenney.com/schema/metrics"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xmlns:jolokia="http://www.jolokia.org/jolokia-spring/schema/config"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd
              http://www.jolokia.org/jolokia-spring/schema/config http://www.jolokia.org/jolokia-spring/schema/config/jolokia-config.xsd
              http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;
    &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
    &lt;property name="locations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/conf.properties&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;jolokia:agent lookupConfig="true" systemPropertiesMode="never"&gt;
    &lt;jolokia:config
            autoStart="true"
            host="${jolokia.host}"
            port="${jolokia.port}"
            user="${jolokia.user}"
            password="${jolokia.password}"/&gt;
&lt;/jolokia:agent&gt;
...
</code></pre>

<p></beans>
```</p>

<p>Et&hellip; c'est tout&hellip; Jolokia est intégré à notre petite stack.</p>

<h2>Intégration de Swagger</h2>

<p>Concernant l'intégration de Swagger, cela ne diffère en rien de mon article précédent. Même problème de CORS, même hack&hellip;</p>

<p><img src="http://4.bp.blogspot.com/-ev6GX1U7SEs/Ux8fxhWTl_I/AAAAAAAABRo/srY62BOqZS4/s1600/si-swagger.png" alt="medium" /></p>

<h2>Branchement des plugins Maven Appassembler et Assembly</h2>

<p>De même que pour Swagger, rien à signaler de particulier par rapport à mon article précédent&hellip; cela fonctionne sans problème ;&ndash;)</p>

<h1>Conclusion</h1>

<p>En conclusion, on peut constater que l'intégration de Spring integration dans notre petite stack est tout aussi trivial que le reste!</p>

<p>Encore une fois, simple et efficace ;&ndash;)</p>

<p>Ainsi, on peut bénéficier du meilleur des deux mondes.</p>

<p>Bien sûr, on peut se poser la question de l'intérêt de brancher quelques choses de véloce (Netty) avec un framework succeptible d'entrainer un Overhead (spring integration) et qui serait, alors, le point de contension. La question est légitime mais je n'y répondrai pas&hellip; ;&ndash;) (pour bien faire, il faudrait faire un benchmark).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty 4, Jackon 2... les mêmes mais en mieux...]]></title>
    <link href="http://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html"/>
    <updated>2014-03-17T08:43:12+01:00</updated>
    <id>http://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais</id>
    <content type="html"><![CDATA[<p><img src="http://3.bp.blogspot.com/-Vzol1CndcjY/Uxib17Rlf2I/AAAAAAAABQI/Qi4u0DWe2s4/s1600/resteasy_jolokia_metrics.png" alt="left-small" /></p>

<p>Pour faire suite à mon <a href="/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">article précédent</a> qui montrait comment il était possible de construire une <em>stack</em> légère basée sur Resteasy-Netty3, Jackson, <a href="http://www.jolokia.org/">Jolokia</a> et <a href="https://helloreverb.com/developers/swagger">Swagger</a>, cet article montrera comment il est possible de faire la même chose avec Resteasy-Netty4 et Jackson 2.</p>

<p>Même si les changements ne sont pas énormes, il y a quand même quelques variantes, et, histoire d'être exhaustif, cela permet de faire le tour complet&hellip; ;&ndash;)</p>

<p>En fait, les seuls points qui diffèrent, par rapport au code précédent, touchent :</p>

<ul>
<li>les dépendances,</li>
<li>l'intégration de Resteasy-netty4,</li>
<li>l'intégration du JacksonConfig (changement d'API coté Jackson),</li>
<li>le support de JodaTime dans Jackson 2,</li>
<li>et le support du CORS dans Resteasy-Netty4.</li>
</ul>


<p>C'est donc ces différents points qui seront abordés dans cet article.</p>

<p>Le code se trouve sur github sur la branche <a href="https://github.com/jetoile/resteasy-netty-sample/tree/netty4">netty4</a>.</p>

<!-- more -->


<h1>Les Dépendances</h1>

<p>Les dépendances utilisées sont les suivantes (au format gradle) :
<code>text
compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson2-provider', version:'3.0.6.Final'
compile group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-joda', version:'2.3.2'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}
</code></p>

<p>On peut y constater depuis la version précédente que netty est passé en version <strong>4.0.17.Final</strong> mais également c'est maintenant l'artefact <strong>resteasy-netty4</strong> qui est utilisé plutôt que <strong>resteasy-netty</strong>. De la même manière, c'est maintenant l'artefact <strong>resteasy-jackson2-provider</strong> plutôt que <strong>resteasy-jackson-provider</strong>.</p>

<p>En outre l'artefact <strong>jackson-datatype-joda</strong> a été ajouté (nous y reviendrons ultérieurement).</p>

<h1>Intégration de Resteasy-netty4</h1>

<p>Afin de remplacer Resteasy-netty 3 par Resteasy-Netty4, il suffit de modifier les dépendances et de supprimer le hack fait précédemment concernant le CORS (ie. la classe <code>RequestHandler</code>) qui est incompatible avec cette nouvelle version.</p>

<p>Une fois cela fait, le programme devrait être de nouveau fonctionnel sans avoir à modifier quoique ce soit (modulo Swagger-UI mais nous y reviendrons ultérieurement.)</p>

<h1>Intégration de Jackson 2</h1>

<p>Comme il a été vu précédemment, c'est maintenant la version de Jackson 2 qui est utilisé plutôt que la 1.</p>

<p>Aussi, il est nécessaire de modifier les packages de Jackson importés : cela n'est à faire que dans la classe <code>JacksonConfig</code>.</p>

<p>Certaines des API ayant également évoluées, la classe <code>JacksonConfig</code> devient :
```java
public class JacksonConfig implements ContextResolver<ObjectMapper> {</p>

<pre><code>private final ObjectMapper objectMapper;

public JacksonConfig() {
    objectMapper = new ObjectMapper();
    objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
}

@Override
public ObjectMapper getContext(Class&lt;?&gt; objectType) {
    return objectMapper;
}
</code></pre>

<p>}
```</p>

<h1>Support de JodaTime dans Jackson 2</h1>

<p>On a vu dans le paragraphe précédent comment il fallait modifier notre code pour utiliser Jackson 2 à la place de Jackson 1.</p>

<p>Cependant, lors d'un :
<code>bash
curl -XGET http://localhost:8081/sample/say/hello
</code></p>

<p>On obtient :
```javascript
{</p>

<pre><code>"message": "hello",
"time": {
    "era": 1,
    "dayOfMonth": 6,
    "dayOfWeek": 4,
    "dayOfYear": 65,
    "weekyear": 2014,
    "weekOfWeekyear": 10,
    "monthOfYear": 3,
    "yearOfEra": 2014,
    "yearOfCentury": 14,
    "centuryOfEra": 20,
    "millisOfSecond": 173,
    "millisOfDay": 53370173,
    "secondOfMinute": 30,
    "secondOfDay": 53370,
    "minuteOfHour": 49,
    "minuteOfDay": 889,
    "hourOfDay": 14,
    "year": 2014,
    "zone": {
        "fixed": false,
        "uncachedZone": {
            "cachable": true,
            "fixed": false,
            "id": "Europe/Paris"
        },
        "id": "Europe/Paris"
    },
    "millis": 1394113770173,
    "chronology": {
        "zone": {
            "fixed": false,
            "uncachedZone": {
                "cachable": true,
                "fixed": false,
                "id": "Europe/Paris"
            },
            "id": "Europe/Paris"
        }
    },
    "afterNow": false,
    "beforeNow": false,
    "equalNow": true
}
</code></pre>

<p>}
```</p>

<p>Pour corriger cela, il suffit d'importer la dépendance <strong>&lsquo;com.fasterxml.jackson.datatype&rsquo;, name: &lsquo;jackson-datatype-joda&rsquo;</strong> et d'ajouter à l'<code>objectMapper</code> le module <code>JodaModule</code> :
<code>java
objectMapper = new ObjectMapper();
objectMapper.registerModule(new JodaModule());
objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  
</code></p>

<p>Ainsi, on obtient bien :
```javascript
{</p>

<pre><code>"message": "hello",
"time": "2014-03-06T13:53:38.714Z"
</code></pre>

<p>}
```</p>

<h1>Support du CORS dans Resteasy-Netty4</h1>

<p>Précédemment, avec Resteast-netty 3, nous avions remarqué un problème de CORS avec Swagger-UI.
Pour en venir à bout, un <em>hack</em> avait été fait mais ce n'était pas très propre&hellip;</p>

<p>Malheureusement, Resteasy-netty4 n'offre pas, non plus, de manière simple pour surmonter ce problème. Heureusement, en fouillant un peu sur internet, un <a href="http://stackoverflow.com/questions/18857546/implement-cross-origin-resource-sharing-cors-on-resteasy-netty-server">article</a> propose de rajouter un <code>ChannelInboundHandler</code> au <em>pipeline</em> Netty.</p>

<p>Cependant, je n'ai pas trouvé de moyen simple de le faire mis à part la surcharge de la méthode&hellip;</p>

<p>Le code obtenu est donc le suivant :</p>

<p>La classe <code>ChannedInboundHandler</code> :
```java
public class CorsHeadersChannelHandler extends SimpleChannelInboundHandler<NettyHttpRequest> {</p>

<pre><code>protected void channelRead0(ChannelHandlerContext ctx, NettyHttpRequest request) throws Exception {
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
    request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");

    ctx.fireChannelRead(request);
}
</code></pre>

<p>}
```</p>

<p>La surcharge de la méthode <code>start()</code> pour ajouter le <em>handler</em> au pipeline Netty (désolé pour le nom&hellip;) :</p>

<p>```java
public class MyNettyJaxrsServer extends NettyJaxrsServer {</p>

<pre><code>private EventLoopGroup eventLoopGroup;
private EventLoopGroup eventExecutor;
private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
private int executorThreadCount = 16;
private SSLContext sslContext;
private int maxRequestSize = 1024 * 1024 * 10;
private int backlog = 128;

@Override
public void setSSLContext(SSLContext sslContext) { this.sslContext = sslContext; }

@Override
public void setIoWorkerCount(int ioWorkerCount) { this.ioWorkerCount = ioWorkerCount; }

@Override
public void setExecutorThreadCount(int executorThreadCount) { this.executorThreadCount =  executorThreadCount; }

@Override
public void setMaxRequestSize(int maxRequestSize) { this.maxRequestSize  = maxRequestSize; }

public void setBacklog(int backlog) { this.backlog = backlog; }

@Override
public void start() {
    eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);
    eventExecutor = new NioEventLoopGroup(executorThreadCount);
    deployment.start();
    final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
    // Configure the server.
    if (sslContext == null) {
        bootstrap.group(eventLoopGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline().addLast(new HttpRequestDecoder());
                        ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
                        ch.pipeline().addLast(new HttpResponseEncoder());
                        ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTP));
                        ch.pipeline().addLast(new CorsHeadersChannelHandler());
                        ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
                        ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
                    }
                })
                .option(ChannelOption.SO_BACKLOG, backlog)
                .childOption(ChannelOption.SO_KEEPALIVE, true);
    } else {
        final SSLEngine engine = sslContext.createSSLEngine();
        engine.setUseClientMode(false);
        bootstrap.group(eventLoopGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline().addFirst(new SslHandler(engine));
                        ch.pipeline().addLast(new HttpRequestDecoder());
                        ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
                        ch.pipeline().addLast(new HttpResponseEncoder());
                        ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTPS));
                        ch.pipeline().addLast(new CorsHeadersChannelHandler());
                        ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
                        ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
                    }
                })
                .option(ChannelOption.SO_BACKLOG, backlog)
                .childOption(ChannelOption.SO_KEEPALIVE, true);
    }
    bootstrap.bind(port).syncUninterruptibly();
}
</code></pre>

<p>}
```</p>

<p>On y observe le rajout du <em>handler</em> :
<code>java
ch.pipeline().addLast(new CorsHeadersChannelHandler());
</code></p>

<p>Enfin, l'initialisation du serveur Resteasy-netty :
<code>java
MyNettyJaxrsServer netty = new MyNettyJaxrsServer();
</code></p>

<h1>Conclusion</h1>

<p>On a vu, dans cet article, comment il était possible d'intégrer JAX-RS avec Netty 4 à l'aide de Resteasy tout en ayant une intégration de Jackson 2.</p>

<p>On a également montré qu'il était possible d'y intégrer très simplement Swagger et Jolokia.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty et bien plus encore... mode d'emploi...]]></title>
    <link href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html"/>
    <updated>2014-03-10T08:03:49+01:00</updated>
    <id>http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode</id>
    <content type="html"><![CDATA[<p><img src="http://1.bp.blogspot.com/-HYBTn5anFdE/Uxdv3cRgu_I/AAAAAAAABP4/gsCZjUIxDyQ/s1600/resteasy_jolokia_metrics.png" alt="left-small" /></p>

<p>L'informatique évolue constamment et c'est également le cas des architectures qui ont tendance à s'orienter de plus en plus vers l'utilisation de services REST. Ces services REST doivent, en outre, être de plus en plus véloces afin de pouvoir répondre à une charge de plus en plus forte (que ce soit d'un point de vue temps de réponse mais également d'un point de vue charge suportée). C'est dans ce contexte que des solutions comme <a href="http://restlet.org/">Restlet</a> ou <a href="http://restx.io/">RestX</a> (pour n'en citer que quelques-unes) ont vu le jour.</p>

<p>En effet, en plus d'offrir la possibilité de servir des services REST, elles s'appuient sur des framework dont la particularité est d'offrir des traitements non bloquant sur les entrées/sorties (NIO).</p>

<p>C'est dans ce contexte que cet article parlera principalement de Resteasy-Netty 3 (la version 3 a été utilisé en raison de contraintes techniques (connexion à <a href="http://cassandra.apache.org/">Apache Cassandra</a> dont le <a href="https://github.com/datastax/java-driver">driver</a> utilise Netty 3)).</p>

<p>Cependant, ce ne sera pas le seul protagoniste car, comme on verra par la suite, il est très simple à utiliser&hellip;</p>

<p>Le vrai sujet de cet article est, en fait, comment il a été possible d'ajouter d'autres framework comme Swagger ou Jolokia à Resteasy-Netty 3.</p>

<p>Cet article sera découpé en deux parties :</p>

<ul>
<li>Besoin et conception</li>
<li>Mise en oeuvre</li>
</ul>


<p>Le code se trouve sur Github <a href="https://github.com/jetoile/resteasy-netty-sample">ici</a>.</p>

<!-- more -->


<h1>Besoin et conception</h1>

<p>Le besoin était d'offrir un ensemble de services REST qui devait être suffisamment véloce pour répondre au besoin de performance en terme de charge mais également en terme de temps de réponse.</p>

<p>Venant du monde Java et plus précisément de Java EE, il aurait été pertinent de partir sur une solution classique à base de <a href="https://jcp.org/en/jsr/detail?id=311">JAX-RS</a> (<a href="https://jersey.java.net/">Jersey</a> ou <a href="http://www.jboss.org/resteasy">RestEasy</a>) hébergée par un <a href="http://tomcat.apache.org/">Tomcat</a> ou un <a href="http://www.eclipse.org/jetty/">Jetty</a>.</p>

<p>Cependant, une crainte était que le mode de fonctionnement des Servlets soit limitant concernant les entrées/sorties. Bien sûr, il était possible d'utiliser le connecteur NIO de Tomcat mais ce n'est pas cette solution qui a été retenue&hellip; ;&ndash;)</p>

<p>Suite à la lecture de l'excellent <a href="http://blog.xebia.fr/2011/11/09/java-nio-et-framework-web-haute-performance/">article</a> sur le retour d'expérience de <a href="https://twitter.com/slemesle">Séven</a> et de <a href="https://twitter.com/julienBuret">Julien</a> lors du challenge USI 2011, le choix a été fait de partir sur une solution basée sur <a href="http://netty.io/">Netty</a>.</p>

<p>Par contre, développer des services directement sur Netty était embêtant et risquait surtout de rebuter l'équipe de développement. De la même manière, introduire un nouveau framework disposant de ses propres API n'était pas préconisé (NDLR : les standards c'est bien ! ;&ndash;) ).</p>

<p>C'est pour cette raison qu'il était préférable de trouver une solution alliant à la fois les avantages de NIO (et si possible s'appuyant sur Netty) et de JAX-RS.</p>

<p>Ainsi, il a été décidé de partir sur Resteasy-Netty 3 qui semblait offrir le meilleur des deux mondes (je dis &ldquo;semblais&rdquo; car aucun comparatif en charge des différents protagonistes n'a été réalisé et les résultats obtenus ont été suffisamment satisfaisant pour n'avoir pas à pousser plus loin l'expérimentation).</p>

<p>L'un des autres avantages de n'avoir pas utiliser un conteneur de Servlet classique était qu'il permettait de rendre le livrable auto-porteur et légé (il aurait bien sûr été possible d'embarquer un Tomcat ou Jetty embedded ou de &ldquo;s'embeddé&rdquo; dans un Tomcat via le goal exec-war de Tomcat7-maven-plugin).</p>

<p>Bien sûr, l'application devait être administrable et supervisable.</p>

<p>Enfin, cerise sur le gateau, intégrer une solution comme <a href="https://helloreverb.com/developers/swagger">Swagger</a> pour documenter les API REST était un <em>&ldquo;nice to have&rdquo;</em>.</p>

<p>Pour notre cas d'exemple, le seul service exposé sera le classique service qui répète ce qu'on lui demande&hellip;</p>

<p>Il répondra donc à une requête de type GET du type :
<code>http://localhost:8081/sample/say/&lt;message&gt;</code></p>

<p>Du coté de la réponse, elle aura la forme suivante :
```javascript
{</p>

<pre><code>"message": &lt;message&gt;,
"time": "2014-03-05T10:55:39.835+01:00"
</code></pre>

<p>}
```</p>

<p>La date de la réponse sera ajoutée juste pour le &ldquo;fun&rdquo; ;&ndash;)</p>

<h1>Mise en oeuvre</h1>

<p>A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :
<code>text
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'
compile group: 'org.codehaus.jackson', name: 'jackson-core-asl', version:'1.9.13'
compile group: 'org.codehaus.jackson', name: 'jackson-mapper-asl', version:'1.9.13'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') { exclude(module: 'jsr305') }
</code></p>

<h2>Implémentation du service REST</h2>

<p>Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial&hellip; et la classe ci-dessous fait humblement l'affaire :</p>

<p>```java
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);

@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortDataSet(@PathParam("msg") String message) {
    DtoResponse response = new DtoResponse();
    try {
        response.setMessage(message);
        response.setTime(DateTime.now());
    } catch (Exception e) {
        log.error("internal error: {}", e);
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
    return Response.ok(response).build();
}
</code></pre>

<p>}
```</p>

<p>Du coté de l'objet retourné par la réponse au format JSON, Jackson intégré à Resteasy a été utilisé pour la partie marshalling/unmarshalling.</p>

<p>Coté gestion des dates, ce sera JodaTime (l'application tourne avec Java 7).</p>

<p>Du coup, un objet DTO a été écrit et annoté à l'aide d'annotations JAXB :</p>

<p>```java
@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
private DateTime time;

public DtoResponse() {}

public String getMessage() { return message;}

public void setMessage(String message) { this.message = message; }

public DateTime getTime() { return time; }

public void setTime(DateTime time) { this.time = time; }
</code></pre>

<p>}
```</p>

<h2>Mise en oeuvre de Resteasy-Netty 3</h2>

<p>Mettre en place Resteasy-Netty 3 est très simple, d'après la <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/pdf/resteasy-reference-guide-en-US.pdf">documnentation</a>, il suffit de faire :</p>

<p><code>java
public static void start(ResteasyDeployment deployment) throws Exception {
  netty = new NettyJaxrsServer();
  netty.setDeployment(deployment);
  netty.setPort(TestPortProvider.getPort());
  netty.setRootResourcePath("");
  netty.setSecurityDomain(null);
  netty.start();
 }
</code></p>

<p>et c'est donc ce que l'on va faire&hellip; ;&ndash;)</p>

<p><a href="http://commons.apache.org/proper/commons-configuration/">Apache commons-configuration</a> a été utilisé afin de déporter la configuration dans un fichier <em>properties</em>.</p>

<p>```java
public class Client {</p>

<pre><code>private final static Logger LOGGER = LoggerFactory.getLogger(Client.class);
private static final String CONF_PROPERTIES = "conf.properties";
private static Configuration config;

public static void main(String[] args) throws ConfigurationException, BootstrapException {
    try {
        config = new PropertiesConfiguration(CONF_PROPERTIES);
    } catch (ConfigurationException e) {
        throw new BootstrapException("bad config", e);
    }
    initServer();
}

private static void initServer() {
    SimpleService service = new SimpleService();
    ResteasyDeployment deployment = new ResteasyDeployment();

    int nettyPort = 8081;

    if (config != null) {
        deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));
        deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));
        deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));
        deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));

        nettyPort = config.getInt("netty.port", TestPortProvider.getPort());
    } else {
        LOGGER.warn("is going to use default netty config");
    }

    deployment.setResources(Arrays.&lt;Object&gt;asList(service));

    NettyJaxrsServer netty = new NettyJaxrsServer();
    netty.setDeployment(deployment);
    netty.setPort(nettyPort);
    netty.setRootResourcePath("");
    netty.setSecurityDomain(null);
    netty.start();
}    
</code></pre>

<p>}
```</p>

<p>On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <code>setResources()</code> sur l'instance de <code>ResteasyDeployment</code> fournit au serveur <strong>NettyJaxrs</strong> :</p>

<p><code>java
SimpleService service = new SimpleService();
ResteasyDeployment deployment = new ResteasyDeployment();
deployment.setResources(Arrays.&lt;Object&gt;asList(service));
NettyJaxrsServer netty = new NettyJaxrsServer();
netty.setDeployment(deployment);
...
netty.start();
</code></p>

<p>Et voilà! On dispose désormais d'un programme exécutable qui démarre un serveur REST basé sur Netty.</p>

<p>Plutôt simple non? ;&ndash;)</p>

<h2>Configuration de Jackson</h2>

<p>Avec le code précédent, si la commande suivante est exécutée :</p>

<p><code>bash
 curl -XGET  http://localhost:8081/sample/say/hello
</code></p>

<p>Le résultat suivant est obtenu :
```javascript
{</p>

<pre><code>"message": "hello",
"time": 1402560438128
</code></pre>

<p>}
```</p>

<p>Hum&hellip; la date n'est pas formatté comme il faut&hellip; pas glop&hellip; :&lsquo;(</p>

<p>En fait, il est possible de modifier la configuration de <a href="http://jackson.codehaus.org/">Jackson</a> et on trouve, dans la littérature, un moyen très simple de le faire en configurant l'<em>ObjectMapper</em> comme suit :
<code>java
objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);
</code></p>

<p>Bien sûr, le but n'étant pas de faire cette transformation manuellement à chaque fois, on préfère laisser Resteasy le gérer lui-même.</p>

<p>Ainsi, il existe <a href="http://stackoverflow.com/questions/19229341/changing-default-json-time-format-with-resteasy-3-x">deux autres</a> manières de faire :</p>

<ul>
<li>Le faire par annotation</li>
<li>Le faire par configuration dans le <code>web.xml</code></li>
</ul>


<p>Cependant, dans notre cas, nous ne disposons pas d'un conteneur de Servlet classique et il n'est donc pas possible de s'appuyer sur une configuration par web.xml. Pour le faire par annotation, j'avoue ne pas avoir testé mais je suis sceptique&hellip;</p>

<p>Du coup, il reste une possibilité qui est de déclarer un <code>JacksonConfig</code> et de demander à Resteasy-Netty de nous l'enregistrer en tant que <em>provider</em> (en gros de demander à Resteasy-Netty de faire manuellement ce qui est fait via le <code>web.xml</code>) :</p>

<p>```java
public class JacksonConfig implements ContextResolver<ObjectMapper> {</p>

<pre><code>private final ObjectMapper objectMapper;

public JacksonConfig() {
    objectMapper = new ObjectMapper();
    objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);
    objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);
}

@Override
public ObjectMapper getContext(Class&lt;?&gt; objectType) {
    return objectMapper;
}
</code></pre>

<p>}
```</p>

<p>Pour l'enregistrement, c'est très simple puisqu'il suffit d'ajouter la ligne suivante :
<code>deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig"));</code></p>

<p>Et voilà! C'est tout!</p>

<p>Encore une fois, simple et efficace et le résultat obtenu est bien celui escompté :
```javascript
{</p>

<pre><code>"message": "hello",
"time": "2014-06-12T10:06:54.553+02:00"
</code></pre>

<p>}
```</p>

<p>A noter que l'<em>ancienne</em> version de Jackson est utilisée ici car c'est celle qui est utilisé par défaut par Resteasy. Il aurait été possible de l'utiliser dans sa version plus récente mais j'avoue ne pas avoir fait l'exercice&hellip; (cf. <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/html/json.html#d4e1046">ici</a>)</p>

<h2>Intégration de Metrics</h2>

<p>Afin de permettre une mesure des temps d'invocation de différentes opérations, la librairie <a href="http://metrics.codahale.com/">Metrics</a> a été utilisée.</p>

<p>Pour plus d'information dessus, le sujet est très bien traité sur le blog de <a href="https://twitter.com/clescot">Charles</a> :</p>

<ul>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-les-bases/">Metrics : Les Bases</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-jee/">Metrics : Intégration Avec JEE</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-spring-et-guice/">Metrics : Intégration Avec Spring Et Guice</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-JDBC-logback-et-jersey/">Metrics : Intégration Avec JDBC, Logback Et Jersey</a></li>
</ul>


<p>Dans notre cas, bien sûr, pas de <em>Spring</em>, de <em>Guice</em> ou de <em>Servlet Listener</em>. Une simple variable de classe dans la classe portant la méthode <code>main()</code> suffit :
```java
public static MetricRegistry metricRegistry;</p>

<p>public static void main(String[] args) throws ConfigurationException, BootstrapException {
   &hellip;</p>

<pre><code>metricRegistry = new MetricRegistry();
final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();
reporter.start();
</code></pre>

<p>}
```</p>

<p>Concernant l'utilisation à proprement parler, cela se fait de cette manière (dans notre cas, utilisation du <strong>Timer</strong> qui représente un histogramme des durées et une mesure de la fréquence d’apparition) :
```java
@GET
@Path(&ldquo;/say/{msg}&rdquo;)
@Produces(MediaType.APPLICATION_JSON)
public Response getPortDataSet(@PathParam(&ldquo;msg&rdquo;) String message) {</p>

<pre><code>final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));
final Timer.Context context = timer.time();
try {
</code></pre>

<p>  &hellip;</p>

<pre><code>    return Response.ok(response).build();
} finally {
    if (context != null) context.stop();
}
</code></pre>

<p>}
```</p>

<p>Une fois l'application démarrée et après 1 ou 2 appels, l'ObjectName apparait dans la console JMX et il est alors possible de voir les différents résultats.</p>

<p><img src="http://1.bp.blogspot.com/-RMh6acQ8Qkc/UxdsRqymVkI/AAAAAAAABPk/r3rvWdgPNtg/s1600/metrics-hawtio.png" alt="medium" /></p>

<p>On constate encore une fois que la mise en place de Metrics n'a demandé aucun effort particulier.</p>

<h2>Intégration de Jolokia</h2>

<p>Une autre étape de notre périple consiste à activer Jolokia que j'ai déjà présenté dans un <a href="/2014/03/jolokia-le-piment-qui-vous-veut-du-bien.html">article précédent</a>.</p>

<p>Dans notre cas d'usage, cela sera fait de manière programmatique.</p>

<p>Pour ce faire, c'est encore une fois très simple et il suffit d'ajouter le code suivant dans notre classe principale :
```java
private static void initJolokiaServer() {</p>

<pre><code>try {
    JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());

    JolokiaServer jolokiaServer = new JolokiaServer(config, true);
    jolokiaServer.start();
} catch (Exception e) {
    LOGGER.error("unable to start jolokia server", e);
}
</code></pre>

<p>}
```</p>

<p>Concernant sa configuration, pour éviter d'avoir à aller chercher des properties et à repeupler une Map, le fichier par défaut (<code>default-jolokia-agent.properties</code>) a été copié (en renseignant certaines informations comme le user/password) dans le répertoire <code>src/main/resources</code> :
```text</p>

<h1>Configuration properties for the JVM jolokia-agent</h1>

<h1>Host address to bind to.</h1>

<h1>Default: localhost, determinated dynamically via InetAddress.getLocalHost()</h1>

<p>host=0.0.0.0</p>

<h1>Port to listen to</h1>

<p>port=7778</p>

<h1>Context path</h1>

<p>agentContext=/jolokia</p>

<h1>Backlog of request to keep when queue</h1>

<p>backlog=10</p>

<h1>Possible values:</h1>

<h1>* &ldquo;fixed&rdquo;  : Thread pool with at max nrThreads</h1>

<h1>* &ldquo;single&rdquo; : A single thread serves all requests (default)</h1>

<h1>* &ldquo;cached&rdquo; : A thread pool which reuses threads and creates threads on demand (unbounded)</h1>

<h1>executor=fixed</h1>

<h1>nrThreads=5</h1>

<h1>User and password for basic authentication</h1>

<p>user=jolokia
password=jolokia</p>

<h1>How many entroes to keep in the history</h1>

<p>historyMaxEntries=10</p>

<h1>Switch on debugging</h1>

<p>debug=false</p>

<h1>How many debug entries to keep on the server side which can be queried by JMX</h1>

<p>debugMaxEntries=100</p>

<h1>Maximum traversal depth for serialization of complex objects.</h1>

<p>maxDepth=15</p>

<h1>Maximum size of collections returned during serialization.</h1>

<p>maxCollectionSize=1000</p>

<h1>Maximum number of objects returned by serialization</h1>

<p>maxObjects=0
```</p>

<p>Un petit coup de (le user jolokia et le mot de passe jolokia ont été positionné dans le fichier <em>properties</em>) :
<code>bash
curl -XGET -u jolokia:jolokia http://localhost:7778/jolokia/version
</code></p>

<p>nous permet bien d'obtenir la réponse attendue :
```javascript
{</p>

<pre><code>"timestamp": 1394036344,
"status": 200,
"request": {
    "type": "version"
},
"value": {
    "protocol": "7.0",
    "agent": "1.1.2",
    "info": {}
}
</code></pre>

<p>}
```</p>

<p>A noter que les user/password ont été positionné car cela permet une connexion via <a href="http://hawt.io/">Hawt.io</a>.</p>

<h2>Intégration de Swagger</h2>

<p><a href="https://helloreverb.com/developers/swagger">Swagger</a> offre une manière très simple de documenter une API REST. En effet, en s'appuyant sur des annotations à mettre dans la classe de service, elle permet d'offrir une interface d'écrivant les API.</p>

<p><img src="http://4.bp.blogspot.com/-92lPQm1F_DM/UxdsgUK3bDI/AAAAAAAABPs/yWh6QRHKkFc/s1600/swagger.png" alt="medium" /></p>

<p>Pour le mettre en place, il suffit donc de rajouter les annotations adéquates à notre classe <code>SimpleService</code> :</p>

<p>```java
@Api(value = &ldquo;/sample&rdquo;, description = &ldquo;the sample api&rdquo;)
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);

@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
@ApiOperation(value = "repeat the word",
        notes = "response the word",
        response = DtoResponse.class)
@ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})
public Response getPortDataSet(@PathParam("msg") String message) {

    final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));
    final Timer.Context context = timer.time();
    try {
        DtoResponse response = new DtoResponse();
        try {
            response.setMessage(message);
            response.setTime(DateTime.now());
        } catch (Exception e) {
            log.error("internal error: {}", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(response).build();
    } finally {
        if (context != null) context.stop();
    }
}
</code></pre>

<p>}
```</p>

<p>Reste maintenant à ajouter Swagger à notre <code>main()</code> que l'on doit faire programmatiquement faute d'être dans un conteneur de Servlet standard&hellip;</p>

<p>Pour ce faire, il est nécessaire d'instancier un objet <code>BeanConfig</code> qui contient la configuration de Swagger mais surtout l'adresse et le port du serveur sur lequel tourne le service ainsi que le package où se trouve ce dernier. Ces informations sont renseignées, dans notre cas, dans notre fichier de configuration et positionnées programmatiquement dans notre <code>BeanConfig</code>.</p>

<p>Enfin, il faut trouver le moyen de faire le pendant de ce qui est déclaré sur <a href="https://github.com/wordnik/swagger-core/wiki/Servlet-Quickstart">cette page</a>&hellip; bien sûr, le tout sans Servlet&hellip; ouch&hellip; :&lsquo;( En fouillant un peu, on tombe rapidement sur le <a href="https://github.com/wordnik/swagger-core/wiki/Java-CXF-Quickstart">quickstart swagger/cxf</a> où les <em>providers</em> sont positionnés : il suffit de faire pareil avec Resteasy-Netty ;&ndash;)</p>

<p>```java
private static void initSwagger(ResteasyDeployment deployment) {</p>

<pre><code>BeanConfig swaggerConfig = new BeanConfig();
swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));
swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));
swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));
swaggerConfig.setScan(true);
swaggerConfig.setResourcePackage("fr.jetoile.sample.service");

deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig",
        "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",
        "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));
deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));
deployment.setSecurityEnabled(false);
</code></pre>

<p>}
```</p>

<p>Et voilà, ça fonctionne!</p>

<p>En exécutant la commande :
<code>bash
curl -XGET http://localhost:8081/api-docs/sample
</code></p>

<p>On obtient bien le JSON escompté :
```javascript
{</p>

<pre><code>"apiVersion": "1.0.0",
"swaggerVersion": "1.2",
"basePath": "http://localhost:8081",
"resourcePath": "/sample",
"apis": [
    {
        "path": "/sample/say/{msg}",
        "operations": [
            {
                "method": "GET",
                "summary": "repeat the word",
                "notes": "response the word",
                "type": "DtoResponse",
                "nickname": "getPortDataSet",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "msg",
                        "required": true,
                        "allowMultiple": false,
                        "type": "string",
                        "paramType": "path"
                    }
                ],
                "responseMessages": [
                    {
                        "code": 500,
                        "message": "Internal server error"
                    }
                ]
            }
        ]
    }
],
"models": {
    "DtoResponse": {
        "id": "DtoResponse",
        "properties": {
            "message": {
                "type": "string"
            },
            "time": {
                "$ref": "DateTime"
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Mais (car il y a un mais&hellip;) en utilisant <a href="https://github.com/wordnik/swagger-ui">Swagger-UI</a> (qu'il faut déployer sur un apache/nginx/tomcat ou autre), il peut arriver que cela ne fonctionne pas&hellip; )(ie. que Swagger-IU n'arrive pas à fetcher les ressources de notre service REST). Cela arrivera d'ailleurs sûrement si notre application est déployée sur une machine différente de celle où est déployée Swagger-UI (pour rappel, on ne dispose pas, ici, d'un conteneur de Servlet et exposer des pages statiques n'est pas l'objectif de notre petite application). Le problème vient de notre cher ami, le <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>&hellip; Du coup, il devient nécessaire d'ajouter des <em>headers</em> dans le requête de réponse.</p>

<p>Et c'est là que la tâche se gâte&hellip; En effet, pas de possibilité de positionner un filtre comme avec les Servlets. Pas non plus de possibilité de modifier la configuration de Resteasy-Netty 3 pour lui demander d'ajouter des headers (si cela existe, je n'ai pas trouvé)&hellip;</p>

<p>Du coup, la seule solution a été de patcher sauvagement notre ami Resteasy-Netty 3 en surchargeant une de ses classes pour y ajouter les bons headers&hellip; Pas très classe mais bon&hellip;</p>

<p>Pour ce faire, il suffit de créer dans notre application le package <code>org.jboss.resteasy.plugins.server.netty</code> et d'y copier la classe <code>RequestHandler</code> en y ajoutant les headers utiles :
```java
package org.jboss.resteasy.plugins.server.netty;</p>

<p>import org.jboss.netty.channel.*;
import org.jboss.netty.channel.ChannelHandler.Sharable;
import org.jboss.netty.handler.codec.frame.TooLongFrameException;
import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponseStatus;
import org.jboss.resteasy.logging.Logger;
import org.jboss.resteasy.spi.Failure;</p>

<p>import static org.jboss.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;</p>

<p>/<em>*
 * TODO : hack to add CORS into header
 *
 * {@link org.jboss.netty.channel.SimpleChannelUpstreamHandler} which handles the requests and dispatch them.
 *
 * This class is {@link org.jboss.netty.channel.ChannelHandler.Sharable}.
 *
 * @author The Netty Project
 * @author Andy Taylor (<a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#97;&#110;&#x64;&#121;&#46;&#116;&#x61;&#x79;&#x6c;&#x6f;&#114;&#x40;&#x6a;&#x62;&#x6f;&#115;&#x73;&#46;&#x6f;&#x72;&#103;">&#x61;&#x6e;&#x64;&#121;&#46;&#x74;&#x61;&#121;&#x6c;&#x6f;&#114;&#x40;&#x6a;&#98;&#x6f;&#x73;&#x73;&#46;&#111;&#x72;&#x67;</a>)
 * @author Trustin Lee
 * @author Norman Maurer
 * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
 </em>/
@Sharable
public class RequestHandler extends SimpleChannelUpstreamHandler {</p>

<pre><code>protected final RequestDispatcher dispatcher;
private final static Logger logger = Logger.getLogger(org.jboss.resteasy.plugins.server.netty.RequestHandler.class);

public RequestHandler(RequestDispatcher dispatcher) { this.dispatcher = dispatcher; }

@Override
public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
    if (e.getMessage() instanceof NettyHttpRequest) {
        NettyHttpRequest request = (NettyHttpRequest) e.getMessage();

        //HACK ICI!!!
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");
        //FIN DU HACK

        if (request.is100ContinueExpected()) { send100Continue(e); }

        NettyHttpResponse response = request.getResponse();
        try {
            dispatcher.service(request, response, true);
        } catch (Failure e1) {
            response.reset();
            response.setStatus(e1.getErrorCode());
            return;
        } catch (Exception ex) {
            response.reset();
            response.setStatus(500);
            logger.error("Unexpected", ex);
            return;
        }

        // Write the response.
        ChannelFuture future = e.getChannel().write(response);

        // Close the non-keep-alive connection after the write operation is done.
        if (!request.isKeepAlive()) { future.addListener(ChannelFutureListener.CLOSE); }
    }
}

private void send100Continue(MessageEvent e) {
    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
    e.getChannel().write(response);
}

@Override
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
    // handle the case of to big requests.
    if (e.getCause() instanceof TooLongFrameException) {
        DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE);
        e.getChannel().write(response).addListener(ChannelFutureListener.CLOSE);
    } else {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}
</code></pre>

<p>}
```</p>

<p>Voilà, après ce petit tour de passe passe, notre swagger-UI fonctionne comme un charme ;&ndash;)</p>

<p>Au final, (presque?) simple non? ;&ndash;)</p>

<h2>Branchement des plugins Maven Appassembler et Assembly</h2>

<p>Afin de générer une application utilisable <em>out of the box</em>, le plugin maven <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/">appassembler</a> a été utilisé. Pour ceux qui ne saurait pas ce que c'est, je les invite à regarder soit la documentation officielle soit un article que j'avais fait <a href="/2012/02/petit-focus-sur-2-plugins-maven.html">précédemment</a> (#autopromo ;&ndash;) ).</p>

<p>Ainsi, ici, le goal <code>generate-daemons</code> du plugin a été utilisé :
```xml
<plugin></p>

<pre><code>&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
&lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;
&lt;executions&gt;

    &lt;execution&gt;
        &lt;id&gt;spring-integ-reader&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;generate-daemons&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
            &lt;target&gt;${project.build.directory}/appassembler-jsw&lt;/target&gt;

            &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt;

            &lt;daemons&gt;
                &lt;daemon&gt;
                    &lt;id&gt;${project.name}&lt;/id&gt;
                    &lt;mainClass&gt;fr.jetoile.sample.Client&lt;/mainClass&gt;
                    &lt;commandLineArguments&gt;
                    &lt;/commandLineArguments&gt;
                    &lt;platforms&gt;
                        &lt;platform&gt;jsw&lt;/platform&gt;
                    &lt;/platforms&gt;
                    &lt;generatorConfigurations&gt;
                        &lt;generatorConfiguration&gt;
                            &lt;generator&gt;jsw&lt;/generator&gt;
                            &lt;includes&gt;
                                &lt;include&gt;linux-x86-64&lt;/include&gt;
                                &lt;include&gt;linux-x86-32&lt;/include&gt;
                            &lt;/includes&gt;
                            &lt;configuration&gt;

                                &lt;property&gt;
                                    &lt;name&gt;configuration.directory.in.classpath.first&lt;/name&gt;
                                    &lt;value&gt;conf&lt;/value&gt;
                                &lt;/property&gt;

                            &lt;/configuration&gt;
                        &lt;/generatorConfiguration&gt;
                    &lt;/generatorConfigurations&gt;
                    &lt;jvmSettings&gt;
                        &lt;initialMemorySize&gt;256M&lt;/initialMemorySize&gt;
                        &lt;maxMemorySize&gt;2048M&lt;/maxMemorySize&gt;
                        &lt;systemProperties&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.port=8199&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.authenticate=false
                            &lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.ssl=false&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.local.only=false
                            &lt;/systemProperty&gt;
                        &lt;/systemProperties&gt;
                        &lt;extraArguments&gt;
                            &lt;extraArgument&gt;-Xdebug&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;
                                -Xrunjdwp:transport=dt_socket,address=9999,server=y,suspend=n
                            &lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-server&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+UnlockCommercialFeatures&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+FlightRecorder&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/extraArgument&gt;
                        &lt;/extraArguments&gt;
                    &lt;/jvmSettings&gt;
                &lt;/daemon&gt;
            &lt;/daemons&gt;
        &lt;/configuration&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;

&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<p>En outre, ce plugin ne créant pas le répertoire <code>logs</code> et ne positionnant pas les droits d'exécution sur les fichiers du répertoire bin, le plugin Maven <a href="https://maven.apache.org/plugins/maven-assembly-plugin/">assembly</a> a été utilisé conjointement :
```xml
<plugin></p>

<pre><code>&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
    &lt;descriptors&gt;
        &lt;descriptor&gt;src/main/assembly/descriptor.xml&lt;/descriptor&gt;
    &lt;/descriptors&gt;
    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;

&lt;/configuration&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;assembly&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;single&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
</code></pre>

<p></plugin>
```</p>

<p>Avec le descripteur simple suivant :
```xml
&lt;?xml version=&ldquo;1.0&rdquo;?>
&lt;assembly xmlns=&ldquo;<a href="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2">http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2</a>&rdquo;</p>

<pre><code>      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"&gt;
&lt;id&gt;reader&lt;/id&gt;
&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
&lt;formats&gt;&lt;format&gt;tar.gz&lt;/format&gt;&lt;/formats&gt;

&lt;fileSets&gt;
    &lt;fileSet&gt;
        &lt;directory&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}&lt;/directory&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;excludes&gt;
            &lt;exclude&gt;bin/${project.name}&lt;/exclude&gt;
            &lt;exclude&gt;bin/wrapper-linux-x86-32&lt;/exclude&gt;
            &lt;exclude&gt;bin/wrapper-linux-x86-64&lt;/exclude&gt;
        &lt;/excludes&gt;
        &lt;fileMode&gt;640&lt;/fileMode&gt;
        &lt;directoryMode&gt;750&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
    &lt;fileSet&gt;
        &lt;directory&gt;src/main/assembly&lt;/directory&gt;
        &lt;outputDirectory&gt;/logs&lt;/outputDirectory&gt;
        &lt;excludes&gt;&lt;exclude&gt;*&lt;/exclude&gt;&lt;/excludes&gt;
    &lt;/fileSet&gt;
&lt;/fileSets&gt;

&lt;files&gt;
    &lt;file&gt;
        &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/${project.name}&lt;/source&gt;
        &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;
        &lt;fileMode&gt;750&lt;/fileMode&gt;
    &lt;/file&gt;
    &lt;file&gt;
        &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/wrapper-linux-x86-64&lt;/source&gt;
        &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;
        &lt;fileMode&gt;750&lt;/fileMode&gt;
    &lt;/file&gt;
&lt;/files&gt;
</code></pre>

<p></assembly>
```</p>

<p>Ainsi, l'exécution de la commande suivante :
<code>bash
mvn package
</code></p>

<p>génère un livrable exploitable directement après sa décompression.</p>

<p>Lors d'un <code>mvn release</code>, il sera également automatiquement uploadé sur le <em>Repository Manager</em>.</p>

<h1>Conclusion</h1>

<p>En conclusion, je n'ai pas grand chose à ajouter si ce n'est que j'ai trouvé Resteasy-Netty simple à utiliser et qu'il a été aisé d'y ajouter tout ce qui était nécessaire à notre besoin.</p>

<p>Et le tout de manière simple et efficace pour une solution véloce et légère!</p>

<p>Pour faire encore plus simple, <a href="http://projectlombok.org/">Lombok</a> aurait pu être utilisé mais, de mémoire, en test de Java 8, une incompatibilité est apparue&hellip; à creuser donc pour cette partie&hellip; ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MicroBenchmark : par la pratique]]></title>
    <link href="http://blog.jetoile.fr/2011/03/microbenchmark-par-la-pratique.html"/>
    <updated>2011-03-22T19:17:28+01:00</updated>
    <id>http://blog.jetoile.fr/2011/03/microbenchmark-par-la-pratique</id>
    <content type="html"><![CDATA[<p><img src="https://lh4.googleusercontent.com/-VYpiI5ySjEA/TYKVFQyw27I/AAAAAAAAAU0/XDPtplNTTKQ/s1600/perf03.png" alt="left-small" /></p>

<p>Cet article fait suite à mon article précédent afin de donner mon rapide retour d'expérience sur quelques écueils qui peuvent être commis lors de l'écriture d'un microBenchmark et dans lesquels je suis, bien sûr, tombé :(. Pour remettre dans le contexte, c'est l'écriture de ce benchmark qui a entrainé l'écriture de mon article précédent suite aux résultats que j'ai pu constater et pour lesquels j'ai eu l'aide de mes <a href="/2011/03/microbenchmark-par-la-pratique.html#remerciement">camarades</a>.</p>

<!-- more -->


<h1>Contexte</h1>

<p>Un collègue me disait que le foreach était moins performant qu'une boucle for en raison du fait que l'invocation d'une opération supplémentaire (la méthode <code>next()</code>) rendait l'opération plus lente en raison de la pile de notre cher compteur ordinal (pour ceux qui ne se rappelleraient pas, je vous renvoie sur vos cours d'assembleur ;&ndash;) ), enfin que, du moins, en .Net ça marchait comme ça. Ma réponse : <em>&ldquo;ben j'en sais rien&rdquo;</em> puisque je ne savais pas quelles étaient les optimisations faites par le compilateur (ouais, je sais, super les sujets de conversation&hellip;).</p>

<p>Du coup, ni une, ni deux, j'ai ouvert mon IDE préféré et j'y ai jeté quelques lignes de code pour avoir ma réponse, et là&hellip; ce fut le drame&hellip; : des résultats bizarres sont apparus&hellip;</p>

<p>Ce petit article a donc pour objectif de vous fournir le résultat de ce qu'il faut faire et ne pas faire lors de l'écriture d'un microBenchmark mais également de fournir la réponse que tout le monde attend, à savoir : <strong>qui est réellement le plus fort entre le for et le foreach</strong> (ça peut éviter d'avoir à perdre 5 minutes de test&hellip;).</p>

<p>Bien sûr, n'étant pas expert dans ce domaine, il s'agit juste d'un retour d'expérience dont je vous laisse seul juge de la véracité&hellip; ;&ndash;)</p>

<p><u>Premier disclaimer</u> : contrairement à ce que j'ai présenté dans mon <a href="/2011/03/microbenchmark-mode-d.html">post précédent</a>, je n'effectuerai pas, ici, différents tirs sur différentes architectures d'ordinateurs, VM ou avec différentes options. En effet, ce qui m'intéresse dans cet article est d'entrevoir ce qui peut se passer dans la VM et comment cela peut impacter les performances d'un petit bout de code.</p>

<p><u>Deuxième disclaimer</u> : lors de la procédure d'élagage, un coefficient de 0,5 sera utilisé afin de lisser au maximum mes résultats et cela, en raison de pics très importants observés (pics liés, comme nous le verrons par la suite soit, au warm-up de la JVM, soit au GC).</p>

<h1>Procédure de test et analyse</h1>

<h2>Première tentative</h2>

<h3>Scénario</h3>

<p>Ma première tentative de benchmark était la suivante :</p>

<ul>
<li>on instancie une liste d'un chaîne de caractère,</li>
<li>on itère dessus sans rien faire,</li>
<li>on regarde le temps passé.</li>
</ul>


<p>Ce petit test sera exécuté une centaine de fois afin de pouvoir lisser le résultat.</p>

<p>Le code utilisé pour faire ce petit test est le suivant :
```java
public class IterableBenchmark0 {</p>

<pre><code>private final static int NB_ITEM = 100000;
private final static int NB_TEST = 100;

static List&lt;String&gt; list = new ArrayList&lt;String&gt;(NB_ITEM);

static {
    for (int i = 0; i &lt; NB_ITEM; i++) {
        list.add(Integer.toString(i));
    }
}

public static void main(String[] args) {
    Long[] res = new Long[NB_TEST];
    for (int j = 0; j &lt; NB_TEST; j++) {

        long startTime = System.nanoTime();
        for (int i = 0; i &lt; list.size(); i++) {
        }

        // for (String value : list) {
        // }

        // int i = 0;
        // while (i &lt; list.size()) {
        // i++;
        // }

        res[j] = (System.nanoTime() - startTime);
    }

    long total = 0;
    for (int j = 0; j &lt; NB_TEST; j++) {
        total += res[j];
        System.out.println(res[j]);
    }
    System.out.println("sum : " + total);
    System.out.println("moy : " + total / NB_TEST);
}
</code></pre>

<p>}
```</p>

<p>On y constate, bien sûr, que la récupération des métriques n’encadre que l’opération à tester mais, également, que l’instanciation et l’initialisation de l’<code>ArrayList</code> utilisé ici sont faites en dehors du test.</p>

<h3>Résultats</h3>

<p>Suite à ce test, les résultats obtenus ont été les suivants :
<img src="https://lh5.googleusercontent.com/-lI9NU2jROeg/TYfWEzjCs-I/AAAAAAAAAU8/9qW3rgg2xJM/s1600/naif_res01.png" alt="center" /></p>

<p><img src="https://lh3.googleusercontent.com/-BjIbhc2E824/TYfWbycgbTI/AAAAAAAAAVA/xi74Zdu2He0/s1600/naif_res02.png" alt="medium" /></p>

<p>Après élagage des résultats abérants (procédé commun à tous tes des charges), ces résultats peuvent être réduits aux résultats suivants (ici, k = 0,5) :
<img src="https://lh5.googleusercontent.com/-Ld9lihH08bE/TYfWw4vaxFI/AAAAAAAAAVE/zVJXILl4wtg/s1600/naif_res03.png" alt="medium" /></p>

<h3>Analyse</h3>

<p>Les résultats précédents montrent clairement une différence entre les tirs avec et sans élagages (normal me direz-vous). Cependant, elles apparaissent principalement sur les deux premières itérations de notre boucle chargée d'itérer notre <code>List</code>.</p>

<p>En outre, après élagage, on constate, malgré tout, qu'une nette différence persiste entre les boucles <code>for</code> et <code>while</code> et notre <code>foreach</code>.</p>

<p>A titre informatif, c'est à ce moment là que j'ai dû appeler mes amis (ça ne vous rappelle pas quelque chose&hellip;?)  pour obtenir une analyse plus précise des résultats que je ne comprenais pas&hellip; :(
Du coup (et là, je ne vais pas me fouler ;&ndash;) ), je vous cite les réponses des différents intéressés (et oui, il est possible d'avoir plusieurs amis&hellip; (si cela vous amuse, je vous laisse deviner qui a dit quoi) que je remercie encore une fois ;&ndash;) :</p>

<ul>
<li>première réponse :

<blockquote><p>Ces résultats sont parfaitement logiques.
Pour for et while, la VM s'aperçoit au bout de quelques itérations que la boucle est inutile.</p>

<ul>
<li>on connaît le nombre d'itérations sans avoir besoin d'itérer réellement sur la liste (list.size() est fixe) ;</li>
<li>la boucle n'a aucun &ldquo;side-effect&rdquo; en-dehors.
Du coup, la boucle entière est éliminée, d'où les temps nuls.
Pour for-each, c'est plus compliqué :</li>
<li>La notation syntaxique &ldquo;for-each&rdquo; est compilée sous la forme d'un parcours d'itérateur :
for (Iterator it=list.iterator(); it.hasNext; ) { &hellip; }</li>
</ul>


<p>Du coup, impossible de connaître le nombre d'itérations à l'avance : la JVM est obligée de tout parcourir</p>

<ul>
<li>En plus, pour éviter les modifications concurrentes de la collection (celles qui lancent le fameux  ConcurrentModificationException), la méthode next() effectue des vérifications, qui prennent du temps.</li>
</ul>


<p>Bref, dans ce cas, for-each est moins performant, ou du moins, nettement moins optimisable, que &ldquo;for&rdquo; ou &ldquo;while&rdquo;</p>

<p>Si tu veux un test plus représentatif des performances réelles, moins sujettes à des optimisations agressives, il faut que les boucles aient un &ldquo;side-effect&rdquo; (par exemple, ajouter chaque élément parcouru dans une seconde liste, située en-dehors de la boucle).</p></blockquote></li>
<li>deuxième réponse :

<blockquote><p>(&hellip;) la Hotspot utilise la zone &ldquo;code cache&rdquo; pour cacher des informations à la volée et compiler du code plus optimisé grâce à JIT en fonction des hotspots détectés. Je viens de retrouver un post sur le blog de Sun qui confirme ce mécanisme. Il montre un exemple sur l'optimisation d'une boucle while: <a href="http://blogs.sun.com/ahe/entry/hotspot_and_other_compilers">http://blogs.sun.com/ahe/entry/hotspot_and_other_compilers</a></p></blockquote></li>
<li>troisième réponse :

<blockquote><p>Alors tout d'abord, je pense que comparer le for et le foreach n'a pas de sens en soi&hellip; En effet, il ne faut pas oublier que quand tu écrit ton code Java, celui-ci est compilé en .class (bytecode).</p>

<p>Ces .class sont alors interprétés ou compilés à la volées (par le compilateur Just In Time).</p>

<p>De plus, comme tout micro-benchmark Java, il faut se méfier des résultats.
Tout simplement, le comportement de la JVM (Hotspot) change du tout au tout en fonction des paramètres VM (-server et -client, les cycles d'optimisation&hellip;)</p>

<p>Ensuite, si ton code est fort utilisé, il sera automatiquement &ldquo;inliné&rdquo; par le JIT&hellip;</p>

<p>Je pense que les conclusions à tirer sont claires&hellip; le code testé est erroné : mon Compilateur Planning m'a inliné le code à tester et le fait que les deux premières itérations soit si élevées par rapport aux autres résultats est lié au warm-up de ma JVM.</p></blockquote></li>
</ul>


<p>Je pense que les conclusions à tirer sont claires&hellip; le code testé est erroné : mon Compilateur Planning m'a inliné le code à tester et le fait que les deux premières itérations soit si élevées par rapport aux autres résultats est lié au warm-up de ma JVM.</p>

<h2>Deuxième tentative</h2>

<h3>Scénario</h3>

<p>Du coup, suite à ma première tentative de benchmark infructueuse, deuxième essai en apprenant de mes erreurs&hellip; :</p>

<ul>
<li>on instancie une liste d'un chaîne de caractère,</li>
<li>on itère dessus en ajoutant un effet de bord afin d'empêcher mon Compilateur Planning de m'inliner mon code,</li>
<li>on regarde le temps passé.</li>
</ul>


<p>Comme précédemment, ce petit test sera exécuté une centaine de fois afin de pouvoir lisser le résultat.</p>

<p>Le code utilisé pour faire ce petit test est le suivant :</p>

<p><code>java
public class IterableBenchmark1 {
 
    private final static int NB_ITEM = 100000;
    private final static int NB_TEST = 100;
 
    static List&lt;String&gt; list = new ArrayList&lt;String&gt;(NB_ITEM);
 
    static {
        for (int i = 0; i &lt; NB_ITEM; i++) {
            list.add(Integer.toString(i));
        }
    }
 
    static StringBuilder sideEffect = new StringBuilder();
 
    public static void main(String[] args) {
        Long[] res = new Long[NB_TEST];
        for (int j = 0; j &lt; NB_TEST; j++) {
 
            long startTime = System.nanoTime();
            for (int i = 0; i &lt; list.size(); i++) {
                sideEffect.append(list.get(i));
            }
 
            // for (String value : list) {
            // sideEffect.append(value);
            // }
 
            // int i = 0;
            // while (i &lt; list.size()) {
            // sideEffect.append(list.get(i));
            // i++;
            // }
 
            res[j] = (System.nanoTime() - startTime);
        }
 
        long total = 0;
        for (int j = 0; j &lt; NB_TEST; j++) {
            total += res[j];
            System.out.println(res[j]);
        }
        System.out.println("sum : " + total);
        System.out.println("moy : " + total / NB_TEST);
    }
}
</code></p>

<h3>Résultats</h3>

<p>Suite à ce test, les résultats obtenus ont été les suivants :</p>

<p><img src="https://lh5.googleusercontent.com/--yfx7Mdby8c/TYfXtahEIoI/AAAAAAAAAVI/uscIVmjqEsQ/s1600/sideEffect_res01.png" alt="center" /></p>

<p><img src="https://lh4.googleusercontent.com/-Sze5evxC3P0/TYfX867p4ZI/AAAAAAAAAVM/gZU-aP_AeyY/s1600/sideEffect_res02.png" alt="medium" /></p>

<p>Après élagage des résultats aberrants (procédé commun à tous tests des charges), ces résultats peuvent être réduits aux résultats suivants (ici, k = 0,5) :</p>

<p><img src="https://lh3.googleusercontent.com/-3ekZo0BCGY4/TYfYLLB_TiI/AAAAAAAAAVQ/mz52DXajycg/s1600/sideEffect_res03.png" alt="medium" /></p>

<p>A noter que ce graphique n'est toujours isssu que d'un seul tir&hellip;</p>

<h3>Analyse</h3>

<p>Les résultats semblent enfin cohérents! ouf&hellip;!</p>

<p>En effet, on constate que, mis à part les <strong>GC</strong>, et le <strong>warm-up</strong> de ma VM, mon <em>Compilateur Planning</em> n'a pas réussi à inliner mon code et me fournit, du coup, le résultat attendu.</p>

<p>Après un coup d'élagage me permettant de me débarrasser de mes pics liés au GC, mes courbes sont lissées et se chevauchent même.</p>

<p>Enfin, j'ai ma réponse (mais je garde ça pour plus tard même si je suppose que, du coup, vous connaissez le fin mot de l'histoire!&hellip; mais attendez, ne partez pas&hellip; la suite est intéressante également ;&ndash;))</p>

<h2>Troisième tentative</h2>

<h2>Scénario</h2>

<p>Bon, il est vrai, j'ai obtenu mon résultat sur ma deuxième tentative.</p>

<p>Cependant, pendant la présentation de Joshua Bloch (cf. <a href="/2011/03/microbenchmark-mode-d.html">post précédent</a>), un point m'a particulièrement intéressé : le framework <strong>Caliper</strong>.</p>

<p>En effet, ce framework semble être fait pour répondre aux problématiques des microBenchmark.</p>

<p>Du coup, je vais, ici, montrer comment je l'ai utilisé ainsi que les résultats qu'il m'a fourni.</p>

<p>Deux raisons à cela :</p>

<ul>
<li>valider mes résultats précédents afin de vérifier que je n'ai rien laissé passer&hellip;</li>
<li>m'amuser un peu&hellip; ;&ndash;)</li>
</ul>


<p><u>Disclaimer</u> : cette partie n'abordera ni comment installer, ni comment utiliser Caliper. Elle est juste fournie à titre indicatif.</p>

<p>Le code utilisé pour faire cette troisième tentative est le suivant :</p>

<p><code>java
public class IterableBenchmark2 extends SimpleBenchmark {
 
    private final static int NB_ITEM = 100000;
 
    List list = new ArrayList(NB_ITEM);
    StringBuilder sideEffect = null;
 
    @Override
    protected void setUp() throws Exception {
        for (int i = 0; i &lt; NB_ITEM; i++) {
            list.add(Integer.toString(i));
        }
        sideEffect = new StringBuilder();
    }
 
    public StringBuilder timeFor(int reps) {
        for (int i = 0; i &lt; reps; ++i) {
            for (int j = 0; j &lt; list.size(); j++) {
                sideEffect.append(list.get(j));
            }
        }
        return sideEffect;
    }
 
    public StringBuilder timeForeach(int reps) {
        for (int i = 0; i &lt; reps; ++i) {
            for (String value : list) {
                sideEffect.append(value);
            }
        }
        return sideEffect;
    }
 
    public StringBuilder timeWhile(int reps) {
        for (int i = 0; i &lt; reps; ++i) {
            int j = 0;
            while (j &lt; list.size()) {
                sideEffect.append(list.get(j));
                j++;
            }
        }
        return sideEffect;
    }
 
    public static void main(String[] args) throws Exception {
        Runner.main(IterableBenchmark3.class, args);
    }
}
</code></p>

<p>On remarque ici, que, plutôt que d'exécuter via un script extérieur mon tir, j'ai préféré le faire en invoquant directement le <code>main()</code>.</p>

<h3>Résultats</h3>

<p>Suite à ce test, les résultats obtenus ont été les suivants :</p>

<p><code>text
0% Scenario{vm=java, trial=0, benchmark=For} 3535251,80 ns; σ=197827,29 ns @ 10 trials
33% Scenario{vm=java, trial=0, benchmark=Foreach} 3676070,55 ns; σ=190018,30 ns @ 10 trials
67% Scenario{vm=java, trial=0, benchmark=While} 3508898,75 ns; σ=222565,30 ns @ 10 trials
 
benchmark   ms linear runtime
      For 3,54 ============================
  Foreach 3,68 ==============================
    While 3,51 ============================
 
vm: java
trial: 0
</code></p>

<p><img src="https://lh4.googleusercontent.com/-Z8j93HQc0m4/TYfcBM-QiFI/AAAAAAAAAVU/4IS1Gu0Lon4/s1600/caliper01.png" alt="medium" /></p>

<p>Ces résultats sont donnés avec une seul tir.</p>

<p>Pour montrer comme il est aisé d'effectuer plusieurs tirs avec Caliper (tir qui lance à chaque fois une nouvelle JVM dans un process &ndash; process au sens UNIX du terme &ndash; différent), modifions juste notre méthode <code>main()</code> pour y passer d'autres options :</p>

<p><code>java
public static void main(String[] args) throws Exception {
        Runner.main(IterableBenchmark3.class, new String[] { "--trials", "5"});
    }
</code></p>

<p>Ce qui donne le résultat suivant :</p>

<p><code>text
0% Scenario{vm=java, trial=0, benchmark=For} 3425915,23 ns; σ=207711,73 ns @ 10 trials
 7% Scenario{vm=java, trial=1, benchmark=For} 3453313,87 ns; σ=193613,25 ns @ 10 trials
13% Scenario{vm=java, trial=2, benchmark=For} 3807062,28 ns; σ=278917,43 ns @ 10 trials
20% Scenario{vm=java, trial=3, benchmark=For} 3807244,53 ns; σ=283377,19 ns @ 10 trials
27% Scenario{vm=java, trial=4, benchmark=For} 3808771,58 ns; σ=270090,07 ns @ 10 trials
33% Scenario{vm=java, trial=0, benchmark=Foreach} 3504679,81 ns; σ=190093,88 ns @ 10 trials
40% Scenario{vm=java, trial=1, benchmark=Foreach} 3620052,15 ns; σ=216116,18 ns @ 10 trials
47% Scenario{vm=java, trial=2, benchmark=Foreach} 3519711,06 ns; σ=173384,58 ns @ 10 trials
53% Scenario{vm=java, trial=3, benchmark=Foreach} 3527981,05 ns; σ=232274,54 ns @ 10 trials
60% Scenario{vm=java, trial=4, benchmark=Foreach} 3549837,79 ns; σ=196295,32 ns @ 10 trials
67% Scenario{vm=java, trial=0, benchmark=While} 3628542,80 ns; σ=223275,59 ns @ 10 trials
73% Scenario{vm=java, trial=1, benchmark=While} 3569981,43 ns; σ=225773,17 ns @ 10 trials
80% Scenario{vm=java, trial=2, benchmark=While} 3596601,06 ns; σ=266773,47 ns @ 10 trials
87% Scenario{vm=java, trial=3, benchmark=While} 3493799,14 ns; σ=220276,60 ns @ 10 trials
93% Scenario{vm=java, trial=4, benchmark=While} 3642079,85 ns; σ=185312,29 ns @ 10 trials
 
benchmark trial   ms linear runtime
      For     0 3,43 ==========================
      For     1 3,45 ===========================
      For     2 3,81 =============================
      For     3 3,81 =============================
      For     4 3,81 ==============================
  Foreach     0 3,50 ===========================
  Foreach     1 3,62 ============================
  Foreach     2 3,52 ===========================
  Foreach     3 3,53 ===========================
  Foreach     4 3,55 ===========================
    While     0 3,63 ============================
    While     1 3,57 ============================
    While     2 3,60 ============================
    While     3 3,49 ===========================
    While     4 3,64 ============================
 
vm: java
</code></p>

<p><img src="https://lh6.googleusercontent.com/-0jMElON2GG0/TYfeIplU2lI/AAAAAAAAAVY/8Ws8IPu8_l8/s1600/caliper02.png" alt="medium" /></p>

<p><img src="https://lh3.googleusercontent.com/-Lm7FexMT_jg/TYffb2Hsi3I/AAAAAAAAAVc/xspieQ1S0pc/s1600/caliper021.png" alt="medium" /></p>

<h3>Analyse</h3>

<p>On constate ici que les résultats obtenus avec Caliper sont cohérents avec ceux obtenus précédemment (ie. les résultats sont similaires quelque soit la méthode d'itération), même si on remarque une légère différence due au bruit ajouté par l'utilisation du framework, bruit qui ne doit pas être pris en compte puisque si un tel framework venait à être utilisé, tous les résultats analysés seraient, évidemment, issus de l'utilisation de Caliper. En outre, n'oublions pas qu'il faut raisonner en terme de statistique et non en terme de chiffre pur&hellip;</p>

<h2>Quatrième tentative&hellip; juste pour le fun</h2>

<h3>Scénario</h3>

<p>Cette avant dernière tentative est juste faite pour le fun pour montrer le comportement de Caliper avec un microBenchmark douteux&hellip; ie. notre premier test ;&ndash;).</p>

<p>Aussi, reprenons notre troisième tentative et supprimons les effets de bord :
<code>java
public class IterableBenchmark3 extends SimpleBenchmark {
 
    private final static int NB_ITEM = 100000;
 
    List list = new ArrayList(NB_ITEM);
 
    @Override
    protected void setUp() throws Exception {
        for (int i = 0; i &lt; NB_ITEM; i++) {
            list.add(Integer.toString(i));
        }
    }
 
    public void timeFor(int reps) {
        for (int i = 0; i &lt; reps; ++i) {
            for (int j = 0; j &lt; list.size(); j++) {
            }
        }
    }
 
    public void timeForeach(int reps) {
        for (int i = 0; i &lt; reps; ++i) {
            for (String value : list) {
            }
        }
    }
 
    public void timeWhile(int reps) {
        for (int i = 0; i &lt; reps; ++i) {
            int j = 0;
            while (j &lt; list.size()) {
                j++;
            }
        }
    }
 
    public static void main(String[] args) throws Exception {
        Runner.main(IterableBenchmark3.class, args);
    }
}
</code></p>

<h3>Résultats</h3>

<p>Suite à ce test, les résultats obtenus ont été les suivants :</p>

<p><code>text
0% Scenario{vm=java, trial=0, benchmark=For}  Failed to execute java -cp /home/khanh/eclipse-workspace/benchmark/target/classes:/home/khanh/eclipse-workspace/caliper-read-only/caliper/target/classes:/home/khanh/.m2/repository/com/google/code/gson/gson/1.7-SNAPSHOT/gson-1.7-SNAPSHOT.jar:/home/khanh/.m2/repository/com/google/guava/guava/r07/guava-r07.jar:/home/khanh/.m2/repository/com/google/code/java-allocation-instrumenter/java-allocation-instrumenter/2.0/java-allocation-instrumenter-2.0.jar com.google.caliper.InProcessRunner --warmupMillis 3000 --runMillis 1000 --measurementType TIME --marker //ZxJ/ -Dbenchmark=For fr.soat.blog.benchmark.IterableBenchmark3
starting Scenario{vm=java, trial=0, benchmark=For}
[caliper] [starting warmup]
[caliper] [starting measured section]
Error: Doing 2x as much work didn't take 2x as much time! Is the JIT optimizing away the body of your benchmark?
</code></p>

<h3>Analyse</h3>

<p>La bonne surprise est que Caliper nous indique clairement que JIT a optimisé notre code et que, donc, notre microBenchmark est erroné!</p>

<p>A voir s'il se comporte ainsi avec tous les microBenchmark erronés&hellip;</p>

<h2>Cinquième tentative&hellip; allez, une dernière pour la route</h2>

<h3>Scénario</h3>

<p>Cette dernière tentative permet de voir ce qui se passerait si on désactivait JIT via l'option <code>-Xint</code>.
Pour rappel, l'option Xint permet de :</p>

<blockquote><p>Operate in interpreted-only mode. Compilation to native code is disabled, and all bytecodes are executed by the interpreter. The performance benefits offered by the Java HotSpot Client VM&rsquo;s adaptive compiler will not be present in this mode.</p></blockquote>

<p>Le code utilisé est celui de notre première tentative.</p>

<h3>Résultats</h3>

<p>Suite à ce test, les résultats obtenus ont été les suivants :
<img src="https://lh5.googleusercontent.com/-ADT5BxKL07Y/TYfgAZ0s5aI/AAAAAAAAAVk/8pgxSKpcnL0/s1600/xint_res01.png" alt="center" /></p>

<p><img src="https://lh4.googleusercontent.com/-amtITqXqdR4/TYfgjLGINcI/AAAAAAAAAVo/3R_TdGss_N4/s1600/xint_res02.png" alt="medium" /></p>

<p>Après élagage des résultats aberrants (procédé commun à tous tes des charges), ces résultats peuvent être réduits aux résultats suivants (k = 1) :</p>

<p><img src="https://lh4.googleusercontent.com/-JZbaG93Z9UE/TYfgohOePMI/AAAAAAAAAVs/jgcwFKpjXl8/s1600/xint_res03.png" alt="medium" /></p>

<p>A noter que ce graphique n'est toujours issu que d'un seul tir&hellip;</p>

<h3>Analyse</h3>

<p>Bien sûr, ces résultats ne sont pas du tout représentatifs puisque le byte code est seulement interprété par la JVM et que cela ne représente pas la réalité. Cette dernière tentative n'est présentée qu'à titre indicatif afin de constater les différences qu'il peut y avoir entre le code que l'on écrit (ou compilé) et le code qui est réellement exécuté.</p>

<h1>Conclusion</h1>

<p>Voilà, j'arrive à la fin de mes conclusions que je vous cite en vrac ;&ndash;) :</p>

<ul>
<li>faire un microBenchmark est difficile et cet article ne montre qu'une ébauche des difficultés que cela peut poser,</li>
<li>il est plus simple d'utiliser un outil qui sait bien faire son travail,</li>
<li>il ne faut pas toujours se fier à ce que l'on peut constater : le risque que le cas observé ne soit pas représentatif de la réalité est élevé,
d* e manière générale, on peut dire qu'il y a match nul entre le for et le foreach (en tout cas, dans notre cas de figure!).</li>
</ul>


<p>Bon, un dernier mot : cet article n'apportera rien aux personnes déjà sensibilisées à ce type de problématiques et ce qu'on peut retenir est qu'il ne faut pas tenter d'optimiser inutilement son code (cf. <a href="/2011/03/microbenchmark-mode-d.html">article précédent</a>). Je trouvais juste les résultats intéressants à montrer ;&ndash;)</p>

<p>Ah oui, encore une chose, pour information, mon ordinateur possède les caractéristiques suivantes :</p>

<p><img src="https://lh5.googleusercontent.com/-yR2nGEaMbxE/TYh5vTtnKdI/AAAAAAAAAWA/J4KlOIGwCWc/s1600/ordi01.PNG" alt="medium" /></p>

<h1>Remerciements</h1>

<p>Par ordre alphabétique :
* Zouheir Cadi (@ZouheirCadi),
* <a href="http://thecodersbreakfast.net/">Olivier Croisier</a> (@OlivierCroisier),
* <a href="http://www.opensides.fr/">Arnault Jeanson</a> (@ArnaultJeanson),
* Séven Lemesle (@slemesle)
* et <a href="http://blog.ostyn.fr/">François Ostyn</a> (@ostynf)</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li>Présentation de Joshua Blosh sur Parleys : <a href="http://www.parleys.com/#sl=0&amp;st=5&amp;id=2103">http://www.parleys.com/#sl=0&amp;st=5&amp;id=2103</a></li>
<li>Site du framework Caliper : <a href="http://code.google.com/p/caliper/">http://code.google.com/p/caliper/</a></li>
<li>Présentation de Cliff Click : <a href="http://www.azulsystems.com/events/javaone_2009/session/2009_J1_Benchmark.pdf">http://www.azulsystems.com/events/javaone_2009/session/2009_J1_Benchmark.pdf</a></li>
<li>Page Wiki de Sun sur le microBenchmark : <a href="http://wikis.sun.com/display/HotSpotInternals/MicroBenchmarks">http://wikis.sun.com/display/HotSpotInternals/MicroBenchmarks</a></li>
<li>Page de google Android sur la gestion des perfomances  d’Android : <a href="http://developer.android.com/guide/practices/design/performance.html">http://developer.android.com/guide/practices/design/performance.html</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
