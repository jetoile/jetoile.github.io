---
layout: post
title: "JAXRS, Netty et bien plus encore... mode d'emploi..."
date: 2014-03-10
comments: false
categories:
 - netty
 - java
 - jmx
 - metrics
 - REST
 - perfomance
 - jolokia
 - maven
---

<div class='post'>
<div style="text-align: justify;"><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-HYBTn5anFdE/Uxdv3cRgu_I/AAAAAAAABP4/gsCZjUIxDyQ/s1600/resteasy_jolokia_metrics.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-HYBTn5anFdE/Uxdv3cRgu_I/AAAAAAAABP4/gsCZjUIxDyQ/s1600/resteasy_jolokia_metrics.png" height="211" width="320" /></a></div>L'informatique évolue constamment et c'est également le cas des architectures qui ont tendance à s'orienter de plus en plus vers l'utilisation de services REST. Ces services REST doivent, en outre, être de plus en plus véloces afin de pouvoir répondre à une charge de plus en plus forte (que ce soit d'un point de vue temps de réponse mais également d'un point de vue charge suportée). C'est dans ce contexte que des solutions comme <a href="http://restlet.org/">Restlet</a> ou <a href="http://restx.io/">RestX</a> (pour n'en citer que quelques-unes) ont vu le jour.</div><div style="text-align: justify;">En effet, en plus d'offrir la possibilité de servir des services REST, elles s'appuient sur des framework dont la particularité est d'offrir des traitements non bloquant sur les entrées/sorties (NIO).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">C'est dans ce contexte que cet article parlera principalement de Resteasy-Netty 3 (la version 3 a été utilisé en raison de contraintes techniques (connexion à <a href="http://cassandra.apache.org/">Apache Cassandra</a> dont le <a href="https://github.com/datastax/java-driver">driver</a> utilise Netty 3)).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cependant, ce ne sera pas le seul protagoniste car, comme on verra par la suite, il est très simple à utiliser... </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Le vrai sujet de cet article est, en fait, comment il a été possible d'ajouter d'autres framework comme Swagger ou Jolokia à Resteasy-Netty 3.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cet article sera découpé en deux parties : </div><ul><li style="text-align: justify;">Besoin et conception</li><li style="text-align: justify;">Mise en oeuvre</li></ul><div style="text-align: justify;">Le code se trouve sur Github <a href="https://github.com/jetoile/resteasy-netty-sample">ici</a>.<br /><!-- more --></div><h1>Besoin et conception</h1><div style="text-align: justify;">Le besoin était d'offrir un ensemble de services REST qui devait être suffisamment véloce pour répondre au besoin de performance en terme de charge mais également en terme de temps de réponse.</div><div style="text-align: justify;">Venant du monde Java et plus précisément de Java EE, il aurait été pertinent de partir sur une solution classique à base de <a href="https://jcp.org/en/jsr/detail?id=311">JAX-RS</a> (<a href="https://jersey.java.net/">Jersey</a> ou <a href="http://www.jboss.org/resteasy">RestEasy</a>) hébergée par un <a href="http://tomcat.apache.org/">Tomcat</a> ou un <a href="http://www.eclipse.org/jetty/">Jetty</a>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Cependant, une crainte était que le mode de fonctionnement des Servlets soit limitant concernant les entrées/sorties. Bien sûr, il était possible d'utiliser le connecteur NIO de Tomcat mais ce n'est pas cette solution qui a été retenue... ;-)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Suite à la lecture de l'excellent <a href="http://blog.xebia.fr/2011/11/09/java-nio-et-framework-web-haute-performance/">article</a> sur le retour d'expérience de <a href="https://twitter.com/slemesle">Séven</a> et de <a href="https://twitter.com/julienBuret">Julien</a> lors du challenge USI 2011, le choix a été fait de partir sur une solution basée sur <a href="http://netty.io/">Netty</a>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Par contre, développer des services directement sur Netty était embêtant et risquait surtout de rebuter l'équipe de développement. De la même manière, introduire un nouveau framework disposant de ses propres API n'était pas préconisé (NDLR : les standards c'est bien ! ;-) ).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">C'est pour cette raison qu'il était préférable de trouver une solution alliant à la fois les avantages de NIO (et si possible s'appuyant sur Netty) et de JAX-RS.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, il a été décidé de partir sur Resteasy-Netty 3 qui semblait offrir le meilleur des deux mondes (je dis "semblais" car aucun comparatif en charge des différents protagonistes n'a été réalisé et les résultats obtenus ont été suffisamment satisfaisant pour n'avoir pas à pousser plus loin l'expérimentation).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">L'un des autres avantages de n'avoir pas utiliser un conteneur de Servlet classique était qu'il permettait de rendre le livrable auto-porteur et légé (il aurait bien sûr été possible d'embarquer un Tomcat ou Jetty embedded ou de "s'embeddé" dans un Tomcat via le goal exec-war de Tomcat7-maven-plugin).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Bien sûr, l'application devait être administrable et supervisable.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Enfin, cerise sur le gateau, intégrer une solution comme <a href="https://helloreverb.com/developers/swagger">Swagger</a> pour documenter les API REST était un "<i>nice to have</i>".</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour notre cas d'exemple, le seul service exposé sera le classique service qui répète ce qu'on lui demande...</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il répondra donc à une requête de type GET du type : </div><pre class="brush:bash; wrap-lines: false; auto-links: false">http://localhost:8081/sample/say/&lt;message&gt;<br /></pre><br />Du coté de la réponse, elle aura la forme suivante : <br /><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "message": &lt;message&gt;,<br />    "time": "2014-03-05T10:55:39.835+01:00"<br />}<br /></pre><br />La date de la réponse sera ajoutée juste pour le "fun" ;-) <br /><h1>Mise en oeuvre</h1><div style="text-align: justify;">A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :</div><pre class="brush:text; wrap-lines: false; auto-links: false">compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'<br />compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'<br />compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'<br />compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'<br />compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'<br />compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'<br />compile group: 'org.jboss.resteasy', name: 'resteasy-netty', version:'3.0.6.Final'<br />compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'<br />compile group: 'org.codehaus.jackson', name: 'jackson-core-asl', version:'1.9.13'<br />compile group: 'org.codehaus.jackson', name: 'jackson-mapper-asl', version:'1.9.13'<br />compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'<br />compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'<br />compile group: 'commons-io', name: 'commons-io', version:'2.4'<br />compile group: 'joda-time', name: 'joda-time', version:'2.3'<br />compile(group: 'com.google.guava', name: 'guava', version:'15.0') { exclude(module: 'jsr305') }<br /></pre><h2>Implémentation du service REST</h2><div style="text-align: justify;">Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial... et la classe ci-dessous fait humblement l'affaire : </div><pre class="brush:java; wrap-lines: false; auto-links: false">@Path("/sample")<br />public class SimpleService {<br />    private final static Logger log = LoggerFactory.getLogger(SimpleService.class);<br /><br />    @GET<br />    @Path("/say/{msg}")<br />    @Produces(MediaType.APPLICATION_JSON)<br />    public Response getPortDataSet(@PathParam("msg") String message) {<br />        DtoResponse response = new DtoResponse();<br />        try {<br />            response.setMessage(message);<br />            response.setTime(DateTime.now());<br />        } catch (Exception e) {<br />            log.error("internal error: {}", e);<br />            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();<br />        }<br />        return Response.ok(response).build();<br />    }<br />}<br /></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Du coté de l'objet retourné par la réponse au format JSON, Jackson intégré à Resteasy a été utilisé pour la partie marshalling/unmarshalling.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Coté gestion des dates, ce sera JodaTime (l'application tourne avec Java 7).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Du coup, un objet DTO a été écrit et annoté à l'aide d'annotations JAXB : </div><pre class="brush:java; wrap-lines: false; auto-links: false">@XmlRootElement<br />public class DtoResponse {<br /><br />    private String message;<br />    private DateTime time;<br /><br />    public DtoResponse() {}<br /><br />    public String getMessage() { return message;}<br /><br />    public void setMessage(String message) { this.message = message; }<br /><br />    public DateTime getTime() { return time; }<br /><br />    public void setTime(DateTime time) { this.time = time; }<br />}<br /></pre><h2>Mise en oeuvre de Resteasy-Netty 3</h2><div style="text-align: justify;">Mettre en place Resteasy-Netty 3 est très simple, d'après la <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/pdf/resteasy-reference-guide-en-US.pdf">documentation</a>, il suffit de faire : </div><pre class="brush:java; wrap-lines: false; auto-links: false">public static void start(ResteasyDeployment deployment) throws Exception {<br />  netty = new NettyJaxrsServer();<br />  netty.setDeployment(deployment);<br />  netty.setPort(TestPortProvider.getPort());<br />  netty.setRootResourcePath("");<br />  netty.setSecurityDomain(null);<br />  netty.start();<br /> }<br /> </pre>et c'est donc ce que l'on va faire... ;-)<br /><br /><div style="text-align: justify;"><a href="http://commons.apache.org/proper/commons-configuration/">Apache commons-configuration</a> a été utilisé afin de déporter la configuration dans un fichier <i>properties</i>.</div><br />Pour ce faire, la classe suivante a été utilisée : <br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class Client {<br />    private final static Logger LOGGER = LoggerFactory.getLogger(Client.class);<br />    private static final String CONF_PROPERTIES = "conf.properties";<br />    private static Configuration config;<br /><br />    public static void main(String[] args) throws ConfigurationException, BootstrapException {<br />        try {<br />            config = new PropertiesConfiguration(CONF_PROPERTIES);<br />        } catch (ConfigurationException e) {<br />            throw new BootstrapException("bad config", e);<br />        }<br />        initServer();<br />    }<br /><br />    private static void initServer() {<br />        SimpleService service = new SimpleService();<br />        ResteasyDeployment deployment = new ResteasyDeployment();<br /><br />        int nettyPort = 8081;<br /><br />        if (config != null) {<br />            deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));<br />            deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));<br />            deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));<br />            deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));<br /><br />            nettyPort = config.getInt("netty.port", TestPortProvider.getPort());<br />        } else {<br />            LOGGER.warn("is going to use default netty config");<br />        }<br /><br />        deployment.setResources(Arrays.&lt;Object&gt;asList(service));<br /><br />        NettyJaxrsServer netty = new NettyJaxrsServer();<br />        netty.setDeployment(deployment);<br />        netty.setPort(nettyPort);<br />        netty.setRootResourcePath("");<br />        netty.setSecurityDomain(null);<br />        netty.start();<br />    }<br />}<br /></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <i>setResources()</i> sur l'instance de <i>ResteasyDeployment</i> fournit au serveur <i>NettyJaxrs</i> : </div><pre class="brush:java; wrap-lines: false; auto-links: false">SimpleService service = new SimpleService();<br />ResteasyDeployment deployment = new ResteasyDeployment();<br />deployment.setResources(Arrays.&lt;Object&gt;asList(service));<br />NettyJaxrsServer netty = new NettyJaxrsServer();<br />netty.setDeployment(deployment);<br />...<br />netty.start();<br /></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Et voilà! On dispose désormais d'un programme exécutable qui démarre un serveur REST basé sur Netty.</div><div style="text-align: justify;">Plutôt simple non? ;-) </div><h2>Configuration de Jackson</h2>Avec le code précédent, si la commande suivante est exécutée : <br /><pre class="brush:bash; wrap-lines: false; auto-links: false"> curl -XGET  http://localhost:8081/sample/say/hello <br /> </pre>Le résultat suivant est obtenu : <br /><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "message": "hello",<br />    "time": 1394016168909<br />}<br /></pre><br /><div style="text-align: justify;">Hum... la date n'est pas formatté comme il faut... pas glop... :'(</div><div style="text-align: justify;">En fait, il est possible de modifier la configuration de <a href="http://jackson.codehaus.org/">Jackson</a> et on trouve, dans la littérature, un moyen très simple de le faire en configurant l'<i>ObjectMapper</i> comme suit : </div><pre class="brush:java; wrap-lines: false; auto-links: false">objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);<br /></pre><br /><div style="text-align: justify;">Bien sûr, le but n'étant pas de faire cette transformation manuellement à chaque fois, on préfère laisser Resteasy le gérer lui-même.</div><div style="text-align: justify;">Ainsi, il existe <a href="http://stackoverflow.com/questions/19229341/changing-default-json-time-format-with-resteasy-3-x">deux autres</a> manières de faire : </div><ul><li style="text-align: justify;">Le faire par annotation</li><li style="text-align: justify;">Le faire par configuration dans le <i>web.xml</i></li></ul><div style="text-align: justify;">Cependant, dans notre cas, nous ne disposons pas d'un conteneur de Servlet classique et il n'est donc pas possible de s'appuyer sur une configuration par <i>web.xml</i>. Pour le faire par annotation, j'avoue ne pas avoir testé mais je suis sceptique... </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Du coup, il reste une possibilité qui est de déclarer un <i>JacksonConfig</i> et de demander à Resteasy-Netty de nous l'enregistrer en tant que <i>provider</i> (en gros de demander à Resteasy-Netty de faire manuellement ce qui est fait via le <i>web.xml</i>) :</div><pre class="brush:java; wrap-lines: false; auto-links: false">public class JacksonConfig implements ContextResolver&lt;ObjectMapper&gt; {<br />    private final ObjectMapper objectMapper;<br /><br />    public JacksonConfig() {<br />        objectMapper = new ObjectMapper();<br />        objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);<br />        objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);<br />    }<br /><br />    @Override<br />    public ObjectMapper getContext(Class&lt;?&gt; objectType) {<br />        return objectMapper;<br />    }<br />}<br /></pre><div style="text-align: justify;">Pour l'enregistrement, c'est très simple puisqu'il suffit d'ajouter la ligne suivante :  </div><pre class="brush:java; wrap-lines: false; auto-links: false">deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig"));<br /></pre><br /><div style="text-align: justify;">Et voilà! C'est tout!</div><div style="text-align: justify;">Encore une fois, simple et efficace et le résultat obtenu est bien celui escompté : </div><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "message": "hello",<br />    "time": 1394016168909<br />}<br /></pre><br /><div style="text-align: justify;">A noter que l'<i>ancienne</i> version de Jackson est utilisée ici car c'est celle qui est utilisé par défaut par Resteasy. Il aurait été possible de l'utiliser dans sa version plus récente mais j'avoue ne pas avoir fait l'exercice... (cf. <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/html/json.html#d4e1046">ici</a>) </div><h2 style="text-align: justify;">Intégration de Metrics</h2><div style="text-align: justify;">Afin de permettre une mesure des temps d'invocation de différentes opérations, la librairie <a href="http://metrics.codahale.com/">Metrics</a> a été utilisée. </div><div style="text-align: justify;">Pour plus d'information dessus, le sujet est très bien traité sur le blog de <a href="https://twitter.com/clescot">Charles</a> : </div><ul><li style="text-align: justify;"><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-les-bases/">Metrics : Les Bases</a></li><li style="text-align: justify;"><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-jee/">Metrics : Intégration Avec JEE</a></li><li style="text-align: justify;"><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-spring-et-guice/">Metrics : Intégration Avec Spring Et Guice</a></li><li style="text-align: justify;"><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-JDBC-logback-et-jersey/">Metrics : Intégration Avec JDBC, Logback Et Jersey</a></li></ul><div style="text-align: justify;">Dans notre cas, bien sûr, pas de <i>Spring</i>, de <i>Guice</i> ou de <i>Servlet Listener</i>. Une simple variable de classe dans la classe portant la méthode <i>main()</i> suffit :  </div><pre class="brush:java; wrap-lines: false; auto-links: false">public static MetricRegistry metricRegistry;<br />    <br />public static void main(String[] args) throws ConfigurationException, BootstrapException {<br />   ...<br /><br />    metricRegistry = new MetricRegistry();<br />    final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();<br />    reporter.start();<br />}<br /></pre><br /><div style="text-align: justify;">Concernant l'utilisation à proprement parler, cela se fait de cette manière (dans notre cas, utilisation du <i>Timer</i> qui représente un histogramme des durées et une mesure de la fréquence d’apparition) : </div><pre class="brush:java; wrap-lines: false; auto-links: false">@GET<br />@Path("/say/{msg}")<br />@Produces(MediaType.APPLICATION_JSON)<br />public Response getPortDataSet(@PathParam("msg") String message) {<br /><br />    final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));<br />    final Timer.Context context = timer.time();<br />    try {<br />  ...<br />        return Response.ok(response).build();<br />    } finally {<br />        if (context != null) context.stop();<br />    }<br />}<br /></pre><br /><div style="text-align: justify;">Une fois l'application démarrée et après 1 ou 2 appels, l'<i>ObjectName</i> apparait dans la console JMX et il est alors possible de voir les différents résultats.</div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-RMh6acQ8Qkc/UxdsRqymVkI/AAAAAAAABPk/r3rvWdgPNtg/s1600/metrics-hawtio.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-RMh6acQ8Qkc/UxdsRqymVkI/AAAAAAAABPk/r3rvWdgPNtg/s1600/metrics-hawtio.png" height="483" width="640" /></a></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">On constate encore une fois que la mise en place de Metrics n'a demandé aucun effort particulier. </div><h2>Intégration de Jolokia</h2><div style="text-align: justify;">Une autre étape de notre périple consiste à activer Jolokia que j'ai déjà présenté dans un <a href="http://blog.jetoile.fr/2014/03/jolokia-le-piment-qui-vous-veut-du-bien.html">article précédent</a>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Dans notre cas d'usage, cela sera fait de manière programmatique.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, c'est encore une fois très simple et il suffit d'ajouter le code suivant dans notre classe principale : </div><pre class="brush:java; wrap-lines: false; auto-links: false">private static void initJolokiaServer() {<br />    try {<br />        JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());<br /><br />        JolokiaServer jolokiaServer = new JolokiaServer(config, true);<br />        jolokiaServer.start();<br />    } catch (Exception e) {<br />        LOGGER.error("unable to start jolokia server", e);<br />    }<br />}<br /></pre><br /><div style="text-align: justify;">Concernant sa configuration, pour éviter d'avoir à aller chercher des properties et à repeupler une Map, le fichier par défaut (<i>default-jolokia-agent.properties</i>) a été copié (en renseignant certaines informations comme le user/password) dans le répertoire <i>src/main/resources</i> : </div><pre class="brush:text; wrap-lines: false; auto-links: false"># Configuration properties for the JVM jolokia-agent<br /><br /># Host address to bind to.<br /># Default: localhost, determinated dynamically via InetAddress.getLocalHost()<br />host=0.0.0.0<br /><br /># Port to listen to<br />port=7778<br /><br /># Context path<br />agentContext=/jolokia<br /><br /># Backlog of request to keep when queue<br />backlog=10<br /><br /># Possible values:<br />#  * "fixed"  : Thread pool with at max nrThreads<br />#  * "single" : A single thread serves all requests (default)<br />#  * "cached" : A thread pool which reuses threads and creates threads on demand (unbounded)<br /># executor=fixed<br /># nrThreads=5<br /><br /># User and password for basic authentication<br />user=jolokia<br />password=jolokia<br /><br /># How many entroes to keep in the history<br />historyMaxEntries=10<br /><br /># Switch on debugging<br />debug=false<br /><br /># How many debug entries to keep on the server side which can be queried by JMX<br />debugMaxEntries=100<br /><br /># Maximum traversal depth for serialization of complex objects.<br />maxDepth=15<br /><br /># Maximum size of collections returned during serialization.<br />maxCollectionSize=1000<br /><br /># Maximum number of objects returned by serialization<br />maxObjects=0<br /></pre><br /><div style="text-align: justify;">Un petit coup de (le user jolokia et le mot de passe jolokia ont été positionné dans le fichier <i>properties</i>) : </div><pre class="brush:bash; wrap-lines: false; auto-links: false">curl -XGET -u jolokia:jolokia http://localhost:7778/jolokia/version<br /></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">nous permet bien d'obtenir la réponse attendue : </div><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "timestamp": 1394036344,<br />    "status": 200,<br />    "request": {<br />        "type": "version"<br />    },<br />    "value": {<br />        "protocol": "7.0",<br />        "agent": "1.1.2",<br />        "info": {}<br />    }<br />}<br /></pre><br />A noter que les user/password ont été positionné car cela permet une connexion via <a href="http://hawt.io/">Hawt.io</a>. <br /><h2>Intégration de Swagger</h2><div style="text-align: justify;"><a href="https://helloreverb.com/developers/swagger">Swagger</a> offre une manière très simple de documenter une API REST. En effet, en s'appuyant sur des annotations à mettre dans la classe de service, elle permet d'offrir une interface d'écrivant les API.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-92lPQm1F_DM/UxdsgUK3bDI/AAAAAAAABPs/yWh6QRHKkFc/s1600/swagger.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-92lPQm1F_DM/UxdsgUK3bDI/AAAAAAAABPs/yWh6QRHKkFc/s1600/swagger.png" height="464" width="640" /></a></div><br /></div><div style="text-align: justify;">Pour le mettre en place, il suffit donc de rajouter les annotations adéquates à notre classe <i>SimpleService</i> : </div><pre class="brush:java; wrap-lines: false; auto-links: false">@Api(value = "/sample", description = "the sample api")<br />@Path("/sample")<br />public class SimpleService {<br />    private final static Logger log = LoggerFactory.getLogger(SimpleService.class);<br /><br />    @GET<br />    @Path("/say/{msg}")<br />    @Produces(MediaType.APPLICATION_JSON)<br />    @ApiOperation(value = "repeat the word",<br />            notes = "response the word",<br />            response = DtoResponse.class)<br />    @ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})<br />    public Response getPortDataSet(@PathParam("msg") String message) {<br /><br />        final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));<br />        final Timer.Context context = timer.time();<br />        try {<br />            DtoResponse response = new DtoResponse();<br />            try {<br />                response.setMessage(message);<br />                response.setTime(DateTime.now());<br />            } catch (Exception e) {<br />                log.error("internal error: {}", e);<br />                return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();<br />            }<br />            return Response.ok(response).build();<br />        } finally {<br />            if (context != null) context.stop();<br />        }<br />    }<br />}<br /></pre><br /><div style="text-align: justify;">Reste maintenant à ajouter Swagger à notre <i>main()</i> que l'on doit faire programmatiquement faute d'être dans un conteneur de Servlet standard...</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, il est nécessaire d'instancier un objet <i>BeanConfig</i> qui contient la configuration de Swagger mais surtout l'adresse et le port du serveur sur lequel tourne le service ainsi que le package où se trouve ce dernier. Ces informations sont renseignées, dans notre cas, dans notre fichier de configuration et positionnées programmatiquement dans notre <i>BeanConfig</i>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Enfin, il faut trouver le moyen de faire le pendant de ce qui est déclaré sur <a href="https://github.com/wordnik/swagger-core/wiki/Servlet-Quickstart">cette page</a>... bien sûr, le tout sans Servlet... ouch... :'( En fouillant un peu, on tombe rapidement sur le <a href="https://github.com/wordnik/swagger-core/wiki/Java-CXF-Quickstart">quickstart swagger/cxf</a> où les <i>providers</i> sont positionnés : il suffit de faire pareil avec Resteasy-Netty ;-) </div><pre class="brush:java; wrap-lines: false; auto-links: false">private static void initSwagger(ResteasyDeployment deployment) {<br />    BeanConfig swaggerConfig = new BeanConfig();<br />    swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));<br />    swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));<br />    swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));<br />    swaggerConfig.setScan(true);<br />    swaggerConfig.setResourcePackage("fr.jetoile.sample.service");<br /><br />    deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig",<br />            "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",<br />            "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));<br />    deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));<br />    deployment.setSecurityEnabled(false);<br />}<br /></pre><br /><div style="text-align: justify;">Et voilà, ça fonctionne!</div><div style="text-align: justify;">En exécutant la commande : </div><pre class="brush:bash; wrap-lines: false; auto-links: false">curl -XGET http://localhost:8081/api-docs/sample<br /></pre><br /><div style="text-align: justify;">On obtient bien le JSON escompté : </div><pre class="brush:javascript; wrap-lines: false; auto-links: false">{<br />    "apiVersion": "1.0.0",<br />    "swaggerVersion": "1.2",<br />    "basePath": "http://localhost:8081",<br />    "resourcePath": "/sample",<br />    "apis": [<br />        {<br />            "path": "/sample/say/{msg}",<br />            "operations": [<br />                {<br />                    "method": "GET",<br />                    "summary": "repeat the word",<br />                    "notes": "response the word",<br />                    "type": "DtoResponse",<br />                    "nickname": "getPortDataSet",<br />                    "produces": [<br />                        "application/json"<br />                    ],<br />                    "parameters": [<br />                        {<br />                            "name": "msg",<br />                            "required": true,<br />                            "allowMultiple": false,<br />                            "type": "string",<br />                            "paramType": "path"<br />                        }<br />                    ],<br />                    "responseMessages": [<br />                        {<br />                            "code": 500,<br />                            "message": "Internal server error"<br />                        }<br />                    ]<br />                }<br />            ]<br />        }<br />    ],<br />    "models": {<br />        "DtoResponse": {<br />            "id": "DtoResponse",<br />            "properties": {<br />                "message": {<br />                    "type": "string"<br />                },<br />                "time": {<br />                    "$ref": "DateTime"<br />                }<br />            }<br />        }<br />    }<br />}<br /></pre><br /><div style="text-align: justify;">Mais (car il y a un mais...) en utilisant <a href="https://github.com/wordnik/swagger-ui">Swagger-UI</a> (qu'il faut déployer sur un apache/nginx/tomcat ou autre), il peut arriver que cela ne fonctionne pas... )(ie. que Swagger-IU n'arrive pas à <i>fetcher</i> les ressources de notre service REST). Cela arrivera d'ailleurs sûrement si notre application est déployée sur une machine différente de celle où est déployée Swagger-UI (pour rappel, on ne dispose pas, ici, d'un conteneur de Servlet et exposer des pages statiques n'est pas l'objectif de notre petite application). Le problème vient de notre cher ami, le <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>... Du coup, il devient nécessaire d'ajouter des <i>headers</i> dans le requête de réponse.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Et c'est là que la tâche se gâte... En effet, pas de possibilité de positionner un filtre comme avec les Servlets. Pas non plus de possibilité de modifier la configuration de Resteasy-Netty 3 pour lui demander d'ajouter des headers (si cela existe, je n'ai pas trouvé)... </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Du coup, la seule solution a été de patcher sauvagement notre ami Resteasy-Netty 3 en surchargeant une de ses classes pour y ajouter les bons headers... Pas très classe mais bon...</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour ce faire, il suffit de créer dans notre application le package <b>org.jboss.resteasy.plugins.server.netty</b> et d'y copier la classe <b>RequestHandler</b> en y ajoutant les headers utiles :  </div><pre class="brush:java; wrap-lines: false; auto-links: false">package org.jboss.resteasy.plugins.server.netty;<br /><br />import org.jboss.netty.channel.*;<br />import org.jboss.netty.channel.ChannelHandler.Sharable;<br />import org.jboss.netty.handler.codec.frame.TooLongFrameException;<br />import org.jboss.netty.handler.codec.http.DefaultHttpResponse;<br />import org.jboss.netty.handler.codec.http.HttpResponse;<br />import org.jboss.netty.handler.codec.http.HttpResponseStatus;<br />import org.jboss.resteasy.logging.Logger;<br />import org.jboss.resteasy.spi.Failure;<br /><br />import static org.jboss.netty.handler.codec.http.HttpResponseStatus.CONTINUE;<br />import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;<br /><br />/**<br /> * TODO : hack to add CORS into header<br /> *<br /> * {@link org.jboss.netty.channel.SimpleChannelUpstreamHandler} which handles the requests and dispatch them.<br /> *<br /> * This class is {@link org.jboss.netty.channel.ChannelHandler.Sharable}.<br /> *<br /> * @author <a href="http://www.jboss.org/netty/">The Netty Project</a><br /> * @author Andy Taylor (andy.taylor@jboss.org)<br /> * @author <a href="http://gleamynode.net/">Trustin Lee</a><br /> * @author Norman Maurer<br /> * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $<br /> */<br />@Sharable<br />public class RequestHandler extends SimpleChannelUpstreamHandler {<br />    protected final RequestDispatcher dispatcher;<br />    private final static Logger logger = Logger.getLogger(org.jboss.resteasy.plugins.server.netty.RequestHandler.class);<br /><br />    public RequestHandler(RequestDispatcher dispatcher) { this.dispatcher = dispatcher; }<br /><br />    @Override<br />    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {<br />        if (e.getMessage() instanceof NettyHttpRequest) {<br />            NettyHttpRequest request = (NettyHttpRequest) e.getMessage();<br /><br />            //HACK ICI!!!<br />            request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");<br />            request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");<br />            request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");<br />            //FIN DU HACK<br /><br />            if (request.is100ContinueExpected()) { send100Continue(e); }<br /><br />            NettyHttpResponse response = request.getResponse();<br />            try {<br />                dispatcher.service(request, response, true);<br />            } catch (Failure e1) {<br />                response.reset();<br />                response.setStatus(e1.getErrorCode());<br />                return;<br />            } catch (Exception ex) {<br />                response.reset();<br />                response.setStatus(500);<br />                logger.error("Unexpected", ex);<br />                return;<br />            }<br /><br />            // Write the response.<br />            ChannelFuture future = e.getChannel().write(response);<br /><br />            // Close the non-keep-alive connection after the write operation is done.<br />            if (!request.isKeepAlive()) { future.addListener(ChannelFutureListener.CLOSE); }<br />        }<br />    }<br /><br />    private void send100Continue(MessageEvent e) {<br />        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);<br />        e.getChannel().write(response);<br />    }<br /><br />    @Override<br />    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {<br />        // handle the case of to big requests.<br />        if (e.getCause() instanceof TooLongFrameException) {<br />            DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE);<br />            e.getChannel().write(response).addListener(ChannelFutureListener.CLOSE);<br />        } else {<br />            e.getCause().printStackTrace();<br />            e.getChannel().close();<br />        }<br />    }<br />}<br /></pre><br /><div style="text-align: justify;">Voilà, après ce petit tour de passe passe, notre swagger-UI fonctionne comme un charme ;-)</div><div style="text-align: justify;">Au final, (presque?) simple non? ;-)  </div><h2>Branchement des plugins Maven Appassembler et Assembly</h2><div style="text-align: justify;">Afin de générer une application utilisable <i>out of the box</i>, le plugin maven <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/">appassembler</a> a été utilisé. Pour ceux qui ne saurait pas ce que c'est, je les invite à regarder soit la documentation officielle soit un article que j'avais fait <a href="http://blog.jetoile.fr/2012/02/petit-focus-sur-2-plugins-maven.html">précédemment</a> (#autopromo ;-) ).</div>Ainsi, ici, le goal <i>generate-daemons</i> du plugin a été utilisé : <br /><pre class="brush:xml; wrap-lines: false; auto-links: false">&lt;plugin&gt;<br />    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br />    &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;<br />    &lt;executions&gt;<br /><br />        &lt;execution&gt;<br />            &lt;id&gt;spring-integ-reader&lt;/id&gt;<br />            &lt;phase&gt;package&lt;/phase&gt;<br />            &lt;goals&gt;<br />                &lt;goal&gt;generate-daemons&lt;/goal&gt;<br />            &lt;/goals&gt;<br />            &lt;configuration&gt;<br />                &lt;target&gt;${project.build.directory}/appassembler-jsw&lt;/target&gt;<br /><br />                &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt;<br /><br />                &lt;daemons&gt;<br />                    &lt;daemon&gt;<br />                        &lt;id&gt;${project.name}&lt;/id&gt;<br />                        &lt;mainClass&gt;fr.jetoile.sample.Client&lt;/mainClass&gt;<br />                        &lt;commandLineArguments&gt;<br />                        &lt;/commandLineArguments&gt;<br />                        &lt;platforms&gt;<br />                            &lt;platform&gt;jsw&lt;/platform&gt;<br />                        &lt;/platforms&gt;<br />                        &lt;generatorConfigurations&gt;<br />                            &lt;generatorConfiguration&gt;<br />                                &lt;generator&gt;jsw&lt;/generator&gt;<br />                                &lt;includes&gt;<br />                                    &lt;include&gt;linux-x86-64&lt;/include&gt;<br />                                    &lt;include&gt;linux-x86-32&lt;/include&gt;<br />                                &lt;/includes&gt;<br />                                &lt;configuration&gt;<br /><br />                                    &lt;property&gt;<br />                                        &lt;name&gt;configuration.directory.in.classpath.first&lt;/name&gt;<br />                                        &lt;value&gt;conf&lt;/value&gt;<br />                                    &lt;/property&gt;<br /><br />                                &lt;/configuration&gt;<br />                            &lt;/generatorConfiguration&gt;<br />                        &lt;/generatorConfigurations&gt;<br />                        &lt;jvmSettings&gt;<br />                            &lt;initialMemorySize&gt;256M&lt;/initialMemorySize&gt;<br />                            &lt;maxMemorySize&gt;2048M&lt;/maxMemorySize&gt;<br />                            &lt;systemProperties&gt;<br />                                &lt;systemProperty&gt;com.sun.management.jmxremote&lt;/systemProperty&gt;<br />                                &lt;systemProperty&gt;com.sun.management.jmxremote.port=8199&lt;/systemProperty&gt;<br />                                &lt;systemProperty&gt;com.sun.management.jmxremote.authenticate=false<br />                                &lt;/systemProperty&gt;<br />                                &lt;systemProperty&gt;com.sun.management.jmxremote.ssl=false&lt;/systemProperty&gt;<br />                                &lt;systemProperty&gt;com.sun.management.jmxremote.local.only=false<br />                                &lt;/systemProperty&gt;<br />                            &lt;/systemProperties&gt;<br />                            &lt;extraArguments&gt;<br />                                &lt;extraArgument&gt;-Xdebug&lt;/extraArgument&gt;<br />                                &lt;extraArgument&gt;<br />                                    -Xrunjdwp:transport=dt_socket,address=9999,server=y,suspend=n<br />                                &lt;/extraArgument&gt;<br />                                &lt;extraArgument&gt;-server&lt;/extraArgument&gt;<br />                                &lt;extraArgument&gt;-XX:+UnlockCommercialFeatures&lt;/extraArgument&gt;<br />                                &lt;extraArgument&gt;-XX:+FlightRecorder&lt;/extraArgument&gt;<br />                                &lt;extraArgument&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/extraArgument&gt;<br />                            &lt;/extraArguments&gt;<br />                        &lt;/jvmSettings&gt;<br />                    &lt;/daemon&gt;<br />                &lt;/daemons&gt;<br />            &lt;/configuration&gt;<br />        &lt;/execution&gt;<br />    &lt;/executions&gt;<br />    &lt;configuration&gt;<br /><br />    &lt;/configuration&gt;<br />&lt;/plugin&gt;<br /></pre><br /><div style="text-align: justify;">En outre, ce plugin ne créant pas le répertoire <i>logs</i> et ne positionnant pas les droits d'exécution sur les fichiers du répertoire <i>bin</i>, le plugin Maven <a href="https://maven.apache.org/plugins/maven-assembly-plugin/">assembly</a> a été utilisé conjointement : </div><pre class="brush:xml; wrap-lines: false; auto-links: false">&lt;plugin&gt;<br />    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;<br />    &lt;configuration&gt;<br />        &lt;descriptors&gt;<br />            &lt;descriptor&gt;src/main/assembly/descriptor.xml&lt;/descriptor&gt;<br />        &lt;/descriptors&gt;<br />        &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;<br /><br />    &lt;/configuration&gt;<br />    &lt;executions&gt;<br />        &lt;execution&gt;<br />            &lt;id&gt;assembly&lt;/id&gt;<br />            &lt;phase&gt;package&lt;/phase&gt;<br />            &lt;goals&gt;<br />                &lt;goal&gt;single&lt;/goal&gt;<br />            &lt;/goals&gt;<br />        &lt;/execution&gt;<br />    &lt;/executions&gt;<br />&lt;/plugin&gt;<br /></pre><br />Avec le descripteur simple suivant : <br /><pre class="brush:xml; wrap-lines: false; auto-links: false">&lt;?xml version="1.0"?&gt;<br />&lt;assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2"<br />          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"&gt;<br />    &lt;id&gt;reader&lt;/id&gt;<br />    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;<br />    &lt;formats&gt;&lt;format&gt;tar.gz&lt;/format&gt;&lt;/formats&gt;<br /><br />    &lt;fileSets&gt;<br />        &lt;fileSet&gt;<br />            &lt;directory&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}&lt;/directory&gt;<br />            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;<br />            &lt;excludes&gt;<br />                &lt;exclude&gt;bin/${project.name}&lt;/exclude&gt;<br />                &lt;exclude&gt;bin/wrapper-linux-x86-32&lt;/exclude&gt;<br />                &lt;exclude&gt;bin/wrapper-linux-x86-64&lt;/exclude&gt;<br />            &lt;/excludes&gt;<br />            &lt;fileMode&gt;640&lt;/fileMode&gt;<br />            &lt;directoryMode&gt;750&lt;/directoryMode&gt;<br />        &lt;/fileSet&gt;<br />        &lt;fileSet&gt;<br />            &lt;directory&gt;src/main/assembly&lt;/directory&gt;<br />            &lt;outputDirectory&gt;/logs&lt;/outputDirectory&gt;<br />            &lt;excludes&gt;&lt;exclude&gt;*&lt;/exclude&gt;&lt;/excludes&gt;<br />        &lt;/fileSet&gt;<br />    &lt;/fileSets&gt;<br /><br />    &lt;files&gt;<br />        &lt;file&gt;<br />            &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/${project.name}&lt;/source&gt;<br />            &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;<br />            &lt;fileMode&gt;750&lt;/fileMode&gt;<br />        &lt;/file&gt;<br />        &lt;file&gt;<br />            &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/wrapper-linux-x86-64&lt;/source&gt;<br />            &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;<br />            &lt;fileMode&gt;750&lt;/fileMode&gt;<br />        &lt;/file&gt;<br />    &lt;/files&gt;<br />&lt;/assembly&gt;<br /></pre><br />Ainsi, l'exécution de la commande suivante : <br /><pre class="brush:bash; wrap-lines: false; auto-links: false">mvn package<br /></pre><br /><div style="text-align: justify;">génère un livrable exploitable directement après sa décompression. </div><div style="text-align: justify;">Lors d'un <i>maven release</i>, il sera également automatiquement uploadé sur le <i>Repository Manager</i>.  </div><h1>Conclusion</h1><div style="text-align: justify;">En conclusion, je n'ai pas grand chose à ajouter si ce n'est que j'ai trouvé Resteasy-Netty simple à utiliser et qu'il a été aisé d'y ajouter tout ce qui était nécessaire à notre besoin. </div><div style="text-align: justify;">Et le tout de manière simple et efficace pour une solution véloce et légère! </div><div style="text-align: justify;">Pour faire encore plus simple, <a href="http://projectlombok.org/">Lombok</a> aurait pu être utilisé mais, de mémoire, en test de Java 8, une incompatibilité est apparue... à creuser donc pour cette partie... ;-) </div></div>
