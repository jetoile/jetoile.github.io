---
layout: post
title: "MicroBenchmark : par la pratique"
date: 2011-03-22
comments: false
categories:
 - java
 - perfomance
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="https://lh4.googleusercontent.com/-VYpiI5ySjEA/TYKVFQyw27I/AAAAAAAAAU0/XDPtplNTTKQ/s1600/perf03.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em; text-align: justify;"><img border="0" height="173" src="https://lh4.googleusercontent.com/-VYpiI5ySjEA/TYKVFQyw27I/AAAAAAAAAU0/XDPtplNTTKQ/s1600/perf03.png" width="320" /></a></div>Cet article fait suite à mon article précédent afin de donner mon rapide retour d'expérience sur quelques écueils qui peuvent être commis lors de l'écriture d'un microBenchmark et dans lesquels je suis, bien sûr, tombé :(. Pour remettre dans le contexte, c'est l'écriture de ce benchmark qui a entrainé l'écriture de mon article précédent suite aux résultats que j'ai pu constater et pour lesquels j'ai eu l'aide de&nbsp;<a href="http://jetoile.blogspot.com/2011/03/microbenchmark-par-la-pratique.html#remerciement">mes camarades</a>.<br /><br /><!-- more --><br /><h1>Contexte</h1>Un collègue me&nbsp;disait que le foreach était moins performant qu'une boucle for en raison du fait que l'invocation d'une opération supplémentaire (la méthode next()) rendait l'opération plus lente en raison de la pile de notre cher compteur ordinal (pour ceux qui ne se rappelleraient pas, je vous renvoie sur vos cours d'assembleur ;-) ), enfin que, du moins, en .Net ça marchait comme ça. Ma réponse : "ben j'en sais rien" puisque je ne savais pas quelles étaient les optimisations faites par le compilateur (ouais, je sais, super les sujets de conversation...).<br />Du coup,&nbsp;ni une, ni deux, j'ai ouvert mon IDE préféré et j'y ai jeté quelques lignes de code pour avoir ma réponse, et là... ce fut le drame... : des résultats bizarres sont apparus...<br />Ce petit article a donc pour objectif de vous fournir le résultat de ce qu'il faut faire et ne pas faire lors de l'écriture d'un microBenchmark mais également de fournir la réponse que tout le monde attend, à savoir :&nbsp;<b>qui est réellement le plus fort entre le for et le foreach</b>&nbsp;(ça peut éviter d'avoir à perdre 5 minutes de test...).<br />Bien sûr, n'étant pas expert dans ce domaine, il s'agit juste d'un retour d'expérience dont je vous laisse seul juge de la véracité... ;-)<br /><u>Premier disclaimer</u> : contrairement à ce que j'ai présenté dans mon <a href="http://jetoile.blogspot.com/2011/03/microbenchmark-mode-d.html">post précédent</a>, je n'effectuerai pas, ici, différents tirs sur différentes architectures d'ordinateurs, VM ou avec différentes options. En effet, ce qui m'intéresse dans cet article est d'entrevoir ce qui peut se passer dans la VM et comment cela peut impacter les performances d'un petit bout de code.<br /><u>Deuxième disclaimer</u> : lors de la procédure d'élagage, un coefficient de 0,5 sera utilisé afin de lisser au maximum mes résultats et cela, en raison de pics très importants observés (pics liés, comme nous le verrons par la suite soit, au warm-up de la JVM, soit au GC).<br /><h1>Procédure de test et analyse</h1><h2>Première tentative</h2><h3>Scénario</h3>Ma première tentative de benchmark était la suivante :<br /><ul><li>on instancie une liste d'un chaîne de caractère,</li>
 <li>on itère dessus sans rien faire,</li>
 <li>on regarde le temps passé.</li>
 </ul>Ce petit test sera exécuté une centaine de fois afin de pouvoir lisser le résultat.<br />Le code utilisé pour faire ce petit test est le suivant :<br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class IterableBenchmark0 {
<br />
<br />    private final static int NB_ITEM = 100000;
<br />    private final static int NB_TEST = 100;
<br />
<br />    static List&lt;String&gt; list = new ArrayList&lt;String&gt;(NB_ITEM);
<br />
<br />    static {
<br />        for (int i = 0; i &lt; NB_ITEM; i++) {
<br />            list.add(Integer.toString(i));
<br />        }
<br />    }
<br />
<br />    public static void main(String[] args) {
<br />        Long[] res = new Long[NB_TEST];
<br />        for (int j = 0; j &lt; NB_TEST; j++) {
<br />
<br />            long startTime = System.nanoTime();
<br />            for (int i = 0; i &lt; list.size(); i++) {
<br />            }
<br />
<br />            // for (String value : list) {
<br />            // }
<br />
<br />            // int i = 0;
<br />            // while (i &lt; list.size()) {
<br />            // i++;
<br />            // }
<br />
<br />            res[j] = (System.nanoTime() - startTime);
<br />        }
<br />
<br />        long total = 0;
<br />        for (int j = 0; j &lt; NB_TEST; j++) {
<br />            total += res[j];
<br />            System.out.println(res[j]);
<br />        }
<br />        System.out.println("sum : " + total);
<br />        System.out.println("moy : " + total / NB_TEST);
<br />    }
<br />}</pre>On y constate, bien sûr, que la récupération des métriques n’encadre que l’opération à tester mais, également, que l’instanciation et l’initialisation de l’<i>ArrayList</i> utilisé ici sont faites en dehors du test.<br /><h3>Résultats</h3>Suite à ce test, les résultats obtenus ont été les suivants :<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://lh5.googleusercontent.com/-lI9NU2jROeg/TYfWEzjCs-I/AAAAAAAAAU8/9qW3rgg2xJM/s1600/naif_res01.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="50" src="https://lh5.googleusercontent.com/-lI9NU2jROeg/TYfWEzjCs-I/AAAAAAAAAU8/9qW3rgg2xJM/s320/naif_res01.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-BjIbhc2E824/TYfWbycgbTI/AAAAAAAAAVA/xi74Zdu2He0/s1600/naif_res02.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="192" src="https://lh3.googleusercontent.com/-BjIbhc2E824/TYfWbycgbTI/AAAAAAAAAVA/xi74Zdu2He0/s320/naif_res02.png" width="320" /></a></div>Après élagage des résultats abérants (procédé commun à tous tes des charges), ces résultats peuvent être réduits aux résultats suivants (ici, k = 0,5) :<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://lh5.googleusercontent.com/-Ld9lihH08bE/TYfWw4vaxFI/AAAAAAAAAVE/zVJXILl4wtg/s1600/naif_res03.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="168" src="https://lh5.googleusercontent.com/-Ld9lihH08bE/TYfWw4vaxFI/AAAAAAAAAVE/zVJXILl4wtg/s320/naif_res03.png" width="320" /></a></div>A noter que ce graphique n'a été issu que d'un seul tir... mais, si vous daignez croire mes dires, il est assez représentatif des autres tirs.<br /><h3>Analyse</h3>Les résultats précédents montrent clairement une différence entre les tirs avec et sans élagages (normal me direz-vous). Cependant, elles apparaissent principalement sur les deux premières itérations de notre boucle chargée d'itérer notre <i>List</i>.<br />En outre, après élagage, on constate, malgré tout, qu'une nette différence persiste entre les boucles for et while et notre foreach.<br />A titre informatif, c'est à ce moment là que j'ai dû appeler mes amis (ça ne vous rappelle pas quelque chose...?) &nbsp;pour obtenir une analyse plus précise des résultats que je ne comprenais pas... :(<br />Du coup (et là, je ne vais pas me fouler ;-) ), je vous cite les réponses des différents intéressés (et oui, il est possible d'avoir plusieurs amis... (si cela vous amuse, je vous laisse deviner qui a dit quoi) que je remercie encore une fois ;-) :<br /><ul><li>première réponse :</li>
 </ul><blockquote>Ces résultats sont parfaitement logiques.<br />Pour for et while, la VM s'aperçoit au bout de quelques itérations que la boucle est inutile.<br />- on connaît le nombre d'itérations sans avoir besoin d'itérer réellement sur la liste (list.size() est fixe) ;<br />- la boucle n'a aucun "side-effect" en-dehors.<br />Du coup, la boucle entière est éliminée, d'où les temps nuls.<br />Pour for-each, c'est plus compliqué :<br />- La notation syntaxique "for-each" est compilée sous la forme d'un parcours d'itérateur :<br />for (Iterator it=list.iterator(); it.hasNext; ) { ... }<br />Du coup, impossible de connaître le nombre d'itérations à l'avance : la JVM est obligée de tout parcourir<br />- En plus, pour éviter les modifications concurrentes de la collection (celles qui lancent le fameux ConcurrentModificationException), la méthode next() effectue des vérifications, qui prennent du temps.<br />Bref, dans ce cas, for-each est moins performant, ou du moins, nettement moins optimisable, que "for" ou "while"<br />Si tu veux un test plus représentatif des performances réelles, moins sujettes à des optimisations agressives, il faut que les boucles aient un "side-effect" (par exemple, ajouter chaque élément parcouru dans une seconde liste, située en-dehors de la boucle).</blockquote><ul><li>deuxième réponse :</li>
 </ul><blockquote>(...) la Hotspot utilise la zone "code cache" pour cacher des informations à la volée et compiler du code plus optimisé grâce à JIT en fonction des hotspots détectés.&nbsp;Je viens de retrouver un post sur le blog de Sun qui confirme ce mécanisme. Il montre un exemple sur l'optimisation d'une boucle while:&nbsp;<a _mce_href="http://blogs.sun.com/ahe/entry/hotspot_and_other_compilers" href="http://blogs.sun.com/ahe/entry/hotspot_and_other_compilers">http://blogs.sun.com/ahe/entry/hotspot_and_other_compilers</a></blockquote><ul><li>troisième réponse :</li>
 </ul><blockquote><div>Alors tout d'abord, je pense que comparer le for et le foreach n'a pas de sens en soi...&nbsp;En effet, il ne faut pas oublier que quand tu écrit ton code Java, celui-ci est compilé en .class (bytecode).</div><div>Ces .class sont alors interprétés ou compilés à la volées (par le compilateur Just In Time).&nbsp;</div><div>De plus, comme tout micro-benchmark Java, il faut se méfier des résultats.</div><div>Tout simplement, le comportement de la JVM (Hotspot) change du tout au tout en fonction des&nbsp;paramètres VM (-server et -client, les cycles d'optimisation...)</div><div>Ensuite, si ton code est fort utilisé, il sera automatiquement "inliné" par le JIT...&nbsp;</div></blockquote>Je pense que les conclusions à tirer sont claires... le code testé est erroné : mon Compilateur Planning m'a inliné le code à tester et le fait que les deux premières itérations soit si élevées par rapport aux autres résultats est lié au&nbsp;<b>warm-up</b>&nbsp;de ma JVM.<br /><h2>Deuxième tentative</h2><h3>Scénario</h3>Du coup, suite à ma première tentative de benchmark infructueuse, deuxième essai en apprenant de mes erreurs... :<br /><ul><li>on instancie une liste d'un chaîne de caractère,</li>
 <li>on itère dessus en ajoutant un effet de bord afin d'empêcher mon Compilateur Planning de m'inliner mon code,</li>
 <li>on regarde le temps passé.</li>
 </ul>Comme précédemment, ce petit test sera exécuté une centaine de fois afin de pouvoir lisser le résultat.<br />Le code utilisé pour faire ce petit test est le suivant :<br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class IterableBenchmark1 {
<br />
<br />    private final static int NB_ITEM = 100000;
<br />    private final static int NB_TEST = 100;
<br />
<br />    static List&lt;String&gt; list = new ArrayList&lt;String&gt;(NB_ITEM);
<br />
<br />    static {
<br />        for (int i = 0; i &lt; NB_ITEM; i++) {
<br />            list.add(Integer.toString(i));
<br />        }
<br />    }
<br />
<br />    static StringBuilder sideEffect = new StringBuilder();
<br />
<br />    public static void main(String[] args) {
<br />        Long[] res = new Long[NB_TEST];
<br />        for (int j = 0; j &lt; NB_TEST; j++) {
<br />
<br />            long startTime = System.nanoTime();
<br />            for (int i = 0; i &lt; list.size(); i++) {
<br />                sideEffect.append(list.get(i));
<br />            }
<br />
<br />            // for (String value : list) {
<br />            // sideEffect.append(value);
<br />            // }
<br />
<br />            // int i = 0;
<br />            // while (i &lt; list.size()) {
<br />            // sideEffect.append(list.get(i));
<br />            // i++;
<br />            // }
<br />
<br />            res[j] = (System.nanoTime() - startTime);
<br />        }
<br />
<br />        long total = 0;
<br />        for (int j = 0; j &lt; NB_TEST; j++) {
<br />            total += res[j];
<br />            System.out.println(res[j]);
<br />        }
<br />        System.out.println("sum : " + total);
<br />        System.out.println("moy : " + total / NB_TEST);
<br />    }
<br />}</pre><h3>Résultats</h3>Suite à ce test, les résultats obtenus ont été les suivants :<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://lh5.googleusercontent.com/--yfx7Mdby8c/TYfXtahEIoI/AAAAAAAAAVI/uscIVmjqEsQ/s1600/sideEffect_res01.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="46" src="https://lh5.googleusercontent.com/--yfx7Mdby8c/TYfXtahEIoI/AAAAAAAAAVI/uscIVmjqEsQ/s320/sideEffect_res01.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh4.googleusercontent.com/-Sze5evxC3P0/TYfX867p4ZI/AAAAAAAAAVM/gZU-aP_AeyY/s1600/sideEffect_res02.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="192" src="https://lh4.googleusercontent.com/-Sze5evxC3P0/TYfX867p4ZI/AAAAAAAAAVM/gZU-aP_AeyY/s320/sideEffect_res02.png" width="320" /></a></div>Après élagage des résultats aberrants (procédé commun à tous tests des charges), ces résultats peuvent être réduits aux résultats suivants (ici, k = 0,5) :<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-3ekZo0BCGY4/TYfYLLB_TiI/AAAAAAAAAVQ/mz52DXajycg/s1600/sideEffect_res03.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="168" src="https://lh3.googleusercontent.com/-3ekZo0BCGY4/TYfYLLB_TiI/AAAAAAAAAVQ/mz52DXajycg/s320/sideEffect_res03.png" width="320" /></a></div>A noter que ce graphique n'est toujours isssu que d'un seul tir...<br /><h3>Analyse</h3>Les résultats semblent enfin cohérents! ouf...!<br />En effet, on constate que, mis à part les <b>GC</b>, et le <b>warm-up</b> de ma VM, mon Compilateur Planning n'a pas réussi à inliner mon code et me fournit, du coup, le résultat attendu.<br />Après un coup d'élagage me permettant de me débarrasser de mes pics liés au GC, mes courbes sont lissées et se chevauchent même.<br />Enfin, j'ai ma réponse (mais je garde ça pour plus tard même si je suppose que, du coup, vous connaissez le fin mot de l'histoire!... mais attendez, ne partez pas... la suite est intéressante également ;-))<br /><h2>Troisième tentative</h2><h3>Scénario</h3>Bon, il est vrai, j'ai obtenu mon résultat sur ma deuxième tentative.<br />Cependant, pendant la présentation de Joshua Bloch (cf. <a href="http://jetoile.blogspot.com/2011/03/microbenchmark-mode-d.html">post précédent</a>), un point m'a particulièrement intéressé : le framework <b>Caliper</b>.<br />En effet, ce framework semble être fait pour répondre aux problématiques des microBenchmark.<br />Du coup, je vais, ici, montrer comment je l'ai utilisé ainsi que les résultats qu'il m'a fourni.<br />Deux raisons à cela :<br /><ul><li>valider mes résultats précédents afin de vérifier que je n'ai rien laissé passer...</li>
 <li>m'amuser un peu... ;-)</li>
 </ul><u>Disclaimer</u> :&nbsp;cette partie n'abordera ni comment installer, ni comment utiliser Caliper. Elle est juste fournie à titre indicatif.<br />Le code utilisé pour faire cette troisième tentative est le suivant :<br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class IterableBenchmark2 extends SimpleBenchmark {
<br />
<br />    private final static int NB_ITEM = 100000;
<br />
<br />    List list = new ArrayList(NB_ITEM);
<br />    StringBuilder sideEffect = null;
<br />
<br />    @Override
<br />    protected void setUp() throws Exception {
<br />        for (int i = 0; i &lt; NB_ITEM; i++) {
<br />            list.add(Integer.toString(i));
<br />        }
<br />        sideEffect = new StringBuilder();
<br />    }
<br />
<br />    public StringBuilder timeFor(int reps) {
<br />        for (int i = 0; i &lt; reps; ++i) {
<br />            for (int j = 0; j &lt; list.size(); j++) {
<br />                sideEffect.append(list.get(j));
<br />            }
<br />        }
<br />        return sideEffect;
<br />    }
<br />
<br />    public StringBuilder timeForeach(int reps) {
<br />        for (int i = 0; i &lt; reps; ++i) {
<br />            for (String value : list) {
<br />                sideEffect.append(value);
<br />            }
<br />        }
<br />        return sideEffect;
<br />    }
<br />
<br />    public StringBuilder timeWhile(int reps) {
<br />        for (int i = 0; i &lt; reps; ++i) {
<br />            int j = 0;
<br />            while (j &lt; list.size()) {
<br />                sideEffect.append(list.get(j));
<br />                j++;
<br />            }
<br />        }
<br />        return sideEffect;
<br />    }
<br />
<br />    public static void main(String[] args) throws Exception {
<br />        Runner.main(IterableBenchmark3.class, args);
<br />    }
<br />}</pre>On remarque ici, que, plutôt que d'exécuter via un script extérieur mon tir, j'ai préféré le faire en invoquant directement le <i>main()</i>.<br /><h3>Résultats</h3>Suite à ce test, les résultats obtenus ont été les suivants :<br /><pre class="brush:bash; wrap-lines: false; auto-links: false">0% Scenario{vm=java, trial=0, benchmark=For} 3535251,80 ns; σ=197827,29 ns @ 10 trials
<br />33% Scenario{vm=java, trial=0, benchmark=Foreach} 3676070,55 ns; σ=190018,30 ns @ 10 trials
<br />67% Scenario{vm=java, trial=0, benchmark=While} 3508898,75 ns; σ=222565,30 ns @ 10 trials
<br />
<br />benchmark   ms linear runtime
<br />      For 3,54 ============================
<br />  Foreach 3,68 ==============================
<br />    While 3,51 ============================
<br />
<br />vm: java
<br />trial: 0</pre><div class="separator" style="clear: both; text-align: center;"><a href="https://lh4.googleusercontent.com/-Z8j93HQc0m4/TYfcBM-QiFI/AAAAAAAAAVU/4IS1Gu0Lon4/s1600/caliper01.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="295" src="https://lh4.googleusercontent.com/-Z8j93HQc0m4/TYfcBM-QiFI/AAAAAAAAAVU/4IS1Gu0Lon4/s320/caliper01.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh5.googleusercontent.com/-q4_o_I_LbNw/TYfff5hOmXI/AAAAAAAAAVg/8G7hPEZSc_A/s1600/caliper011.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="59" src="https://lh5.googleusercontent.com/-q4_o_I_LbNw/TYfff5hOmXI/AAAAAAAAAVg/8G7hPEZSc_A/s320/caliper011.png" width="320" /></a></div><br />Ces résultats sont donnés avec une seul tir.<br />Pour montrer comme il est aisé d'effectuer plusieurs tirs avec Caliper (tir qui lance à chaque fois une nouvelle JVM dans un process - process au sens UNIX du terme - différent), modifions juste notre méthode <i>main()</i> pour y passer d'autres options :<br /><pre class="brush:java; wrap-lines: false; auto-links: false">public static void main(String[] args) throws Exception {
<br />        Runner.main(IterableBenchmark3.class, new String[] { "--trials", "5"});
<br />    }
<br /></pre>Ce qui donne le résultat suivant :<br /><pre class="brush:bash; wrap-lines: false; auto-links: false">0% Scenario{vm=java, trial=0, benchmark=For} 3425915,23 ns; σ=207711,73 ns @ 10 trials
<br /> 7% Scenario{vm=java, trial=1, benchmark=For} 3453313,87 ns; σ=193613,25 ns @ 10 trials
<br />13% Scenario{vm=java, trial=2, benchmark=For} 3807062,28 ns; σ=278917,43 ns @ 10 trials
<br />20% Scenario{vm=java, trial=3, benchmark=For} 3807244,53 ns; σ=283377,19 ns @ 10 trials
<br />27% Scenario{vm=java, trial=4, benchmark=For} 3808771,58 ns; σ=270090,07 ns @ 10 trials
<br />33% Scenario{vm=java, trial=0, benchmark=Foreach} 3504679,81 ns; σ=190093,88 ns @ 10 trials
<br />40% Scenario{vm=java, trial=1, benchmark=Foreach} 3620052,15 ns; σ=216116,18 ns @ 10 trials
<br />47% Scenario{vm=java, trial=2, benchmark=Foreach} 3519711,06 ns; σ=173384,58 ns @ 10 trials
<br />53% Scenario{vm=java, trial=3, benchmark=Foreach} 3527981,05 ns; σ=232274,54 ns @ 10 trials
<br />60% Scenario{vm=java, trial=4, benchmark=Foreach} 3549837,79 ns; σ=196295,32 ns @ 10 trials
<br />67% Scenario{vm=java, trial=0, benchmark=While} 3628542,80 ns; σ=223275,59 ns @ 10 trials
<br />73% Scenario{vm=java, trial=1, benchmark=While} 3569981,43 ns; σ=225773,17 ns @ 10 trials
<br />80% Scenario{vm=java, trial=2, benchmark=While} 3596601,06 ns; σ=266773,47 ns @ 10 trials
<br />87% Scenario{vm=java, trial=3, benchmark=While} 3493799,14 ns; σ=220276,60 ns @ 10 trials
<br />93% Scenario{vm=java, trial=4, benchmark=While} 3642079,85 ns; σ=185312,29 ns @ 10 trials
<br />
<br />benchmark trial   ms linear runtime
<br />      For     0 3,43 ==========================
<br />      For     1 3,45 ===========================
<br />      For     2 3,81 =============================
<br />      For     3 3,81 =============================
<br />      For     4 3,81 ==============================
<br />  Foreach     0 3,50 ===========================
<br />  Foreach     1 3,62 ============================
<br />  Foreach     2 3,52 ===========================
<br />  Foreach     3 3,53 ===========================
<br />  Foreach     4 3,55 ===========================
<br />    While     0 3,63 ============================
<br />    While     1 3,57 ============================
<br />    While     2 3,60 ============================
<br />    While     3 3,49 ===========================
<br />    While     4 3,64 ============================
<br />
<br />vm: java</pre><div class="separator" style="clear: both; text-align: center;"><a href="https://lh6.googleusercontent.com/-0jMElON2GG0/TYfeIplU2lI/AAAAAAAAAVY/8Ws8IPu8_l8/s1600/caliper02.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://lh6.googleusercontent.com/-0jMElON2GG0/TYfeIplU2lI/AAAAAAAAAVY/8Ws8IPu8_l8/s320/caliper02.png" width="274" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-Lm7FexMT_jg/TYffb2Hsi3I/AAAAAAAAAVc/xspieQ1S0pc/s1600/caliper021.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="169" src="https://lh3.googleusercontent.com/-Lm7FexMT_jg/TYffb2Hsi3I/AAAAAAAAAVc/xspieQ1S0pc/s320/caliper021.png" width="320" /></a></div><br /><h3>Analyse</h3>On constate ici que les résultats obtenus avec Caliper sont cohérents avec ceux obtenus précédemment (ie. les résultats sont similaires quelque soit la méthode d'itération), même si on remarque une légère différence due au bruit ajouté par l'utilisation du framework, bruit qui ne doit pas être pris en compte puisque si un tel framework venait à être utilisé, tous les résultats analysés seraient, évidemment, issus de l'utilisation de Caliper. En outre, n'oublions pas qu'il faut raisonner en terme de statistique et non en terme de chiffre pur...<br /><h2>Quatrième tentative... juste pour le fun</h2><h3>Scénario</h3>Cette avant dernière tentative est juste faite pour le fun pour montrer le comportement de Caliper avec un microBenchmark douteux... ie. notre premier test ;-).<br />Aussi, reprenons notre troisième tentative et supprimons les effets de bord :<br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class IterableBenchmark3 extends SimpleBenchmark {
<br />
<br />    private final static int NB_ITEM = 100000;
<br />
<br />    List list = new ArrayList(NB_ITEM);
<br />
<br />    @Override
<br />    protected void setUp() throws Exception {
<br />        for (int i = 0; i &lt; NB_ITEM; i++) {
<br />            list.add(Integer.toString(i));
<br />        }
<br />    }
<br />
<br />    public void timeFor(int reps) {
<br />        for (int i = 0; i &lt; reps; ++i) {
<br />            for (int j = 0; j &lt; list.size(); j++) {
<br />            }
<br />        }
<br />    }
<br />
<br />    public void timeForeach(int reps) {
<br />        for (int i = 0; i &lt; reps; ++i) {
<br />            for (String value : list) {
<br />            }
<br />        }
<br />    }
<br />
<br />    public void timeWhile(int reps) {
<br />        for (int i = 0; i &lt; reps; ++i) {
<br />            int j = 0;
<br />            while (j &lt; list.size()) {
<br />                j++;
<br />            }
<br />        }
<br />    }
<br />
<br />    public static void main(String[] args) throws Exception {
<br />        Runner.main(IterableBenchmark3.class, args);
<br />    }
<br />}</pre><h3>Résultats</h3>Suite à ce test, les résultats obtenus ont été les suivants :<br /><pre class="brush:bash; wrap-lines: false; auto-links: false">0% Scenario{vm=java, trial=0, benchmark=For}  Failed to execute java -cp /home/khanh/eclipse-workspace/benchmark/target/classes:/home/khanh/eclipse-workspace/caliper-read-only/caliper/target/classes:/home/khanh/.m2/repository/com/google/code/gson/gson/1.7-SNAPSHOT/gson-1.7-SNAPSHOT.jar:/home/khanh/.m2/repository/com/google/guava/guava/r07/guava-r07.jar:/home/khanh/.m2/repository/com/google/code/java-allocation-instrumenter/java-allocation-instrumenter/2.0/java-allocation-instrumenter-2.0.jar com.google.caliper.InProcessRunner --warmupMillis 3000 --runMillis 1000 --measurementType TIME --marker //ZxJ/ -Dbenchmark=For fr.soat.blog.benchmark.IterableBenchmark3
<br />starting Scenario{vm=java, trial=0, benchmark=For}
<br />[caliper] [starting warmup]
<br />[caliper] [starting measured section]
<br />Error: Doing 2x as much work didn't take 2x as much time! Is the JIT optimizing away the body of your benchmark?</pre><h3>Analyse</h3>La bonne surprise est que Caliper nous indique clairement que JIT a optimisé notre code et que, donc, notre microBenchmark est erroné!<br />A voir s'il se comporte ainsi avec tous les microBenchmark erronés...<br /><h2>Cinquième tentative... allez, une dernière pour la route</h2><h3>Scénario</h3>Cette dernière tentative permet de voir ce qui se passerait si on désactivait JIT via l'option -Xint.<br />Pour rappel, l'option Xint permet de :<br /><blockquote>Operate in interpreted-only mode. Compilation to native code is disabled, and all bytecodes are executed by the interpreter. The performance benefits offered by the Java HotSpot Client VM's adaptive compiler will not be present in this mode.</blockquote>Le code utilisé est celui de notre première tentative.<br /><h3>Résultats</h3>Suite à ce test, les résultats obtenus ont été les suivants :<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://lh5.googleusercontent.com/-ADT5BxKL07Y/TYfgAZ0s5aI/AAAAAAAAAVk/8pgxSKpcnL0/s1600/xint_res01.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="40" src="https://lh5.googleusercontent.com/-ADT5BxKL07Y/TYfgAZ0s5aI/AAAAAAAAAVk/8pgxSKpcnL0/s320/xint_res01.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh4.googleusercontent.com/-amtITqXqdR4/TYfgjLGINcI/AAAAAAAAAVo/3R_TdGss_N4/s1600/xint_res02.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="192" src="https://lh4.googleusercontent.com/-amtITqXqdR4/TYfgjLGINcI/AAAAAAAAAVo/3R_TdGss_N4/s320/xint_res02.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>Après élagage des résultats aberrants (procédé commun à tous tes des charges), ces résultats peuvent être réduits aux résultats suivants (k = 1) :<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://lh4.googleusercontent.com/-JZbaG93Z9UE/TYfgohOePMI/AAAAAAAAAVs/jgcwFKpjXl8/s1600/xint_res03.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="198" src="https://lh4.googleusercontent.com/-JZbaG93Z9UE/TYfgohOePMI/AAAAAAAAAVs/jgcwFKpjXl8/s320/xint_res03.png" width="320" /></a></div>A noter que ce graphique n'est toujours issu que d'un seul tir...<br /><h3>Analyse</h3>Bien sûr, ces résultats ne sont pas du tout représentatifs puisque le byte code est seulement interprété par la JVM et que cela ne représente pas la réalité. Cette dernière tentative n'est présentée qu'à titre indicatif afin de constater les différences qu'il peut y avoir entre le code que l'on écrit (ou compilé) et le code qui est réellement exécuté.<br /><h1>Conclusion</h1>Voilà, j'arrive à la fin de mes conclusions que je vous cite en vrac ;-) :<br /><ul><li>faire un microBenchmark est difficile et cet article ne montre qu'une ébauche des difficultés que cela peut poser,</li>
 <li>il est plus simple d'utiliser un outil qui sait bien faire son travail,</li>
 <li>il ne faut pas toujours se fier à ce que l'on peut constater : le risque que le cas observé ne soit pas représentatif de la réalité est élevé,</li>
 <li>de manière générale, on peut dire qu'il y a match nul entre le for et le foreach (en tout cas, dans notre cas de figure!).</li>
 </ul>Bon, un dernier mot : cet article n'apportera rien aux personnes déjà sensibilisées à ce type de problématiques et ce qu'on peut retenir est qu'il ne faut pas tenter d'optimiser inutilement son code (cf. <a href="http://jetoile.blogspot.com/2011/03/microbenchmark-mode-d.html">article précédent</a>). Je trouvais juste les résultats intéressants à montrer ;-)<br /><br />Ah oui, encore une chose, pour information, mon ordinateur possède les caractéristiques suivantes :<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://lh5.googleusercontent.com/-yR2nGEaMbxE/TYh5vTtnKdI/AAAAAAAAAWA/J4KlOIGwCWc/s1600/ordi01.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="262" src="https://lh5.googleusercontent.com/-yR2nGEaMbxE/TYh5vTtnKdI/AAAAAAAAAWA/J4KlOIGwCWc/s320/ordi01.PNG" width="320" /></a></div><ul></ul><h1 id="remerciement">Remerciements</h1>Par ordre alphabétique :<br /><ul><li>Zouheir Cadi (<b>@ZouheirCadi</b>),&nbsp;</li>
 <li><a href="http://thecodersbreakfast.net/">Olivier Croisier</a> (<b>@OlivierCroisier</b>),&nbsp;</li>
 <li><a href="http://www.opensides.fr/">Arnault Jeanson</a> (<b>@ArnaultJeanson</b>),</li>
 <li>Séven Lemesle (<b>@slemesle</b>)</li>
 <li>et <a href="http://blog.ostyn.fr/">François Ostyn</a> (<b>@ostynf</b>)</li>
 </ul><h1>Pour aller plus loin...</h1><div style="text-align: justify;"><ul><li><b>Présentation de Joshua Blosh sur Parleys</b> : <a href="http://www.parleys.com/#sl=0&amp;st=5&amp;id=2103">http://www.parleys.com/#sl=0&amp;st=5&amp;id=2103</a></li>
 <li><b>Site du framework Caliper</b> : <a href="http://code.google.com/p/caliper/">http://code.google.com/p/caliper/</a></li>
 <li><b>Présentation de Cliff Click</b> : <a href="http://www.azulsystems.com/events/javaone_2009/session/2009_J1_Benchmark.pdf">http://www.azulsystems.com/events/javaone_2009/session/2009_J1_Benchmark.pdf</a></li>
 <li><b>Page Wiki de Sun sur le microBenchmark</b> : <a href="http://wikis.sun.com/display/HotSpotInternals/MicroBenchmarks">http://wikis.sun.com/display/HotSpotInternals/MicroBenchmarks</a></li>
 <li><b>Page de google Android sur la gestion des perfomances&nbsp; d’Android</b> : <a href="http://developer.android.com/guide/practices/design/performance.html">http://developer.android.com/guide/practices/design/performance.html</a></li>
 </ul></div></div>
