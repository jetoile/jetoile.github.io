<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: maven | Jetoile]]></title>
  <link href="http://blog.jetoile.fr/blog/categories/maven/atom.xml" rel="self"/>
  <link href="http://blog.jetoile.fr/"/>
  <updated>2016-04-18T18:29:47+02:00</updated>
  <id>http://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Undertow pour booster vos services REST]]></title>
    <link href="http://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest.html"/>
    <updated>2015-06-23T14:51:56+02:00</updated>
    <id>http://blog.jetoile.fr/2015/06/undertow-pour-booster-vos-services-rest</id>
    <content type="html"><![CDATA[<p><img src="/images/undertow.png" alt="left-small" />
Il y a quelques temps, j'avais fait une série d'articles sur <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>.</p>

<p>Cette article repart du même besoin, à savoir disposer d'une <em>stack</em> légère pour réaliser un service REST, mais en utilisant <a href="http://undertow.io/">Undertow</a> plutôt que Resteasy-Netty.</p>

<!-- more -->


<p>Au niveau des besoins, ils seront identiques ie. :</p>

<ul>
<li>utiliser JAX-RS,</li>
<li>intégrer Swagger,</li>
<li>intégrer Jolokia,</li>
<li>générer un livrable autoporteur.</li>
</ul>


<p>RestEasy-Netty, même s'il existe de nombreux points d'entrée, demande quelques phases de <em>hack</em> (gestion du <em>crossover domain</em> par exemple) et dispose d'un mécanisme un peu limité concernant la partie sécurité.</p>

<p>En outre, l'absence du mécanisme de Servlet reste un peu embêtant pour mettre en place certaines <em>features</em> comme le MDC ( <a href="http://logback.qos.ch/manual/mdc.html"><em>Mapped Diagnostic Context</em></a> ) bien pratique lorsque l'on est dans une architecture type microservice.</p>

<p>Le code complet est disponible <a href="https://github.com/jetoile/undertow-sample">ici</a>.</p>

<h1>Rappel du cahier des charges</h1>

<p>Comme je l'ai déjà indiqué dans les autres posts, l'objectif est seulement de montrer comme il peut être simple d'exposer un service REST à l'aide d'<a href="http://undertow.io/">Undertow</a>. Pour ce faire, un simple service sera exposé et il consistera à répèter ce qu’on lui demande…</p>

<p>Il répondra donc à une requête de type GET du type : <a href="http://localhost:8081/sample/say/">http://localhost:8081/sample/say/</a><message></p>

<p>Du coté de la réponse, elle aura la forme suivante :
```javascript
{</p>

<pre><code>"message": &lt;message&gt;,
"time":"2015-06-23T15:18:50.748"
</code></pre>

<p>}
```</p>

<h1>Mise en oeuvre</h1>

<p>A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :
```text</p>

<pre><code>compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.11.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.3.1'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.12'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'javax.servlet-api', version:'3.1.0'
compile group: 'io.dropwizard.metrics', name: 'metrics-core', version:'3.1.2'
compile group: 'io.undertow', name: 'undertow-core', version:'1.2.8.Final'
compile group: 'io.undertow', name: 'undertow-servlet', version:'1.2.8.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-undertow', version:'3.0.11.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson2-provider', version:'3.0.11.Final'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version:'2.5.4'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version:'2.5.4'
compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version:'2.5.4'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.10'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'org.slf4j', name: 'slf4j-api', version:'1.7.12'
compile group: 'ch.qos.logback', name: 'logback-classic', version:'1.1.3'
</code></pre>

<p>```</p>

<p>Concernant la version des différentes dépendances, on constate que ce n'est pas swagger2 qui est utilisé en raison d'une incapacité de ma part à l'intégrer&hellip; :&lsquo;(</p>

<h1>Implémentation du service REST</h1>

<p>Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial… et la classe ci-dessous fait humblement l’affaire :
```java
@Api(value = &ldquo;/sample&rdquo;,</p>

<pre><code>    description = "the sample api")
</code></pre>

<p>@Path(&ldquo;/sample&rdquo;)
@RolesAllowed(&ldquo;admin&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);


@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
@ApiOperation(value = "repeat the word",
        notes = "response the word",
        response = DtoResponse.class)
@ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})
public Response sayHello(@PathParam("msg") String message) {

    log.info("sample log");

    final Timer timer = Main.metricRegistry.timer(name(SimpleService.class, "say-service"));
    final Timer.Context context = timer.time();
    try {

        DtoResponse response = new DtoResponse();
        try {
            response.setMessage(message);
            response.setTime(LocalDateTime.now());
        } catch (Exception e) {
            log.error("internal error: {}", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(response).build();
    } finally {
        if (context != null) context.stop();
    }
}
</code></pre>

<p>}
<code>
Coté du DTO, il est le suivant :
</code>java
@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
private LocalDateTime time;

public DtoResponse() {
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

public LocalDateTime getTime() {
    return time;
}

public void setTime(LocalDateTime time) {
    this.time = time;
}
</code></pre>

<p>}
```</p>

<p>On remarquera l'utilisation de Java8 pour la gestion du temps plutôt que Joda-Time.</p>

<p>En outre, concernant les annotations Swagger et l'utilisation de metrics, nous y reviendrons plus tard.</p>

<p>Concernant le message de log, de même, nous y reviendrons plus tard avec l'intégration d'un MDC pour les logs.</p>

<h1>Mise en oeuvre avec Undertow</h1>

<p>Mettre en place Resteasy avec Undertow est très simple, d’après la documnentation, il suffit de faire :
```java
SimpleService simpleService = new SimpleService();
ResteasyDeployment deployment = new ResteasyDeployment();</p>

<p>deployment.setResources(Arrays.<Object>asList(simpleService));</p>

<p>int port = config.getInt(&ldquo;undertow.port&rdquo;, TestPortProvider.getPort());
String host = config.getString(&ldquo;undertow.host&rdquo;, String.valueOf(TestPortProvider.getHost()));
System.setProperty(&ldquo;org.jboss.resteasy.port&rdquo;, String.valueOf(TestPortProvider.getPort());
System.setProperty(&ldquo;org.jboss.resteasy.host&rdquo;, String.valueOf(TestPortProvider.getHost());</p>

<p>UndertowJaxrsServer server = new UndertowJaxrsServer();</p>

<p>DeploymentInfo deploymentInfo = server.undertowDeployment(deployment);
deploymentInfo.setDeploymentName(&ldquo;&rdquo;);
deploymentInfo.setContextPath(&ldquo;/&rdquo;);
deploymentInfo.setClassLoader(Main.class.getClassLoader());</p>

<p>deployment.setProviderFactory(new ResteasyProviderFactory());
server.deploy(deploymentInfo);
server.start(Undertow.builder().addHttpListener(port, host));
```</p>

<p>On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <code>setResources()</code> sur l’instance de <em>ResteasyDeployment</em> fournit au serveur <em>UndertowJaxrsServer</em> :</p>

<p>Et voilà! On dispose désormais d’un programme exécutable qui démarre un serveur REST basé sur Undertow.</p>

<p>Par contre, il semble que le service ne rende pas vraiment ce que l'on voulait :
<code>bash
curl 'http://localhost:8081/sample/say/&lt;message&gt;'
</code></p>

<p>```json
{</p>

<pre><code>"message": "&lt;message&gt;",
"time": {
    "hour": 15,
    "minute": 55,
    "second": 51,
    "nano": 225000000,
    "year": 2015,
    "month": "JUNE",
    "dayOfMonth": 23,
    "dayOfWeek": "TUESDAY",
    "dayOfYear": 174,
    "monthValue": 6,
    "chronology": {
        "calendarType": "iso8601",
        "id": "ISO"
    }
}
</code></pre>

<p>}
```</p>

<p>Pas de souci, il suffit de préciser comment on souhaite que LocalDateTime soit sérialisé par Jackson :</p>

<p>Ainsi, notre DTO devient :
```java</p>

<p>@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
@JsonSerialize(using = LocalDateTimeToStringSerializer.class)
private LocalDateTime time;

public DtoResponse() {
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

public LocalDateTime getTime() {
    return time;
}

public void setTime(LocalDateTime time) {
    this.time = time;
}
</code></pre>

<p>}
```</p>

<p>où :</p>

<p>```java
public class LocalDateTimeToStringSerializer extends JsonSerializer<LocalDateTime> {</p>

<pre><code>@Override
public void serialize(LocalDateTime value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
    jgen.writeObject(value.format(DateTimeFormatter.ISO_DATE_TIME));
}
</code></pre>

<p>}
```</p>

<p>Après ces modifications, on obtient bien :</p>

<p><code>json
{"message":"&lt;message&gt;","time":"2015-06-23T16:04:01.419"}
</code></p>

<h1>Intégration de Metrics</h1>

<p>Concernant l'intégration de Metrics, pas grand chose de nouveau et donc pas grand chose à dire ;&ndash;)</p>

<p>Déclarer le registry :
<code>java
metricRegistry = new MetricRegistry();
final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();
reporter.start();
</code></p>

<p>Et utiliser le dans vos classes :
```java
final Timer timer = Main.metricRegistry.timer(name(SimpleService.class, &ldquo;say-service&rdquo;));
final Timer.Context context = timer.time();
try {</p>

<pre><code>...
</code></pre>

<p>} finally {</p>

<pre><code>if (context != null) context.stop();
</code></pre>

<p>}
```</p>

<h1>Intégration de la sécurité</h1>

<p>Undertow permet une bien meilleur intégration de la sécurité que RestEasy-Netty. En effet, grâce au mécanisme de Servlet, il est possible de bénéficier de toute la puissance des conteneurs de Servlets.</p>

<p>Du coté du serveur Undertow, il suffit donc de définir un <em>ServletIdentityManager</em> et de lui fournir un <em>LoginConfig</em> :
```java
deployment.setSecurityEnabled(true);</p>

<p>ServletIdentityManager identityManager = new ServletIdentityManager();
identityManager.addUser(&ldquo;khanh&rdquo;, &ldquo;khanh&rdquo;, &ldquo;admin&rdquo;);</p>

<p>deploymentInfo = deploymentInfo.setIdentityManager(identityManager).setLoginConfig(new LoginConfig(&ldquo;BASIC&rdquo;, &ldquo;Test Realm&rdquo;));
```</p>

<p>où :
```java
public class ServletIdentityManager implements IdentityManager {</p>

<pre><code>private static final Charset UTF_8 = Charset.forName("UTF-8");
private final Map&lt;String, UserAccount&gt; users = new HashMap&lt;&gt;();

public void addUser(final String name, final String password, final String... roles) {
    UserAccount user = new UserAccount();
    user.name = name;
    user.password = password.toCharArray();
    user.roles = new HashSet&lt;&gt;(Arrays.asList(roles));
    users.put(name, user);
}

@Override
public Account verify(Account account) {
    // Just re-use the existing account.
    return account;
}

@Override
public Account verify(String id, Credential credential) {
    Account account = users.get(id);
    if (account != null &amp;&amp; verifyCredential(account, credential)) {
        return account;
    }

    return null;
}

@Override
public Account verify(Credential credential) {
    return null;
}

private boolean verifyCredential(Account account, Credential credential) {
    // This approach should never be copied in a realm IdentityManager.
    if (account instanceof UserAccount) {
        if (credential instanceof PasswordCredential) {
            char[] expectedPassword = ((UserAccount) account).password;
            char[] suppliedPassword = ((PasswordCredential) credential).getPassword();

            return Arrays.equals(expectedPassword, suppliedPassword);
        } else if (credential instanceof DigestCredential) {
            DigestCredential digCred = (DigestCredential) credential;
            MessageDigest digest = null;
            try {
                digest = digCred.getAlgorithm().getMessageDigest();

                digest.update(account.getPrincipal().getName().getBytes(UTF_8));
                digest.update((byte) ':');
                digest.update(digCred.getRealm().getBytes(UTF_8));
                digest.update((byte) ':');
                char[] expectedPassword = ((UserAccount) account).password;
                digest.update(new String(expectedPassword).getBytes(UTF_8));

                return digCred.verifyHA1(HexConverter.convertToHexBytes(digest.digest()));
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException("Unsupported Algorithm", e);
            } finally {
                digest.reset();
            }
        }
    }
    return false;
}

private static class UserAccount implements Account {
    // In no way whatsoever should a class like this be considered a good idea for a real IdentityManager implementation,
    // this is for testing only.

    String name;
    char[] password;
    Set&lt;String&gt; roles;

    private final Principal principal = new Principal() {
        @Override
        public String getName() {
            return name;
        }
    };

    @Override
    public Principal getPrincipal() {
        return principal;
    }

    @Override
    public Set&lt;String&gt; getRoles() {
        return roles;
    }
}
</code></pre>

<p>}
```</p>

<p>Il s'agit ici d'une Basic Authentification mais il est bien sûr possible d'en mettre en place d'autre.</p>

<p>Coté autorisation, il est alors possible de bénéficier de l'annotation <code>@RolesAllowed</code> de JAX-RS :
<code>java
@Path("/sample")
@RolesAllowed("admin")
public class SimpleService {
...
}
</code></p>

<h1>Intégration d'un MDC</h1>

<p>Concernant la mise en place d'un MDC (<em>Mapped Diagnostic Context</em>), le fait de bénéficier du mécanisme de <em>Filter</em> des Servlets rend la chose beaucoup plus simple.</p>

<p>En effet, une fois la couche sécurité branchée, il suffit de récupérer le <code>UserPrincipal</code> dans la requête et l'enregistrer dans le MDC.</p>

<p>La déclaration des Filters se fait de la manière suivante pour Undertow :
```java
FilterInfo mdcFilter = new FilterInfo(&ldquo;MDCFilter&rdquo;, MDCServletFilter.class);
deploymentInfo.addFilter(mdcFilter);
deploymentInfo.addFilterUrlMapping(&ldquo;MDCFilter&rdquo;, &ldquo;*&rdquo;, DispatcherType.REQUEST);</p>

<p>FilterInfo mdcInsertingFilter = new FilterInfo(&ldquo;MDCInsertingServletFilter&rdquo;, MDCInsertingServletFilter.class);
deploymentInfo.addFilter(mdcInsertingFilter);
deploymentInfo.addFilterUrlMapping(&ldquo;MDCInsertingServletFilter&rdquo;, &ldquo;*&rdquo;, DispatcherType.REQUEST);
```</p>

<p>Avec le filter ci-dessous :
```java
public class MDCServletFilter implements Filter {</p>

<pre><code>private final String USER_KEY = "username";

public void destroy() {
}

public void doFilter(ServletRequest request, ServletResponse response,
                     FilterChain chain) throws IOException, ServletException {

    boolean successfulRegistration = false;

    HttpServletRequest req = (HttpServletRequest) request;
    Principal principal = req.getUserPrincipal();
    // Please note that we could have also used a cookie to
    // retrieve the user name

    if (principal != null) {
        String username = principal.getName();
        successfulRegistration = registerUsername(username);
    }

    try {
        chain.doFilter(request, response);
    } finally {
        if (successfulRegistration) {
            MDC.remove(USER_KEY);
        }
    }
}

public void init(FilterConfig arg0) throws ServletException {
}


/**
 * Register the user in the MDC under USER_KEY.
 *
 * @param username
 * @return true id the user can be successfully registered
 */
private boolean registerUsername(String username) {
    if (username != null &amp;&amp; username.trim().length() &gt; 0) {
        MDC.put(USER_KEY, username);
        return true;
    }
    return false;
}
</code></pre>

<p>}
<code>
Ainsi, disposer d'un MDC permet d'ajouter automatiquement des informations dans les logs :
</code>xml
<configuration></p>

<pre><code>&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;%d{HH:mm:ss.SSS} %-5level %logger{36} %X{req.remoteHost} %X{req.requestURI} - C:%X{username} - %msg%n

        &lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;


&lt;root level="info"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
&lt;/root&gt;
</code></pre>

<p></configuration>
```</p>

<p>On obtient alors bien les logs voulues :
<code>text
17:15:11.466 INFO  f.j.sample.service.SimpleService 127.0.0.1 /sample/say/&lt;message&gt; - C:khanh - sample log
</code></p>

<h1>Intégration de Jolokia</h1>

<p>Coté Jolokia, pas grand chose à ajouter par rapport à ma série d'article précédent&hellip;
```java
try {</p>

<pre><code>        JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());

        JolokiaServer jolokiaServer = new JolokiaServer(config, true);
        jolokiaServer.start();
</code></pre>

<p>} catch (Exception e) {</p>

<pre><code>        LOGGER.error("unable to start jolokia server", e);
</code></pre>

<p>}
```</p>

<h1>Intégration de Swagger</h1>

<p>Concernant l'intégration de Swagger, le fait de disposer des <em>Filter</em> de Servlet permet de n'avoir pas à faire de <em>hack</em> immonde pour gérer le CORS (cf. <a href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">article précédent</a>) : il suffit de déclarer un <em>Filter</em> dans Undertow qui a, en outre, la chance d'exister :
```java
CorsFilter filter = new CorsFilter();
filter.setAllowedMethods(&ldquo;GET,POST,PUT,DELETE,OPTIONS&rdquo;);
filter.setAllowedHeaders(&ldquo;X-Requested-With, Content-Type, Content-Length, Authorization&rdquo;);
filter.getAllowedOrigins().add(&ldquo;*&rdquo;);</p>

<p>deployment.setProviderFactory(new ResteasyProviderFactory());
deployment.getProviderFactory().register(filter);
```</p>

<p>Concernant la déclaration dans Undertow, pas grand chose à ajouter :
```java</p>

<pre><code>private static void initSwagger(ResteasyDeployment deployment) {
    BeanConfig swaggerConfig = new BeanConfig();
    swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));
    swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));
    swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));
    swaggerConfig.setScan(true);
    swaggerConfig.setResourcePackage("fr.jetoile.sample.service");

    deployment.setProviderClasses(Lists.newArrayList(
            "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",
            "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));
    deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));
    deployment.setSecurityEnabled(false);
}
</code></pre>

<p>```</p>

<h1>Branchement des plugins Maven Appassembler et Assembly</h1>

<p>Coté génération du livrable, encore une fois, pas grand chose à ajouter par rapport à mon précédent article : l'utilisation des plugins assembly et appassembler est identique.</p>

<h1>Conclusion</h1>

<p>On avait vu dans les articles précédents que RestEasy-Netty était une solution intéressante pour la simplicité de sa mise en oeuvre ainsi que pour le faible overhead.</p>

<p>Cependant, certaines intégrations ressemblaient plus à du <em>hack</em> qu'à une solution configurable.</p>

<p>Undertow (enfin pour être plus précis RestEasy-Undertow) pour sa part offre la même simplicité que RestEasy-Netty mais il permet en plus de s'intégrer avec beaucoup d'autres choses et le fait de retrouver le mécanisme de <em>Filter</em> facilite énormément les choses (par exemple, je ne suis pas sûr que bénéficier du MDC avec RestEasy-Netty ait été aussi simple).</p>

<p>Coté performance, je reviendrai dessus dans un autre article mais je peux déjà dire que la solution RestEasy-Undertow n'a rien à envier à RestEasy-Netty.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty et bien plus encore... mode d'emploi...]]></title>
    <link href="http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html"/>
    <updated>2014-03-10T08:03:49+01:00</updated>
    <id>http://blog.jetoile.fr/2014/03/jaxrs-netty-et-bien-plus-encore-mode</id>
    <content type="html"><![CDATA[<p><img src="http://1.bp.blogspot.com/-HYBTn5anFdE/Uxdv3cRgu_I/AAAAAAAABP4/gsCZjUIxDyQ/s1600/resteasy_jolokia_metrics.png" alt="left-small" /></p>

<p>L'informatique évolue constamment et c'est également le cas des architectures qui ont tendance à s'orienter de plus en plus vers l'utilisation de services REST. Ces services REST doivent, en outre, être de plus en plus véloces afin de pouvoir répondre à une charge de plus en plus forte (que ce soit d'un point de vue temps de réponse mais également d'un point de vue charge suportée). C'est dans ce contexte que des solutions comme <a href="http://restlet.org/">Restlet</a> ou <a href="http://restx.io/">RestX</a> (pour n'en citer que quelques-unes) ont vu le jour.</p>

<p>En effet, en plus d'offrir la possibilité de servir des services REST, elles s'appuient sur des framework dont la particularité est d'offrir des traitements non bloquant sur les entrées/sorties (NIO).</p>

<p>C'est dans ce contexte que cet article parlera principalement de Resteasy-Netty 3 (la version 3 a été utilisé en raison de contraintes techniques (connexion à <a href="http://cassandra.apache.org/">Apache Cassandra</a> dont le <a href="https://github.com/datastax/java-driver">driver</a> utilise Netty 3)).</p>

<p>Cependant, ce ne sera pas le seul protagoniste car, comme on verra par la suite, il est très simple à utiliser&hellip;</p>

<p>Le vrai sujet de cet article est, en fait, comment il a été possible d'ajouter d'autres framework comme Swagger ou Jolokia à Resteasy-Netty 3.</p>

<p>Cet article sera découpé en deux parties :</p>

<ul>
<li>Besoin et conception</li>
<li>Mise en oeuvre</li>
</ul>


<p>Le code se trouve sur Github <a href="https://github.com/jetoile/resteasy-netty-sample">ici</a>.</p>

<!-- more -->


<h1>Besoin et conception</h1>

<p>Le besoin était d'offrir un ensemble de services REST qui devait être suffisamment véloce pour répondre au besoin de performance en terme de charge mais également en terme de temps de réponse.</p>

<p>Venant du monde Java et plus précisément de Java EE, il aurait été pertinent de partir sur une solution classique à base de <a href="https://jcp.org/en/jsr/detail?id=311">JAX-RS</a> (<a href="https://jersey.java.net/">Jersey</a> ou <a href="http://www.jboss.org/resteasy">RestEasy</a>) hébergée par un <a href="http://tomcat.apache.org/">Tomcat</a> ou un <a href="http://www.eclipse.org/jetty/">Jetty</a>.</p>

<p>Cependant, une crainte était que le mode de fonctionnement des Servlets soit limitant concernant les entrées/sorties. Bien sûr, il était possible d'utiliser le connecteur NIO de Tomcat mais ce n'est pas cette solution qui a été retenue&hellip; ;&ndash;)</p>

<p>Suite à la lecture de l'excellent <a href="http://blog.xebia.fr/2011/11/09/java-nio-et-framework-web-haute-performance/">article</a> sur le retour d'expérience de <a href="https://twitter.com/slemesle">Séven</a> et de <a href="https://twitter.com/julienBuret">Julien</a> lors du challenge USI 2011, le choix a été fait de partir sur une solution basée sur <a href="http://netty.io/">Netty</a>.</p>

<p>Par contre, développer des services directement sur Netty était embêtant et risquait surtout de rebuter l'équipe de développement. De la même manière, introduire un nouveau framework disposant de ses propres API n'était pas préconisé (NDLR : les standards c'est bien ! ;&ndash;) ).</p>

<p>C'est pour cette raison qu'il était préférable de trouver une solution alliant à la fois les avantages de NIO (et si possible s'appuyant sur Netty) et de JAX-RS.</p>

<p>Ainsi, il a été décidé de partir sur Resteasy-Netty 3 qui semblait offrir le meilleur des deux mondes (je dis &ldquo;semblais&rdquo; car aucun comparatif en charge des différents protagonistes n'a été réalisé et les résultats obtenus ont été suffisamment satisfaisant pour n'avoir pas à pousser plus loin l'expérimentation).</p>

<p>L'un des autres avantages de n'avoir pas utiliser un conteneur de Servlet classique était qu'il permettait de rendre le livrable auto-porteur et légé (il aurait bien sûr été possible d'embarquer un Tomcat ou Jetty embedded ou de &ldquo;s'embeddé&rdquo; dans un Tomcat via le goal exec-war de Tomcat7-maven-plugin).</p>

<p>Bien sûr, l'application devait être administrable et supervisable.</p>

<p>Enfin, cerise sur le gateau, intégrer une solution comme <a href="https://helloreverb.com/developers/swagger">Swagger</a> pour documenter les API REST était un <em>&ldquo;nice to have&rdquo;</em>.</p>

<p>Pour notre cas d'exemple, le seul service exposé sera le classique service qui répète ce qu'on lui demande&hellip;</p>

<p>Il répondra donc à une requête de type GET du type :
<code>http://localhost:8081/sample/say/&lt;message&gt;</code></p>

<p>Du coté de la réponse, elle aura la forme suivante :
```javascript
{</p>

<pre><code>"message": &lt;message&gt;,
"time": "2014-03-05T10:55:39.835+01:00"
</code></pre>

<p>}
```</p>

<p>La date de la réponse sera ajoutée juste pour le &ldquo;fun&rdquo; ;&ndash;)</p>

<h1>Mise en oeuvre</h1>

<p>A titre informatif, les versions des différentes librairies qui sont utilisés dans les exemples de code ci-dessous sont les suivantes (au format gradle pour gagner de la place) :
<code>text
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-jvm', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.codahale.metrics', name: 'metrics-core', version:'3.0.1'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'
compile group: 'org.codehaus.jackson', name: 'jackson-core-asl', version:'1.9.13'
compile group: 'org.codehaus.jackson', name: 'jackson-mapper-asl', version:'1.9.13'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') { exclude(module: 'jsr305') }
</code></p>

<h2>Implémentation du service REST</h2>

<p>Le mise en place du service REST basé sur JAX-RS est on ne peut plus trivial&hellip; et la classe ci-dessous fait humblement l'affaire :</p>

<p>```java
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);

@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortDataSet(@PathParam("msg") String message) {
    DtoResponse response = new DtoResponse();
    try {
        response.setMessage(message);
        response.setTime(DateTime.now());
    } catch (Exception e) {
        log.error("internal error: {}", e);
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
    return Response.ok(response).build();
}
</code></pre>

<p>}
```</p>

<p>Du coté de l'objet retourné par la réponse au format JSON, Jackson intégré à Resteasy a été utilisé pour la partie marshalling/unmarshalling.</p>

<p>Coté gestion des dates, ce sera JodaTime (l'application tourne avec Java 7).</p>

<p>Du coup, un objet DTO a été écrit et annoté à l'aide d'annotations JAXB :</p>

<p>```java
@XmlRootElement
public class DtoResponse {</p>

<pre><code>private String message;
private DateTime time;

public DtoResponse() {}

public String getMessage() { return message;}

public void setMessage(String message) { this.message = message; }

public DateTime getTime() { return time; }

public void setTime(DateTime time) { this.time = time; }
</code></pre>

<p>}
```</p>

<h2>Mise en oeuvre de Resteasy-Netty 3</h2>

<p>Mettre en place Resteasy-Netty 3 est très simple, d'après la <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/pdf/resteasy-reference-guide-en-US.pdf">documnentation</a>, il suffit de faire :</p>

<p><code>java
public static void start(ResteasyDeployment deployment) throws Exception {
  netty = new NettyJaxrsServer();
  netty.setDeployment(deployment);
  netty.setPort(TestPortProvider.getPort());
  netty.setRootResourcePath("");
  netty.setSecurityDomain(null);
  netty.start();
 }
</code></p>

<p>et c'est donc ce que l'on va faire&hellip; ;&ndash;)</p>

<p><a href="http://commons.apache.org/proper/commons-configuration/">Apache commons-configuration</a> a été utilisé afin de déporter la configuration dans un fichier <em>properties</em>.</p>

<p>```java
public class Client {</p>

<pre><code>private final static Logger LOGGER = LoggerFactory.getLogger(Client.class);
private static final String CONF_PROPERTIES = "conf.properties";
private static Configuration config;

public static void main(String[] args) throws ConfigurationException, BootstrapException {
    try {
        config = new PropertiesConfiguration(CONF_PROPERTIES);
    } catch (ConfigurationException e) {
        throw new BootstrapException("bad config", e);
    }
    initServer();
}

private static void initServer() {
    SimpleService service = new SimpleService();
    ResteasyDeployment deployment = new ResteasyDeployment();

    int nettyPort = 8081;

    if (config != null) {
        deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));
        deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));
        deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));
        deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));

        nettyPort = config.getInt("netty.port", TestPortProvider.getPort());
    } else {
        LOGGER.warn("is going to use default netty config");
    }

    deployment.setResources(Arrays.&lt;Object&gt;asList(service));

    NettyJaxrsServer netty = new NettyJaxrsServer();
    netty.setDeployment(deployment);
    netty.setPort(nettyPort);
    netty.setRootResourcePath("");
    netty.setSecurityDomain(null);
    netty.start();
}    
</code></pre>

<p>}
```</p>

<p>On y constate que pour ajouter un service, il suffit juste de déclarer la classe implémentant JAX-RS via la méthode <code>setResources()</code> sur l'instance de <code>ResteasyDeployment</code> fournit au serveur <strong>NettyJaxrs</strong> :</p>

<p><code>java
SimpleService service = new SimpleService();
ResteasyDeployment deployment = new ResteasyDeployment();
deployment.setResources(Arrays.&lt;Object&gt;asList(service));
NettyJaxrsServer netty = new NettyJaxrsServer();
netty.setDeployment(deployment);
...
netty.start();
</code></p>

<p>Et voilà! On dispose désormais d'un programme exécutable qui démarre un serveur REST basé sur Netty.</p>

<p>Plutôt simple non? ;&ndash;)</p>

<h2>Configuration de Jackson</h2>

<p>Avec le code précédent, si la commande suivante est exécutée :</p>

<p><code>bash
 curl -XGET  http://localhost:8081/sample/say/hello
</code></p>

<p>Le résultat suivant est obtenu :
```javascript
{</p>

<pre><code>"message": "hello",
"time": 1402560438128
</code></pre>

<p>}
```</p>

<p>Hum&hellip; la date n'est pas formatté comme il faut&hellip; pas glop&hellip; :&lsquo;(</p>

<p>En fait, il est possible de modifier la configuration de <a href="http://jackson.codehaus.org/">Jackson</a> et on trouve, dans la littérature, un moyen très simple de le faire en configurant l'<em>ObjectMapper</em> comme suit :
<code>java
objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);
</code></p>

<p>Bien sûr, le but n'étant pas de faire cette transformation manuellement à chaque fois, on préfère laisser Resteasy le gérer lui-même.</p>

<p>Ainsi, il existe <a href="http://stackoverflow.com/questions/19229341/changing-default-json-time-format-with-resteasy-3-x">deux autres</a> manières de faire :</p>

<ul>
<li>Le faire par annotation</li>
<li>Le faire par configuration dans le <code>web.xml</code></li>
</ul>


<p>Cependant, dans notre cas, nous ne disposons pas d'un conteneur de Servlet classique et il n'est donc pas possible de s'appuyer sur une configuration par web.xml. Pour le faire par annotation, j'avoue ne pas avoir testé mais je suis sceptique&hellip;</p>

<p>Du coup, il reste une possibilité qui est de déclarer un <code>JacksonConfig</code> et de demander à Resteasy-Netty de nous l'enregistrer en tant que <em>provider</em> (en gros de demander à Resteasy-Netty de faire manuellement ce qui est fait via le <code>web.xml</code>) :</p>

<p>```java
public class JacksonConfig implements ContextResolver<ObjectMapper> {</p>

<pre><code>private final ObjectMapper objectMapper;

public JacksonConfig() {
    objectMapper = new ObjectMapper();
    objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);
    objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);
}

@Override
public ObjectMapper getContext(Class&lt;?&gt; objectType) {
    return objectMapper;
}
</code></pre>

<p>}
```</p>

<p>Pour l'enregistrement, c'est très simple puisqu'il suffit d'ajouter la ligne suivante :
<code>deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig"));</code></p>

<p>Et voilà! C'est tout!</p>

<p>Encore une fois, simple et efficace et le résultat obtenu est bien celui escompté :
```javascript
{</p>

<pre><code>"message": "hello",
"time": "2014-06-12T10:06:54.553+02:00"
</code></pre>

<p>}
```</p>

<p>A noter que l'<em>ancienne</em> version de Jackson est utilisée ici car c'est celle qui est utilisé par défaut par Resteasy. Il aurait été possible de l'utiliser dans sa version plus récente mais j'avoue ne pas avoir fait l'exercice&hellip; (cf. <a href="https://docs.jboss.org/resteasy/docs/3.0.6.Final/userguide/html/json.html#d4e1046">ici</a>)</p>

<h2>Intégration de Metrics</h2>

<p>Afin de permettre une mesure des temps d'invocation de différentes opérations, la librairie <a href="http://metrics.codahale.com/">Metrics</a> a été utilisée.</p>

<p>Pour plus d'information dessus, le sujet est très bien traité sur le blog de <a href="https://twitter.com/clescot">Charles</a> :</p>

<ul>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-les-bases/">Metrics : Les Bases</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-jee/">Metrics : Intégration Avec JEE</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-spring-et-guice/">Metrics : Intégration Avec Spring Et Guice</a></li>
<li><a href="http://clescot.com/blog/2013/10/11/metrics-pour-mesurer-efficacement-les-performances-integration-avec-JDBC-logback-et-jersey/">Metrics : Intégration Avec JDBC, Logback Et Jersey</a></li>
</ul>


<p>Dans notre cas, bien sûr, pas de <em>Spring</em>, de <em>Guice</em> ou de <em>Servlet Listener</em>. Une simple variable de classe dans la classe portant la méthode <code>main()</code> suffit :
```java
public static MetricRegistry metricRegistry;</p>

<p>public static void main(String[] args) throws ConfigurationException, BootstrapException {
   &hellip;</p>

<pre><code>metricRegistry = new MetricRegistry();
final JmxReporter reporter = JmxReporter.forRegistry(metricRegistry).build();
reporter.start();
</code></pre>

<p>}
```</p>

<p>Concernant l'utilisation à proprement parler, cela se fait de cette manière (dans notre cas, utilisation du <strong>Timer</strong> qui représente un histogramme des durées et une mesure de la fréquence d’apparition) :
```java
@GET
@Path(&ldquo;/say/{msg}&rdquo;)
@Produces(MediaType.APPLICATION_JSON)
public Response getPortDataSet(@PathParam(&ldquo;msg&rdquo;) String message) {</p>

<pre><code>final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));
final Timer.Context context = timer.time();
try {
</code></pre>

<p>  &hellip;</p>

<pre><code>    return Response.ok(response).build();
} finally {
    if (context != null) context.stop();
}
</code></pre>

<p>}
```</p>

<p>Une fois l'application démarrée et après 1 ou 2 appels, l'ObjectName apparait dans la console JMX et il est alors possible de voir les différents résultats.</p>

<p><img src="http://1.bp.blogspot.com/-RMh6acQ8Qkc/UxdsRqymVkI/AAAAAAAABPk/r3rvWdgPNtg/s1600/metrics-hawtio.png" alt="medium" /></p>

<p>On constate encore une fois que la mise en place de Metrics n'a demandé aucun effort particulier.</p>

<h2>Intégration de Jolokia</h2>

<p>Une autre étape de notre périple consiste à activer Jolokia que j'ai déjà présenté dans un <a href="/2014/03/jolokia-le-piment-qui-vous-veut-du-bien.html">article précédent</a>.</p>

<p>Dans notre cas d'usage, cela sera fait de manière programmatique.</p>

<p>Pour ce faire, c'est encore une fois très simple et il suffit d'ajouter le code suivant dans notre classe principale :
```java
private static void initJolokiaServer() {</p>

<pre><code>try {
    JolokiaServerConfig config = new JolokiaServerConfig(new HashMap&lt;String, String&gt;());

    JolokiaServer jolokiaServer = new JolokiaServer(config, true);
    jolokiaServer.start();
} catch (Exception e) {
    LOGGER.error("unable to start jolokia server", e);
}
</code></pre>

<p>}
```</p>

<p>Concernant sa configuration, pour éviter d'avoir à aller chercher des properties et à repeupler une Map, le fichier par défaut (<code>default-jolokia-agent.properties</code>) a été copié (en renseignant certaines informations comme le user/password) dans le répertoire <code>src/main/resources</code> :
```text</p>

<h1>Configuration properties for the JVM jolokia-agent</h1>

<h1>Host address to bind to.</h1>

<h1>Default: localhost, determinated dynamically via InetAddress.getLocalHost()</h1>

<p>host=0.0.0.0</p>

<h1>Port to listen to</h1>

<p>port=7778</p>

<h1>Context path</h1>

<p>agentContext=/jolokia</p>

<h1>Backlog of request to keep when queue</h1>

<p>backlog=10</p>

<h1>Possible values:</h1>

<h1>* &ldquo;fixed&rdquo;  : Thread pool with at max nrThreads</h1>

<h1>* &ldquo;single&rdquo; : A single thread serves all requests (default)</h1>

<h1>* &ldquo;cached&rdquo; : A thread pool which reuses threads and creates threads on demand (unbounded)</h1>

<h1>executor=fixed</h1>

<h1>nrThreads=5</h1>

<h1>User and password for basic authentication</h1>

<p>user=jolokia
password=jolokia</p>

<h1>How many entroes to keep in the history</h1>

<p>historyMaxEntries=10</p>

<h1>Switch on debugging</h1>

<p>debug=false</p>

<h1>How many debug entries to keep on the server side which can be queried by JMX</h1>

<p>debugMaxEntries=100</p>

<h1>Maximum traversal depth for serialization of complex objects.</h1>

<p>maxDepth=15</p>

<h1>Maximum size of collections returned during serialization.</h1>

<p>maxCollectionSize=1000</p>

<h1>Maximum number of objects returned by serialization</h1>

<p>maxObjects=0
```</p>

<p>Un petit coup de (le user jolokia et le mot de passe jolokia ont été positionné dans le fichier <em>properties</em>) :
<code>bash
curl -XGET -u jolokia:jolokia http://localhost:7778/jolokia/version
</code></p>

<p>nous permet bien d'obtenir la réponse attendue :
```javascript
{</p>

<pre><code>"timestamp": 1394036344,
"status": 200,
"request": {
    "type": "version"
},
"value": {
    "protocol": "7.0",
    "agent": "1.1.2",
    "info": {}
}
</code></pre>

<p>}
```</p>

<p>A noter que les user/password ont été positionné car cela permet une connexion via <a href="http://hawt.io/">Hawt.io</a>.</p>

<h2>Intégration de Swagger</h2>

<p><a href="https://helloreverb.com/developers/swagger">Swagger</a> offre une manière très simple de documenter une API REST. En effet, en s'appuyant sur des annotations à mettre dans la classe de service, elle permet d'offrir une interface d'écrivant les API.</p>

<p><img src="http://4.bp.blogspot.com/-92lPQm1F_DM/UxdsgUK3bDI/AAAAAAAABPs/yWh6QRHKkFc/s1600/swagger.png" alt="medium" /></p>

<p>Pour le mettre en place, il suffit donc de rajouter les annotations adéquates à notre classe <code>SimpleService</code> :</p>

<p>```java
@Api(value = &ldquo;/sample&rdquo;, description = &ldquo;the sample api&rdquo;)
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private final static Logger log = LoggerFactory.getLogger(SimpleService.class);

@GET
@Path("/say/{msg}")
@Produces(MediaType.APPLICATION_JSON)
@ApiOperation(value = "repeat the word",
        notes = "response the word",
        response = DtoResponse.class)
@ApiResponses(value = {@ApiResponse(code = 500, message = "Internal server error")})
public Response getPortDataSet(@PathParam("msg") String message) {

    final Timer timer = Client.metricRegistry.timer(name(SimpleService.class, "say-service"));
    final Timer.Context context = timer.time();
    try {
        DtoResponse response = new DtoResponse();
        try {
            response.setMessage(message);
            response.setTime(DateTime.now());
        } catch (Exception e) {
            log.error("internal error: {}", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(response).build();
    } finally {
        if (context != null) context.stop();
    }
}
</code></pre>

<p>}
```</p>

<p>Reste maintenant à ajouter Swagger à notre <code>main()</code> que l'on doit faire programmatiquement faute d'être dans un conteneur de Servlet standard&hellip;</p>

<p>Pour ce faire, il est nécessaire d'instancier un objet <code>BeanConfig</code> qui contient la configuration de Swagger mais surtout l'adresse et le port du serveur sur lequel tourne le service ainsi que le package où se trouve ce dernier. Ces informations sont renseignées, dans notre cas, dans notre fichier de configuration et positionnées programmatiquement dans notre <code>BeanConfig</code>.</p>

<p>Enfin, il faut trouver le moyen de faire le pendant de ce qui est déclaré sur <a href="https://github.com/wordnik/swagger-core/wiki/Servlet-Quickstart">cette page</a>&hellip; bien sûr, le tout sans Servlet&hellip; ouch&hellip; :&lsquo;( En fouillant un peu, on tombe rapidement sur le <a href="https://github.com/wordnik/swagger-core/wiki/Java-CXF-Quickstart">quickstart swagger/cxf</a> où les <em>providers</em> sont positionnés : il suffit de faire pareil avec Resteasy-Netty ;&ndash;)</p>

<p>```java
private static void initSwagger(ResteasyDeployment deployment) {</p>

<pre><code>BeanConfig swaggerConfig = new BeanConfig();
swaggerConfig.setVersion(config.getString("swagger.version", "1.0.0"));
swaggerConfig.setBasePath("http://" + config.getString("swagger.host", "localhost") + ":" + config.getString("swagger.port", "8081"));
swaggerConfig.setTitle(config.getString("swagger.title", "jetoile sample app"));
swaggerConfig.setScan(true);
swaggerConfig.setResourcePackage("fr.jetoile.sample.service");

deployment.setProviderClasses(Lists.newArrayList("fr.jetoile.sample.JacksonConfig",
        "com.wordnik.swagger.jaxrs.listing.ResourceListingProvider",
        "com.wordnik.swagger.jaxrs.listing.ApiDeclarationProvider"));
deployment.setResourceClasses(Lists.newArrayList("com.wordnik.swagger.jaxrs.listing.ApiListingResourceJSON"));
deployment.setSecurityEnabled(false);
</code></pre>

<p>}
```</p>

<p>Et voilà, ça fonctionne!</p>

<p>En exécutant la commande :
<code>bash
curl -XGET http://localhost:8081/api-docs/sample
</code></p>

<p>On obtient bien le JSON escompté :
```javascript
{</p>

<pre><code>"apiVersion": "1.0.0",
"swaggerVersion": "1.2",
"basePath": "http://localhost:8081",
"resourcePath": "/sample",
"apis": [
    {
        "path": "/sample/say/{msg}",
        "operations": [
            {
                "method": "GET",
                "summary": "repeat the word",
                "notes": "response the word",
                "type": "DtoResponse",
                "nickname": "getPortDataSet",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "msg",
                        "required": true,
                        "allowMultiple": false,
                        "type": "string",
                        "paramType": "path"
                    }
                ],
                "responseMessages": [
                    {
                        "code": 500,
                        "message": "Internal server error"
                    }
                ]
            }
        ]
    }
],
"models": {
    "DtoResponse": {
        "id": "DtoResponse",
        "properties": {
            "message": {
                "type": "string"
            },
            "time": {
                "$ref": "DateTime"
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Mais (car il y a un mais&hellip;) en utilisant <a href="https://github.com/wordnik/swagger-ui">Swagger-UI</a> (qu'il faut déployer sur un apache/nginx/tomcat ou autre), il peut arriver que cela ne fonctionne pas&hellip; )(ie. que Swagger-IU n'arrive pas à fetcher les ressources de notre service REST). Cela arrivera d'ailleurs sûrement si notre application est déployée sur une machine différente de celle où est déployée Swagger-UI (pour rappel, on ne dispose pas, ici, d'un conteneur de Servlet et exposer des pages statiques n'est pas l'objectif de notre petite application). Le problème vient de notre cher ami, le <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>&hellip; Du coup, il devient nécessaire d'ajouter des <em>headers</em> dans le requête de réponse.</p>

<p>Et c'est là que la tâche se gâte&hellip; En effet, pas de possibilité de positionner un filtre comme avec les Servlets. Pas non plus de possibilité de modifier la configuration de Resteasy-Netty 3 pour lui demander d'ajouter des headers (si cela existe, je n'ai pas trouvé)&hellip;</p>

<p>Du coup, la seule solution a été de patcher sauvagement notre ami Resteasy-Netty 3 en surchargeant une de ses classes pour y ajouter les bons headers&hellip; Pas très classe mais bon&hellip;</p>

<p>Pour ce faire, il suffit de créer dans notre application le package <code>org.jboss.resteasy.plugins.server.netty</code> et d'y copier la classe <code>RequestHandler</code> en y ajoutant les headers utiles :
```java
package org.jboss.resteasy.plugins.server.netty;</p>

<p>import org.jboss.netty.channel.*;
import org.jboss.netty.channel.ChannelHandler.Sharable;
import org.jboss.netty.handler.codec.frame.TooLongFrameException;
import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponseStatus;
import org.jboss.resteasy.logging.Logger;
import org.jboss.resteasy.spi.Failure;</p>

<p>import static org.jboss.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;</p>

<p>/<em>*
 * TODO : hack to add CORS into header
 *
 * {@link org.jboss.netty.channel.SimpleChannelUpstreamHandler} which handles the requests and dispatch them.
 *
 * This class is {@link org.jboss.netty.channel.ChannelHandler.Sharable}.
 *
 * @author The Netty Project
 * @author Andy Taylor (<a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#97;&#x6e;&#100;&#x79;&#x2e;&#x74;&#x61;&#121;&#108;&#x6f;&#114;&#64;&#x6a;&#x62;&#x6f;&#x73;&#x73;&#46;&#111;&#x72;&#103;">&#97;&#110;&#x64;&#121;&#46;&#x74;&#97;&#x79;&#x6c;&#x6f;&#114;&#x40;&#x6a;&#x62;&#111;&#115;&#x73;&#46;&#x6f;&#114;&#103;</a>)
 * @author Trustin Lee
 * @author Norman Maurer
 * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
 </em>/
@Sharable
public class RequestHandler extends SimpleChannelUpstreamHandler {</p>

<pre><code>protected final RequestDispatcher dispatcher;
private final static Logger logger = Logger.getLogger(org.jboss.resteasy.plugins.server.netty.RequestHandler.class);

public RequestHandler(RequestDispatcher dispatcher) { this.dispatcher = dispatcher; }

@Override
public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
    if (e.getMessage() instanceof NettyHttpRequest) {
        NettyHttpRequest request = (NettyHttpRequest) e.getMessage();

        //HACK ICI!!!
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Origin", "*");
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
        request.getResponse().getOutputHeaders().add("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Content-Length");
        //FIN DU HACK

        if (request.is100ContinueExpected()) { send100Continue(e); }

        NettyHttpResponse response = request.getResponse();
        try {
            dispatcher.service(request, response, true);
        } catch (Failure e1) {
            response.reset();
            response.setStatus(e1.getErrorCode());
            return;
        } catch (Exception ex) {
            response.reset();
            response.setStatus(500);
            logger.error("Unexpected", ex);
            return;
        }

        // Write the response.
        ChannelFuture future = e.getChannel().write(response);

        // Close the non-keep-alive connection after the write operation is done.
        if (!request.isKeepAlive()) { future.addListener(ChannelFutureListener.CLOSE); }
    }
}

private void send100Continue(MessageEvent e) {
    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
    e.getChannel().write(response);
}

@Override
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
    // handle the case of to big requests.
    if (e.getCause() instanceof TooLongFrameException) {
        DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE);
        e.getChannel().write(response).addListener(ChannelFutureListener.CLOSE);
    } else {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}
</code></pre>

<p>}
```</p>

<p>Voilà, après ce petit tour de passe passe, notre swagger-UI fonctionne comme un charme ;&ndash;)</p>

<p>Au final, (presque?) simple non? ;&ndash;)</p>

<h2>Branchement des plugins Maven Appassembler et Assembly</h2>

<p>Afin de générer une application utilisable <em>out of the box</em>, le plugin maven <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/">appassembler</a> a été utilisé. Pour ceux qui ne saurait pas ce que c'est, je les invite à regarder soit la documentation officielle soit un article que j'avais fait <a href="/2012/02/petit-focus-sur-2-plugins-maven.html">précédemment</a> (#autopromo ;&ndash;) ).</p>

<p>Ainsi, ici, le goal <code>generate-daemons</code> du plugin a été utilisé :
```xml
<plugin></p>

<pre><code>&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
&lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;
&lt;executions&gt;

    &lt;execution&gt;
        &lt;id&gt;spring-integ-reader&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;generate-daemons&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
            &lt;target&gt;${project.build.directory}/appassembler-jsw&lt;/target&gt;

            &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt;

            &lt;daemons&gt;
                &lt;daemon&gt;
                    &lt;id&gt;${project.name}&lt;/id&gt;
                    &lt;mainClass&gt;fr.jetoile.sample.Client&lt;/mainClass&gt;
                    &lt;commandLineArguments&gt;
                    &lt;/commandLineArguments&gt;
                    &lt;platforms&gt;
                        &lt;platform&gt;jsw&lt;/platform&gt;
                    &lt;/platforms&gt;
                    &lt;generatorConfigurations&gt;
                        &lt;generatorConfiguration&gt;
                            &lt;generator&gt;jsw&lt;/generator&gt;
                            &lt;includes&gt;
                                &lt;include&gt;linux-x86-64&lt;/include&gt;
                                &lt;include&gt;linux-x86-32&lt;/include&gt;
                            &lt;/includes&gt;
                            &lt;configuration&gt;

                                &lt;property&gt;
                                    &lt;name&gt;configuration.directory.in.classpath.first&lt;/name&gt;
                                    &lt;value&gt;conf&lt;/value&gt;
                                &lt;/property&gt;

                            &lt;/configuration&gt;
                        &lt;/generatorConfiguration&gt;
                    &lt;/generatorConfigurations&gt;
                    &lt;jvmSettings&gt;
                        &lt;initialMemorySize&gt;256M&lt;/initialMemorySize&gt;
                        &lt;maxMemorySize&gt;2048M&lt;/maxMemorySize&gt;
                        &lt;systemProperties&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.port=8199&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.authenticate=false
                            &lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.ssl=false&lt;/systemProperty&gt;
                            &lt;systemProperty&gt;com.sun.management.jmxremote.local.only=false
                            &lt;/systemProperty&gt;
                        &lt;/systemProperties&gt;
                        &lt;extraArguments&gt;
                            &lt;extraArgument&gt;-Xdebug&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;
                                -Xrunjdwp:transport=dt_socket,address=9999,server=y,suspend=n
                            &lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-server&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+UnlockCommercialFeatures&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+FlightRecorder&lt;/extraArgument&gt;
                            &lt;extraArgument&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/extraArgument&gt;
                        &lt;/extraArguments&gt;
                    &lt;/jvmSettings&gt;
                &lt;/daemon&gt;
            &lt;/daemons&gt;
        &lt;/configuration&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;

&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<p>En outre, ce plugin ne créant pas le répertoire <code>logs</code> et ne positionnant pas les droits d'exécution sur les fichiers du répertoire bin, le plugin Maven <a href="https://maven.apache.org/plugins/maven-assembly-plugin/">assembly</a> a été utilisé conjointement :
```xml
<plugin></p>

<pre><code>&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
    &lt;descriptors&gt;
        &lt;descriptor&gt;src/main/assembly/descriptor.xml&lt;/descriptor&gt;
    &lt;/descriptors&gt;
    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;

&lt;/configuration&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;assembly&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;single&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
</code></pre>

<p></plugin>
```</p>

<p>Avec le descripteur simple suivant :
```xml
&lt;?xml version=&ldquo;1.0&rdquo;?>
&lt;assembly xmlns=&ldquo;<a href="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2">http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2</a>&rdquo;</p>

<pre><code>      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"&gt;
&lt;id&gt;reader&lt;/id&gt;
&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
&lt;formats&gt;&lt;format&gt;tar.gz&lt;/format&gt;&lt;/formats&gt;

&lt;fileSets&gt;
    &lt;fileSet&gt;
        &lt;directory&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}&lt;/directory&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;excludes&gt;
            &lt;exclude&gt;bin/${project.name}&lt;/exclude&gt;
            &lt;exclude&gt;bin/wrapper-linux-x86-32&lt;/exclude&gt;
            &lt;exclude&gt;bin/wrapper-linux-x86-64&lt;/exclude&gt;
        &lt;/excludes&gt;
        &lt;fileMode&gt;640&lt;/fileMode&gt;
        &lt;directoryMode&gt;750&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
    &lt;fileSet&gt;
        &lt;directory&gt;src/main/assembly&lt;/directory&gt;
        &lt;outputDirectory&gt;/logs&lt;/outputDirectory&gt;
        &lt;excludes&gt;&lt;exclude&gt;*&lt;/exclude&gt;&lt;/excludes&gt;
    &lt;/fileSet&gt;
&lt;/fileSets&gt;

&lt;files&gt;
    &lt;file&gt;
        &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/${project.name}&lt;/source&gt;
        &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;
        &lt;fileMode&gt;750&lt;/fileMode&gt;
    &lt;/file&gt;
    &lt;file&gt;
        &lt;source&gt;${project.build.directory}/appassembler-jsw/jsw/${project.name}/bin/wrapper-linux-x86-64&lt;/source&gt;
        &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;
        &lt;fileMode&gt;750&lt;/fileMode&gt;
    &lt;/file&gt;
&lt;/files&gt;
</code></pre>

<p></assembly>
```</p>

<p>Ainsi, l'exécution de la commande suivante :
<code>bash
mvn package
</code></p>

<p>génère un livrable exploitable directement après sa décompression.</p>

<p>Lors d'un <code>mvn release</code>, il sera également automatiquement uploadé sur le <em>Repository Manager</em>.</p>

<h1>Conclusion</h1>

<p>En conclusion, je n'ai pas grand chose à ajouter si ce n'est que j'ai trouvé Resteasy-Netty simple à utiliser et qu'il a été aisé d'y ajouter tout ce qui était nécessaire à notre besoin.</p>

<p>Et le tout de manière simple et efficace pour une solution véloce et légère!</p>

<p>Pour faire encore plus simple, <a href="http://projectlombok.org/">Lombok</a> aurait pu être utilisé mais, de mémoire, en test de Java 8, une incompatibilité est apparue&hellip; à creuser donc pour cette partie&hellip; ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FluentLenium et Cucumber JVM... complément et precision]]></title>
    <link href="http://blog.jetoile.fr/2013/04/fluentlenium-et-cucumber-jvm-complement.html"/>
    <updated>2013-04-11T21:38:54+02:00</updated>
    <id>http://blog.jetoile.fr/2013/04/fluentlenium-et-cucumber-jvm-complement</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-R3ORi15Ei3Y/UTmwoq5A2II/AAAAAAAAA3o/uaIMSSZlq38/s1600/logo.png" alt="left-small" /></p>

<p>Dans mon article précédent, j'avais tenté d'expliquer comment il était possible d'intégrer les frameworks <a href="https://github.com/cucumber/cucumber-jvm">Cucumber JVM</a> et <a href="http://docs.seleniumhq.org/">Selenium</a> au travers de <a href="https://github.com/FluentLenium/FluentLenium">FluentLenium</a>.</p>

<p>En effet, pour rappel, FluentLenium permettait d'abstraire Selenium en lui offrant une API plus <em>fluent</em> mais également en lui apportant nativement ce qu'il préconise, à savoir le <a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a>.</p>

<p>Pour ce faire, j'avais proposé d'utiliser la délégation de l'initialisation de FluentLenium à une classe tierce injectée via le mécanisme d'injection de Cucumber JVM.</p>

<p>Cependant, suite à discussion avec la créatrice de FluentLenium (à savoir <a href="https://twitter.com/mathildelemee">Mathilde</a>), on s'est rendu compte que l'axe utilisé était légèrement biaisé (même s'il fonctionnait&hellip;).</p>

<p>Cet article revient donc sur ce point en proposant une solution plus simple mais présentera également comment il est possible de tester le scénario Cucumber avec différents navigateurs et il y aura un petit mot sur l'utilisation de navigateurs déportés (via les RemoteWebDriver de Selenium 2).</p>

<p>Pour ce faire, il sera découpé en 3 parties qui couvriront des usecases différents se traduisant donc par des implémentations différentes :</p>

<ul>
<li>cas de tests pour un site simple,</li>
<li>cas de tests pour un site complet,</li>
<li>cas de tests multi-navigateurs pour un site complet.</li>
</ul>


<p>A noter que je ne reviendrai pas sur les principes des différents frameworks/concepts mais juste sur comment il est possible d'implémenter ces différents usecases.</p>

<p>A noter également que l'article précédent aurait pu être modifié mais qu'en raison du nombre important de changements, il était plus simple d'en initier un autre&hellip;</p>

<!-- more -->


<h1>Cas de tests pour un site simple</h1>

<h2>Présentation et proposition d'implémentation</h2>

<p>Ce premier cas d'usage couvre le cas : &ldquo;j'ai un site que je veux tester avec Cucumber JVM et l'ensemble des steps peut être réuni dans une seule et même classe.&rdquo;</p>

<p>Bon je vois déjà la levée de bouclier : pourquoi réunir toutes les steps dans une seule et même classe. En fait, la raison du pourquoi sera expliquée un peu plus tard dans le paragraphe <em>Limites</em> de ce chapitre donc patience&hellip; ;&ndash;)</p>

<p>Contrairement à la façon que j'avais présentée dans mon article précédent, il n'est pas obligatoire de déléguer la déclaration des pages <code>FluentPage</code> à une autre classe étendant <code>FluentTest</code>. En fait, il suffit juste de faire étendre la classe contenant les steps cucumber de <code>FluentAdapter</code>, d'y déclarer les pages et d'appeler dans la méthode annotée par @Before (celui de Cucumber JVM bien sûr) les méthode d'initialisation du contexte de FluentLenium.</p>

<p>Pour rappel, cette initialisation instancie le WebDriver utilisé par Selenium 2 mais également les pages (annotées par l'annotation <code>@Page</code>) présentes dans la classe courante (ou ses parentes) qui doit, au minimum, étendre de <code>FluentAdapter</code>. Cela se fait au travers des méthodes <code>initFluent()</code> et <code>initTest()</code>.</p>

<p>Le code est donc extrêmement simple puisqu'il suffit de faire quelque chose du style :</p>

<p>```java
import cucumber.api.java.After;
import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;
import org.fluentlenium.core.FluentAdapter;
import org.fluentlenium.core.annotation.Page;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;</p>

<p>import static org.fest.assertions.api.Assertions.assertThat;</p>

<p>public class SimpleStep extends FluentAdapter {</p>

<p> @Page
 BingPage page;</p>

<p> @Before
 public void before() {
  this.initFluent(new HtmlUnitDriver());
  this.initTest();
 }</p>

<p> @Given(value = &ldquo;j accede a bing&rdquo;)
 public void step1() {
  goTo(page);
 }</p>

<p> @When(value = &ldquo;je recherche ([^ ]*) &rdquo;)
 public void step2(String keyword) {
  fill(&ldquo;#sb_form_q&rdquo;).with(keyword);
  submit(&ldquo;#sb_form_go&rdquo;);
 }</p>

<p> @Then(value = &ldquo;le titre est ([^ ]*) &rdquo;)
 public void step3(String keyword) {
  assertThat(title()).contains(keyword);
 }</p>

<p> @After
 public void after(){
  this.quit();
 }
}
```</p>

<p>où BingPage est :</p>

<p>```java
import org.fluentlenium.core.FluentPage;</p>

<p>public class BingPage extends FluentPage {</p>

<p> @Override
 public String getUrl() {
  return &ldquo;<a href="http://www.bing.com">http://www.bing.com</a>&rdquo;;
 }
}
```</p>

<p>et la feature, la suivante :</p>

<p>```text
Feature: basic</p>

<p>  Scenario: scenar1</p>

<pre><code>Given j accede a bing
When je recherche toto
Then le titre est toto 
</code></pre>

<p>```</p>

<p>Il est intéressant de remarquer la simplicité de la chose (et rien à voir avec l'implémentation que j'avais proposé précédemment!).</p>

<p>A part cela, peu de choses à ajouter : le code parle de lui même&hellip;</p>

<h2>Limites</h2>

<p>On vient de voir comme il était simple de faire cohabiter FluentLenium et Cucumber JVM.</p>

<p>Bien sûr, il y a un mais&hellip; (ça serait trop simple sinon) : comme on peut le constater, actuellement, toutes les steps se trouvent être dans la même classe. Cependant, dans le cas d'un site web un peu plus complexe, il est courant et même encouragé de séparer les steps dans différentes classes.</p>

<p>Dans l'implémentation précédente, l'annotation <code>@Before</code> a été utilisée pour initialiser le contexte (et plus particulièrement le webDriver et les pages pour ensuite injecter le webDriver dans ces dernières).</p>

<p>Cependant, dans le cas où les steps se trouvent être dans plusieurs classes, cela pose potentiellement un problème.</p>

<p>En effet, Cucumber JVM instancie la classe qui contient la définition de la step dès qu'il en a besoin et appelle la méthode annotée par <code>@Before</code> à l'instanciation de cette classe. Ainsi, dans notre cas, si les steps s'étaient trouvées dans deux classes, chacune étendant <code>FluentAdapter</code> et appelant <code>initFluent()</code> et <code>initTest()</code> dans la méthode annotée par @Before, alors cette instanciation aurait été faite deux fois et non une seule fois comme on aurait pu s'y attendre pour un même scénario donné&hellip;</p>

<p>Pire, les pages déclarées dans les classes n'auraient pas eu la même instance du webDriver et elles ne se seraient pas vu l'une l'autre&hellip;</p>

<p>Pas glop tout ça&hellip; :&lsquo;(</p>

<p>Ainsi, l'implémentation précédente fonctionne pour des cas &ldquo;simples&rdquo; mais si la partie test d’acceptante/intégration avait été plus complexe, alors cela aurait empêché la réutilisation et le découplage.</p>

<h1>Cas de tests pour un site complet</h1>

<h2>Présentation et proposition d'implémentation</h2>

<p>Il a été vu dans le paragraphe précédent qu'il pouvait être utile de disposer de plusieurs classes disposant des implémentations des fixtures.
Cependant, la question principale est de trouver comment il est possible de n'instancier qu'une seule fois par scénario le webDriver et de l'injecter dans des instances de pages propres au scénario.</p>

<p>La proposition présentée dans l'article précédent (modulo qu'il ne faut pas étendre de <code>FluentTest</code> mais de <code>FluentAdapter</code>) reste viable, mais il y a plus simple.</p>

<p>En effet, dans la proposition faite précédemment, la classe <code>FluentTestDelegator</code> avait à sa charge, à la fois la déclaration des pages, et l'instanciation et l'initialisation du contexte de FluentLenium. Pour rappel, cette instanciation/initialisation était réalisée par <a href="http://picocontainer.codehaus.org/">Pico Container</a> lors de l'injection de l'instance de cette classe dans la classe contenant les fixtures.</p>

<p>En fait, il est plus propre, d'un point de vue séparation des concepts, de laisser à cette classe le soin de proposer les fixtures d'initialisation du webDriver tout en séparant la déclaration des pages.</p>

<p>Cela peut être réalisé en créant une classe (<code>FluentPageInjector</code>) étendant de <code>FluentAdapter</code> qui définit les pages et de la faire étendre d'une classe (<code>FluentLeniumStepInitilizer</code>) qui définit les fixtures d'instanciation du webDriver.</p>

<p>Cela offre deux avantages : les classes qui définissent les steps de navigation n'ont qu'à étendre de <code>FluentPageInjector</code> pour avoir une visibilité sur les pages (tout en continuant d'injecter via pico l'instance de <code>FluentLeniumStepInitilizer</code>) et il devient alors possible de variabiliser le webDriver à utiliser.</p>

<p>```text
Feature: browser</p>

<p>  Scenario: navigation version firefox</p>

<pre><code>Given I connect on url http://localhost:8080 with firefox
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
And driver is closed
</code></pre>

<p>  Scenario: navigation version chrome</p>

<pre><code>Given I connect on url http://localhost:8080 with chrome with parameters webdriver.chrome.driver:/opt/chromedriver/chromedriver
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
And driver is closed
</code></pre>

<p>  Scenario: navigation version phantomjs</p>

<pre><code>Given I connect on url http://localhost:8080 with phantomjs with parameters phantomjs.binary.path:/opt/phantomjs-1.9.0-linux-x86_64/bin/phantomjs 
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
And driver is closed
</code></pre>

<p>```</p>

<br/>


<p>```java
package step;</p>

<p>import org.fluentlenium.core.FluentAdapter;
import org.fluentlenium.core.annotation.Page;
import page.HomePage;
import page.ResultPage;</p>

<p>public class FluentPageInjector extends FluentAdapter {</p>

<pre><code>@Page
protected HomePage homePage;

@Page
protected ResultPage resultPage;
</code></pre>

<p>}
```</p>

<p>On remarque, comme dit plus haut, que cette classe n'a qu'un seul rôle qui est de déclarer les pages tout en étendant de <code>FluentAdapter</code>.</p>

<p>```java
public class HomePageStep extends FluentPageInjector {</p>

<pre><code> public HomePageStep(FluentLeniumStepInitilizer delegator) {
  this.homePage = delegator.homePage;
  this.resultPage = delegator.resultPage;
 }


 @Given("^j accede a la homePage$")
 public void j_accede_a_homePage() {
  goTo(homePage);
 }

 @Given("^je suis sur homePage$")
 public void je_suis_sur_homePage() {
  homePage.isAt();
 }

 @When("^je submit$")
 public void je_submit() throws Throwable {
  homePage.submit();
 }
</code></pre>

<p>}
```</p>

<br/>


<p>```java
public class ResultPageStep extends FluentPageInjector {</p>

<pre><code>public ResultPageStep(FluentLeniumStepInitilizer delegator) {
    this.resultPage = delegator.resultPage;
}

@When("^je suis sur la page result$")
public void je_suis_sur_la_page_result() throws Throwable {
    resultPage.isAt();
}
</code></pre>

<p>}
```</p>

<p>Ces classes correspondent aux classes qui définissent les fixtures. Elles étendent de <code>FluentPageInjector</code> de façon à pouvoir bénéficier de la visibilité sur les pages. Par contre, il est intéressant de constater que, dans son constructeur, la classe <code>FluentLeniumStepInitializer</code> est injecté via Pico Container. Cela permet d'affecter la valeur des pages.</p>

<p>```java
public class FluentLeniumStepInitilizer extends FluentPageInjector {</p>

<pre><code>@Given("^I connect on url ([^ ]*) with ([^ ]*) with parameters ([^ ]*)$")
public void browser_connect(String host, String browser, String parameters) {
    init(host, browser, parameters);
}

@Then("^drivers are closed")
public void close() {
    this.quit();
}

@After
public void afterClose() {
    this.quit();
}

private void init(String host, String browserName, String parametersLine) {
    Browser browser = null;

    DesiredCapabilities capabilities = new DesiredCapabilities();

    String[] parameters = parametersLine.slip(";");
    for (String parameter : parameters) {
        if (!parameter.isEmpty()) {
            String[] key_value = parameter.split(":");
            capabilities.setCapability(key_value[0], key_value[1]);
        }
    }

    browser = Browser.getBrowser(browserLine.get(0));
    capabilities.setBrowserName(browser.getName());

    initWebDriver(host, browserHost, browser, capabilities);
}

private void initWebDriver(String host, String browserHost, Browser browser, DesiredCapabilities capabilities) {
    Fluent fluent = null;
    WebDriver driver = null;
    if (browser != null) {
        driver = BrowserMapper.getDriver(browser, capabilities);
        fluent = this.initFluent(driver);
    }

    fluent.withDefaultUrl(host);
    this.initTest();
}
</code></pre>

<p>}
```</p>

<p>Cette classe étend par transitivité <code>FluentAdapter</code> et dispose donc de la visibilité sur les méthodes d'initialisation de <code>FluentLenium</code>. En outre, en étendant <code>FluentPageInjector</code> (qui étend de <code>FluentAdapter</code>), cela lui permet, à l'appel de <code>initTest()</code>, d'initialiser les pages.
Concernant l'initialisation des webDriver, cela est fait au niveau de la classe <code>BrowserMapper</code>.</p>

<p>```java
public enum Browser {</p>

<pre><code>HTMLUNIT("default"),
FIREFOX("firefox"),
CHROME("chrome"),
PHANTOMJS("phantomjs");

private String name;

Browser(String name) {
    this.name = name;
}

public String getName() {
    return this.name;
}

public static Browser getBrowser(String name) {
    for (Browser browser : values()) {
        if (browser.getName().equalsIgnoreCase(name)) {
            return browser;
        }
    }
    return HTMLUNIT;
}
</code></pre>

<p>}
```</p>

<br/>


<p>```java
import org.openqa.selenium.Capabilities;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;
import org.openqa.selenium.phantomjs.PhantomJSDriver;</p>

<p>import java.util.HashMap;
import java.util.Map;</p>

<p>public class BrowserMapper {
 private String name;</p>

<p> private static Map&lt;Browser, WebDriverLazyLoader> browserMapper = new HashMap&lt;Browser, WebDriverLazyLoader>();</p>

<p> static {
  browserMapper.put(Browser.CHROME, new WebDriverLazyLoader(ChromeDriver.class));
  browserMapper.put(Browser.FIREFOX, new WebDriverLazyLoader(FirefoxDriver.class));
  browserMapper.put(Browser.HTMLUNIT, new WebDriverLazyLoader(HtmlUnitDriver.class));
  browserMapper.put(Browser.PHANTOMJS, new WebDriverLazyLoader(PhantomJSDriver.class));
 }</p>

<p> public static WebDriver getDriver(Browser browser, Capabilities capabilities) {
  WebDriverLazyLoader webDriverLazyLoader = browserMapper.get(browser);
  if (webDriverLazyLoader != null) {</p>

<pre><code>        if (browser == Browser.PHANTOMJS) {
            return webDriverLazyLoader.getWebDriverClass(capabilities);

        } else if (browser == Browser.CHROME) {
            System.setProperty("webdriver.chrome.driver", (String) capabilities.getCapability("webdriver.chrome.driver"));
            return webDriverLazyLoader.getWebDriverClass(capabilities);

        } else {
            return webDriverLazyLoader.getWebDriverClass();
        }
</code></pre>

<p>  }
  return browserMapper.get(Browser.HTMLUNIT).getWebDriverClass();
 }
}
```</p>

<p>Cette classe permet de faire le pont avec les webDriver qu'il est possible d'utiliser. Cependant, la petite astuce consiste à instancier de manière &ldquo;Lazy&rdquo; ces derniers.</p>

<p>En effet, appeler le constructeur d'un webDriver l'instancie mais le démarre également (ie. que la fenêtre du navigateur s'ouvre réellement). Du coup, la petite classe présentée ci-dessous a été utilisée.</p>

<p>```java
import org.openqa.selenium.Capabilities;
import org.openqa.selenium.WebDriver;</p>

<p>class WebDriverLazyLoader {</p>

<pre><code>private Class webDriverClass;


public WebDriverLazyLoader(Class webDriverClass) {
    this.webDriverClass = webDriverClass;
}

public WebDriver getWebDriverClass() {
    try {
        return (WebDriver)this.webDriverClass.newInstance();
    } catch (ReflectiveOperationException e) {
        e.printStackTrace();
    }
    return null;
}

public WebDriver getWebDriverClass(Capabilities capabilities) {
    try {
        return (WebDriver)this.webDriverClass.getConstructor(Capabilities.class).newInstance(capabilities);
    } catch (ReflectiveOperationException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>}
```</p>

<h2>Limites</h2>

<p>Comme on a pu le voir dans ce chapitre, il est aisé de partager les fixtures Cucumber JVM dans des classes différentes tout en bénéficiant de FluentLenium.</p>

<p>Cependant, pour certains besoins, il peut être utile de vouloir lancer les tests d'acceptance/intégration sur différents navigateurs.</p>

<p>Bien sûr, chaque step pourrait boucler sur l'ensemble des navigateurs sur lesquels les tests doivent être exécutés, mais cela induirait des problématiques d'entrelacement des actions et donc soulèverait des problématiques comme la gestion d'un contexte par webDriver, l'accès à un rapport &ldquo;illisible&rdquo; ou un manque de contrôle sur les préconditions du test qui sont, généralement, lié au scénario et non à une Step.</p>

<p>Le chapitre suivant tentera de répondre à cette problématique en proposant un moyen de &ldquo;boucler&rdquo; sur le scénario avec différents navigateurs.</p>

<h1>Cas de tests multi-navigateurs pour un site complet</h1>

<h2>Présentation et proposition d'implémentation</h2>

<p>Il a été vu dans le chapitre précédent comment il était possible d'exécuter des tests d'acceptances/intégration sur un navigateur donné.</p>

<p>Ce chapitre présentera, pour sa part, une façon de les lancer sur différents navigateurs sans avoir à faire de copier/coller ;&ndash;).</p>

<p>En fait, Cucumber JVM permet nativement de boucler sur un scénario en utilisant différents paramètres. Cela se fait par le mécanisme de <code>scenario outline</code>.</p>

<p>```text</p>

<p>Feature: multibrowser</p>

<p>  Scenario Outline: multi browser navigation version 1:</p>

<pre><code>Given I connect on url http://localhost:8080 with &lt;browser&gt; with parameters &lt;parameters&gt;
Given j accede a la homePage
And je suis sur homePage
When je submit
Then je suis sur la page result
And driver is closed
</code></pre>

<p>  Examples:</p>

<pre><code>| browser | parameters                                             | 
| firefox |                                                        | 
| default |                                                        | 
| chrome  | webdriver.chrome.driver:/opt/chromedriver/chromedriver | 
</code></pre>

<p>```</p>

<p>Et&hellip; c'est tout!</p>

<p>Le code n'a pas à être modifié : Cucumber JVM s'occupe de tout! ;&ndash;)</p>

<h2>Limites</h2>

<p>On a vu dans le paragraphe précédent comment il était possible d'exécuter facilement des tests d'acceptance/intégration en s'appuyant sur la notion de scénario outline offerte nativement par Cucumber JVM.</p>

<p>Coté limitation, je n'en vois pas trop&hellip;</p>

<p>Peut être le fait de ne pas instancier le webDriver pour chaque scénario (opération assez coûteuse en temps) mais cela est aisément résolvable en utilisant une sorte de cache de webDriver fonctionnant sur le principe de singleton qui serait réinialisé lors de l'appel à la step drivers are closed qui serait isolée dans son propre <code>scenario outline</code> :</p>

<p>```text
  Scenario Outline: browsers are closed:</p>

<pre><code>Then driver is closed
</code></pre>

<p>  Examples:</p>

<pre><code>| browser   | parameters                                                            | 
| firefox   |                                                                       | 
| default   |                                                                       | 
| phantomjs | phantomjs.binary.path:/opt/phantomjs-1.9.0-linux-x86_64/bin/phantomjs | 
| chrome    | webdriver.chrome.driver:/opt/chromedriver/chromedriver                |     
</code></pre>

<p>```</p>

<h1>Conclusion</h1>

<p>Il a été présenté dans cet article comment il était possible d'implémenter l'intégration de Cucumber JVM et de Selenium à l'aide de FluentLenium.</p>

<p>Cet article n'a, cependant, pas fait mention de l'exécution des tests sur des navigateurs distants via les <strong>RemoteWebDriver</strong> mais cela est tout à fait possible (même si le code montré ici ne le présente pas) et est même totalement fonctionnel : pour ce faire (code disponible <a href="https://github.com/jetoile/fluentlenium-cucumber/tree/multiNav">ici</a>), il suffit de fournir, entre autre, des paramètres supplémentaires comme l'url de connexion au hub Selenium et d'instancier un <code>RemoteWebDriver</code> plutôt que le webDriver.</p>

<p>De même, le code permettant d'instancier à la mode singleton les webDriver est disponible <a href="https://github.com/jetoile/fluentlenium-cucumber/blob/multiNav/src/test/java/step/FluentLeniumStepInitilizer.java">ici</a> (voir la méthode <code>initCachedWebDriver()</code> de la classe <code>FluentLeniumStepInitilizer</code>).</p>

<p>Enfin, un dernier mot sur la façon dont il est possible d'exécuter tout ce beau monde (comme ça, je réponds à la remarque très pertinente de <a href="https://twitter.com/josepaumard">José</a> ;&ndash;) ) parce que faire des tests, c'est bien, les jouer, c'est mieux!</p>

<p>Il est possible de jouer les tests d'au moins trois manières distinctes : une orienté &ldquo;vraie vie&rdquo; (ie. utilisable au sein d'un build maven et donc exécutable via une usine d'intégration continue) et deux autres plutôt orientés développement.</p>

<p>Ainsi, pour jouer les tests via maven, il suffit de le déclarer dans le <code>pom.xml</code> le plugin failsafe en le branchant sur la &ldquo;bonne phase&rdquo;, à savoir le runner Cucumber JVM :</p>

<p>```xml
<plugin></p>

<pre><code>&lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;goals&gt;
            &lt;goal&gt;integration-test&lt;/goal&gt;
            &lt;goal&gt;verify&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;
    &lt;includes&gt;
        &lt;include&gt;**/BasicRunner.java&lt;/include&gt;
    &lt;/includes&gt;
&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<p>Coté jouabilité des tests sur un environnement de développement  il est possible d'exécuter le <strong>Runner</strong> Cucumber JVM directement (comme lors de l'exécution d'une classe de test unitaire) ou d'utiliser le plugin Cucumber JVM proposé par notre IDE préféré (pour moi IntelliJ, pour les autres, je ne sais pas&hellip;).</p>

<p>```java
import cucumber.api.junit.Cucumber;
import org.junit.runner.RunWith;</p>

<p>@RunWith(Cucumber.class)
@Cucumber.Options(features = &ldquo;classpath:fr/jetoile/webapp/acceptance&rdquo;, format = {&ldquo;pretty&rdquo;, &ldquo;html:target/cucumber&rdquo;, &ldquo;json:target/cucumber.json&rdquo;})
public class RunCucumberFeatures {
}
```</p>

<p><img src="http://4.bp.blogspot.com/-RGW7oSAChOQ/UWXmqPsYh6I/AAAAAAAAA4Y/cDH-YyVcpgs/s1600/screenshot01.png" alt="medium" /></p>

<br/>


<p><img src="http://3.bp.blogspot.com/-FkF8ZO6r6co/UWXnUNjqjII/AAAAAAAAA4g/obtSC7BS6kI/s1600/screenshot02.png" alt="medium" /></p>

<p>Enfin, pour rappel, mon usecase étant de tester mon application web en boite noire, un prérequis était que mon application web soit démarrée au préalable.</p>

<p>Pour ce faire, le plugin maven Jetty (ou Tomcat au choix) a été utilisé et branché sur la phase de pré-integration.</p>

<p>Lors de l'exécution des tests en mode développement (ie. en les lançant comme un TU ou à l'aide du plugin Cucumber JVM via l'IDE), un profil n'exécutant pas le plugin failsafe mais uniquement le démarrage du jetty/tomcat embarqué a été utilisé.</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li>article sur les limitations de Cucumber JVM pour le partage de données entre steps : <a href="http://zsoltfabok.com/blog/2012/09/cucumber-jvm-hooks/">http://zsoltfabok.com/blog/2012/09/cucumber-jvm-hooks/</a></li>
<li>page de fluentLenium : <a href="https://github.com/FluentLenium/FluentLenium">https://github.com/FluentLenium/FluentLenium</a></li>
<li>page des webDriver de Selenium : <a href="http://docs.seleniumhq.org/docs/03_webdriver.jsp">http://docs.seleniumhq.org/docs/03_webdriver.jsp</a></li>
<li>code : <a href="http://github.com/jetoile/fluentlenium-cucumber/">http://github.com/jetoile/fluentlenium-cucumber/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FluentLenium et Cucumber JVM sont sur un bateau...]]></title>
    <link href="http://blog.jetoile.fr/2013/03/fluentlenium-et-cucumber-jvm-sont-sur.html"/>
    <updated>2013-03-14T16:39:36+01:00</updated>
    <id>http://blog.jetoile.fr/2013/03/fluentlenium-et-cucumber-jvm-sont-sur</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-R3ORi15Ei3Y/UTmwoq5A2II/AAAAAAAAA3o/uaIMSSZlq38/s1600/logo.png" alt="left-small" /></p>

<p>Dans un <a href="/2013/03/demarrer-une-webapp-en-mode-embedded.html">article précédent</a>, j'avais abordé comment il était possible de démarrer une application web dans un conteneur de Servlet de manière embedded au sein de la phase integration de Maven. Bien sûr, cela n'a pas été fait que pour l'exercice de style et il y avait une petite idée derrière : pouvoir exécuter des tests d'acceptance en mode boite noire sur l'application.</p>

<p>Pour faire les tests d'acceptance, le choix de Cucumber JVM a été fait afin de permettre l'expression de tests d'acceptance avec une sémantique utilisant le pattern <strong>Given/When/Then</strong> mais également afin de permettre à des non développeurs de comprendre/écrire les scénarii de test à exécuter.</p>

<p>L'application à tester étant une application web, un besoin s'est fait sentir de tester la partie rendue. Dans cet article, lorsque l'on parlera de tester la partie rendue, il sera question de vérifier que l'élément recherché se trouve bien dans le document html remonté dans le navigateur web. Pour rappel (cf. le paragraphe Contexte de ce <a href="2013/03/demarrer-une-webapp-en-mode-embedded.html">post</a>), l'application testée s'appuie sur un framework web java de type Struts2.</p>

<p>Aussi, il ne sera pas question, ici, de tester le rendu dans différents navigateurs.</p>

<p>Il a été décidé de partir sur une solution s'appuyant sur un runtime à base de Selenium : en effet, un besoin latent étant, à terme, de tester le rendu de l'application web sur les différents navigateurs, cette solution semblait correspondre le mieux aux besoins.</p>

<p>Bref, passons ce besoin pour revenir à notre objectif premier, à savoir, vérifier la présence des éléments dans l'arbre DOM remonté par l'application web.</p>

<p>Pour résumer, il a été décidé de partir sur :</p>

<ul>
<li>Cucumber JVM pour la partie représentation/écriture des scénarii,</li>
<li>Selenium pour la partie exécution des tests.</li>
</ul>


<p>Cependant, la syntaxe sur la partie WebDriver de Selenium 2 étant assez verbeuse, il a été décidé d'utiliser le framework FluentLenium qui offre une API plus simple et plus naturelle (enfin plus fluent quoi! ;&ndash;) ). En outre, en plus d'une API plus facile d'utilisation, la notion native de Page de FluentLenium poussant à mieux découpler la représentation d'une page et son test, cela a joué en sa faveur ;&ndash;)</p>

<p>Ainsi, cet article présentera comment il a été possible d'intégrer Cucumber JVM avec FluentLenium afin de pouvoir faire tourner des tests avec Selenium.</p>

<p>A noter que je ne m'attarderai pas, dans cet article, à présenter exhaustivement les différents protagonistes mais seulement les quelques points qu'il est nécessaires de connaitre afin d'intégrer ensemble ces différents framework.</p>

<p>[update] Suite à discussion avec la créatrice de FluentLenium, un autre article a été initié et apporte de nombreux compléments mais également correction à cet article. Pour en savoir, plus, rendez vous <a href="/2013/04/fluentlenium-et-cucumber-jvm-complement.html">ici</a>&hellip;</p>

<!-- more -->


<h1>Présentation des protagonistes</h1>

<h2>Cucumber JVM</h2>

<p><img src="http://2.bp.blogspot.com/-vb7zd_BqITk/UTmwyd4yWsI/AAAAAAAAA3w/tYVxH4hxlig/s1600/cucumber2.jpg" alt="center" /></p>

<p><a href="https://github.com/cucumber/cucumber-jvm">Cucumber JVM</a> est un fork Java de <a href="http://cukes.info/">Cucumber</a> inialement développé en Ruby.</p>

<p>Tout comme <a href="http://jbehave.org/">JBehave</a>, il est orienté BDD (<em>Behaviour Driven Development</em>) et il permet d'écrire ses <strong>scénarii</strong> de tests en suivant le pattern <strong>Given/When/Then</strong> qui correspond à déterminer un ensemble de <a href="https://github.com/cucumber/cucumber/wiki/Step-Definitions">Step</a>.</p>

<p>Ces scénarii s'écrivent dans des fichiers <strong>features</strong> qui sont lus par Cucumber JVM. Ce dernier se charge alors de faire correspondre les <strong>Steps</strong> avec les fixtures associés. Ces <strong>steps</strong> sont des méthodes Java annotées par :</p>

<ul>
<li>@Given(value = &ldquo;&rdquo;)</li>
<li>@When(value = &ldquo;&rdquo;)</li>
<li>@Then(value = &ldquo;&rdquo;)</li>
</ul>


<p>A noter que seule la valeur de l'annotation est utilisée par Cucumber JVM.</p>

<p>Alors que les steps à la sémantique Given permettront de poser les conditions nécessaires à l'exécution du scénario, les steps When exécuteront l'action à tester et les steps Then testeront que tout s'est bien passé en utilisant le framework d'assertion de son choix tels que JUnit, Fest-assert et/ou Harmcrest.</p>

<p>A noter également que pour passer un état d'une Step à une autre, Cucumber JVM nous oblige à stocker ces derniers dans des variables de classe ou à passer par son mécanisme d'injection à l'aide de framework IoC tels que <a href="http://picocontainer.codehaus.org/">Picocontainer</a>.</p>

<p>Ainsi, on peut résumer grossièrement en disant qu'un scénario est écrit dans un fichier <strong>feature</strong> et est composé d'un ensemble de Step qui sont associés à des méthodes qui correspondent aux différentes <strong>fixtures</strong>.</p>

<p>Pour plus d'informations sur le BDD, je vous renvoie sur un <a href="http://blog.soat.fr/2011/06/breizhcamp-behaviour-driven-development-par-olivier-billard-et-thierry-henrio/">compte rendu</a> d'une présentation d'Olivier Billard et de Thierry Henrio réalisé au BreizhCamp que j'avais fait à l'époque.</p>

<h2>Selenium 2</h2>

<p><img src="http://4.bp.blogspot.com/-xOJkyRycXEU/UTmxGd1a-nI/AAAAAAAAA4A/kMPuTOc5tpY/s1600/big-logo.png" alt="center" /></p>

<p>Dans notre cas d'usage, il y a assez peu de chose à dire sur <a href="http://docs.seleniumhq.org/">Selenium</a> si ce n'est qu'il permet, en fournissant différents <strong>WebDriver</strong>, de tester le rendu d'une page HTML en simulant différentes actions telles que le submit de formulaires, le clique d'un bouton et en allant chercher différents éléments dans la page rendue.</p>

<p>Il propose différentes implémentations de WebDriver tels que <strong>FirefoxDriver</strong> ou <strong>HtmlUnitDriver</strong>.</p>

<p>Selenium offre également la possibilité d'exécuter les navigateurs qu'il lance sur différentes machines via Selenium Server mais, dans notre cas, cette fonctionnalité ne sera pas utile. De même, il ne sera pas abordé la partie Selenium IDE qui est peu exploitable car difficilement maintenable. En effet, il est courant et même fortement recommandé de séparer, pour des raisons évidentes, les scénarii à tester du rendu de la page (par exemple en utilisant le <a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a>).</p>

<p>Les liens suivants détaillent plus précisément ces différents points :</p>

<ul>
<li><a href="http://fr.slideshare.net/MathildeLemee/selenium-testng-selenium-grid-best-practices">http://fr.slideshare.net/MathildeLemee/selenium-testng-selenium-grid-best-practices</a></li>
<li><a href="http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-api-commands-and-operations">http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-api-commands-and-operations</a></li>
</ul>


<h2>FluentLenium</h2>

<p><img src="http://1.bp.blogspot.com/-fyH1CNEBvIw/UTmxNk5WZTI/AAAAAAAAA4I/obgbEW5Ae6w/s1600/code.png" alt="center" /></p>

<p><a href="https://github.com/FluentLenium/FluentLenium">FluentLenium</a> est un framework utilisant Selenium mais proposant une API plus simple et plus naturelle que celle offerte par ce dernier.</p>

<p>Il a été pensé pour s'intégrer à des tests exécutés avec JUnit ou TestNG et se charge donc d'initialiser le <strong>WebDriver</strong> Selenium à chaque fois qu'il exécute un test.</p>

<p>Pour ce faire, il utilise, au moment de l'écriture de ces lignes, le mécanisme de <strong>Rule</strong> JUnit qui fait, grosso modo, comme le @Before de JUnit mais qui peut être partagé entre les différentes classes de test.</p>

<p>En outre, FluentLenium s'appuie sur la notion de <strong>FluentPage</strong> et de <strong>FluentTest</strong>. En fait, pour faire simple, les classes de tests doivent étendre FluentTest, ce qui permet à toutes les méthodes annotées par @Test d'initialiser le WebDriver Selenium. La classe peut, de plus, bénéficier des méthodes portées par FluentTest.</p>

<p>La notion de FluentPage permet, quant à elle, de représenter une page (au sens HTML). Cette implémentation du <a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a> incite ainsi l'utilisateur à découpler le test du contenu de la page qui sera alors la seule à être garante du rendu.</p>

<p>Enfin, via l'annotation <strong>Page</strong>, les classes qui étendent FluentPage peuvent être injectées directement dans l'implémentation du FluentTest. Les liens suivants détaillent plus précisément ces différents points :</p>

<ul>
<li><a href="http://fr.slideshare.net/MathildeLemee/fluentlenium">http://fr.slideshare.net/MathildeLemee/fluentlenium</a></li>
<li><a href="https://github.com/FluentLenium/FluentLenium">https://github.com/FluentLenium/FluentLenium</a></li>
</ul>


<h1>Etude sur la mise en oeuvre</h1>

<p>On a vu dans le paragraphe précédent quelques-unes des notions nécessaires à l'intégration de nos trois comparses.</p>

<p>Cependant, il est intéressant de noter que Cucumber JVM et FluentLenium s'appuient sur deux paradigmes potentiellement opposés. En effet, alors que Cucumber JVM dispose d'une représentation par Step formalisé par des méthodes java, FluentLenium propose une granularité par méthode.</p>

<p>En outre, deux points sont primordiaux :</p>

<ul>
<li>FluentLenium s'appuie sur la notion de Rule JUnit pour instancier, démarrer puis stopper le webDriver,</li>
<li>Cucumber JVM ne supporte pas la <a href="https://github.com/cucumber/cucumber-jvm/issues/393">notion de Rule</a> et refuse tout autre Runner différent que le sien.</li>
</ul>


<p>Bien sûr, on peut se douter qu'il est possible de contourner le problème sinon cet article serait un peu mensongé&hellip; ;&ndash;)</p>

<p>En fait, la solution qui a été mise en place pour faire fonctionner conjointement ces deux framework est assez simple : faire que les classes déclarant les <strong>Steps</strong> Cucumber JVM délèguent à une classe étendant FluentTest les différentes actions et vérifications.</p>

<p>Cette classe pourra porter les différentes pages (au sens FluentLenium) et devra exposer les méthodes adéquates qui initialiseront et arrêteront le webDriver cible (méthodes fournies par FluentTest).</p>

<p>A titre informatif, le fait d'utiliser l'<em>Autocloseable</em> (et plus précisément le <em>try-with-resources</em>) de Java 7 s'est traduit par un échec puisque le driver doit rester actif entre les différentes Steps.</p>

<p>De même, essayer d'injecter via Picocontainer les pages ne fonctionne pas car, à ce jour, l'implémentation même de FluentLenium fait que les annotations @Page qui permettent d'initialiser et d'instancier les <strong>FluentPages</strong> doivent être dans une implémentation de <strong>FluentTest</strong>.</p>

<p>Ainsi, cela pourrait se traduire par le code suivant :</p>

<p><code>HomePageStep.java</code></p>

<p>```java
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;
import org.fest.assertions.fluentlenium.FluentLeniumAssertions;</p>

<p>public class HomePageStep {</p>

<pre><code>private FluentTestDelegator fluentLeniumDelegate;

/**
 * injection par pico donc pas besoin d'initialiser le driver (deja fait par le delegator)
 * @param fluentLeniumDelegate
 */
public HomePageStep(FluentTestDelegator fluentLeniumDelegate) {
    this.fluentLeniumDelegate = fluentLeniumDelegate;
}

@When(value = "I go on home page")
public void homePageIsDisplayed() {
        fluentLeniumDelegate.goTo(fluentLeniumDelegate.homePage).await().untilPage();
}

@Then(value = "home page is displayed")
public void homePageIsDisplayed() {
    FluentLeniumAssertions.assertThat(fluentLeniumDelegate.homePage).isAt();
}

@When(value = "I submit the form")
public void submitForm() {
    fluentLeniumDelegate.homePage.submit();
}
</code></pre>

<p>}
```</p>

<p><code>ResultPageStep.java</code></p>

<p>```java
public class ResultPageStep {</p>

<pre><code>private FluentTestDelegator fluentLeniumDelegate;

/**
 * injection par pico donc pas besoin d'initialiser le driver (deja fait par le delegator)
 * @param fluentLeniumDelegate
 */
public ResultPageStep(FluentTestDelegator fluentLeniumDelegate) {
    this.fluentLeniumDelegate = fluentLeniumDelegate;
}

@Then(value = "I am on result page")
public void isOnPage() {
    FluentLeniumAssertions.assertThat(fluentLeniumDelegate.resultPage).isAt();
}
</code></pre>

<p>}
```</p>

<p><code>CommonStep.java</code>
```java
import cucumber.api.java.en.When;</p>

<p>public class CommonStep {</p>

<pre><code>private FluentTestDelegator fluentLeniumDelegate;

public StepHelper(FluentTestDelegator fluentLeniumDelegate) {
    this.fluentLeniumDelegate = fluentLeniumDelegate;
}

@When(value = "I stop my driver")
public void webDrivercloser() {
    fluentLeniumDelegate.close();
}
</code></pre>

<p>}
```</p>

<p><code>FluentTestDelegator.java</code>
```java
import cucumber.api.java.en.When;
import org.fluentlenium.adapter.FluentTest;
import org.fluentlenium.core.annotation.Page;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;
import org.openqa.selenium.remote.DesiredCapabilities;</p>

<p>import java.io.File;
import java.io.IOException;</p>

<p>public class FluentTestDelegator extends FluentTest implements AutoCloseable {</p>

<pre><code>@Page
public HomePage homePage;

@Page
public ResultPage resultPage;

public FluentTestDelegator() throws IOException {
    init();
}

/**
* Appel des operations faites par le Rule Junit de FluentTest
*/
public void init() throws IOException {
    initFluent(new HtmlUnitDriver()).withDefaultUrl("http://localhost:9090");
</code></pre>

<p>//        initFluent(getDefaultDriver()).withDefaultUrl(&ldquo;<a href="http://localhost:9090">http://localhost:9090</a>&rdquo;);</p>

<pre><code>    initTest();
    setDefaultConfig();
}

@Override
public void close() {
    if (getDriver() != null) {
        quit();
    }
}
</code></pre>

<p>}
```</p>

<p><code>HomePage.jave</code>
```java
import cucumber.api.DataTable;
import org.fluentlenium.core.FluentPage;
import org.fluentlenium.core.domain.FluentList;
import org.fluentlenium.core.domain.FluentWebElement;</p>

<p>import java.util.List;</p>

<p>import static org.fest.assertions.Assertions.assertThat;
import static org.fluentlenium.core.filter.FilterConstructor.withText;
import static org.junit.Assert.assertEquals;</p>

<p>public class HomePage extends FluentPage {</p>

<pre><code>@Override
public String getUrl() {
    return "/webapp/home";
}

@Override
public void isAt() {
    assertThat(title()).containsIgnoringCase("homePage");
}

public void submit() {
    submit("#searchForm &gt; form").await().untilPage();
}
</code></pre>

<p>}
```</p>

<p><code>ResultPage.java</code>
```java
public class ResultPage extends FluentPage {</p>

<pre><code>@Override
public String getUrl() {
    return "/webapp/result";
}

@Override
public void isAt() {
    assertThat(title()).containsIgnoringCase("resultPage");
}
</code></pre>

<p>}
```</p>

<p><code>scenario1.feature</code>
```text</p>

<h1>encoding: iso-8859-1</h1>

<p>Feature: homepage test</p>

<p>  Scenario: homePage should be displayed</p>

<pre><code>When I go on home page
Then home page is displayed
Then I stop my driver
</code></pre>

<p>  Scenario: a submit on homePage should redirect to resultPage</p>

<pre><code>When I go on home page
And I submit the form
Then I am on result page
Then I stop my driver
</code></pre>

<p>```</p>

<p>On constate que le code est un peu plus verbeux que ce qu'on aurait souhaité avoir mais cela fonctionne sans soucis.
A noter que via la méthode init de <strong>FluentTestDelegator</strong>, il est possible de préciser le <strong>webDriver</strong> à utiliser (dans notre cas, HtmlUnitDriver).</p>

<h1>Mise en oeuvre</h1>

<p>On a vu dans le paragraphe précédent comment il était possible de faire fonctionner conjointement Cucumber JVM et FluentLenium.</p>

<p>Du coup, il n'y a plus grand chose à rajouter dans ce paragraphe si ce n'est la configuration de notre chef d'orchestre (à savoir Maven) qui a été utilisé pour faire fonctionner tout ce beau monde&hellip; ;&ndash;)</p>

<p>```xml</p>

<pre><code>&lt;dependencies&gt;        
    &lt;dependency&gt;
        &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
        &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;
        &lt;version&gt;1.3&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;batik&lt;/groupId&gt;
        &lt;artifactId&gt;batik-ext&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;        
    &lt;!-- pas de montee de version de junit pour cause de conflit avec hamcrest --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
                &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;info.cukes&lt;/groupId&gt;
        &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;info.cukes&lt;/groupId&gt;
        &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;info.cukes&lt;/groupId&gt;
        &lt;artifactId&gt;cucumber-picocontainer&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;
        &lt;artifactId&gt;fluentlenium-festassert&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;junit&lt;/groupId&gt;
                &lt;artifactId&gt;junit-dep&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.easytesting&lt;/groupId&gt;
        &lt;artifactId&gt;fest-assert&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>  <build>
   <plugins></p>

<pre><code>                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
                    &lt;executions&gt;
                        &lt;execution&gt;
                            &lt;goals&gt;
                                &lt;goal&gt;integration-test&lt;/goal&gt;
                                &lt;goal&gt;verify&lt;/goal&gt;
                            &lt;/goals&gt;
                        &lt;/execution&gt;
                    &lt;/executions&gt;
                    &lt;configuration&gt;
                        &lt;includes&gt;
                            &lt;include&gt;**/RunCucumberFeatures.java&lt;/include&gt;
                        &lt;/includes&gt;
                    &lt;/configuration&gt;
                &lt;/plugin&gt;

    &lt;/plugins&gt;             
</code></pre>

<p>  </build> <br/>
```</p>

<p>```java
import cucumber.api.junit.Cucumber;
import org.junit.runner.RunWith;</p>

<p>@RunWith(Cucumber.class)
@Cucumber.Options(features = &ldquo;classpath:fr/jetoile/webapp/acceptance&rdquo;, format = {&ldquo;pretty&rdquo;, &ldquo;html:target/cucumber&rdquo;, &ldquo;json:target/cucumber.json&rdquo;})
public class RunCucumberFeatures {
}
```</p>

<h1>Conclusion</h1>

<p>On a vu dans cet article (qui est la suite logique d'un <a href="/2013/03/demarrer-une-webapp-en-mode-embedded.html">article précédent</a>) comment il était possible de faire des tests d'acceptance en utilisant conjointement Cucumber JVM et FluentLenium.</p>

<p>A l'utilisation, cela s'avère agréable et rapide à écrire surtout avec quelques petits tweaks supplémentaires qui n'ont pas été exposés ici (profile Maven pour ne démarrer que le serveur embedded et exécution des scénarii Cucumber avec IntelliJ 12 avec possibilité de bénéficier du debugger que ce soit au niveau de l'exécution des tests (debugger ou utilisation d'un webDriver autre que HtmlUnitDriver) ou de l'application cible (via <code>mvnDebug</code>)).</p>

<p>Bref, en tout cas, même si la mise en oeuvre a été un peu galère, il a été possible de bénéficier du meilleur des deux framework sans avoir à se &ldquo;taper&rdquo; la lourdeux de Selenium&hellip; ;&ndash;).</p>

<p>Bien sûr, il est existe bien d'autres solutions mais je te laisse, précieux lecteur, le soin de les évaluer ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Démarrer une webapp en mode embedded avec Maven]]></title>
    <link href="http://blog.jetoile.fr/2013/03/demarrer-une-webapp-en-mode-embedded.html"/>
    <updated>2013-03-06T15:26:29+01:00</updated>
    <id>http://blog.jetoile.fr/2013/03/demarrer-une-webapp-en-mode-embedded</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-2c2Ie9Tla54/UTaEjXrNaiI/AAAAAAAAA20/MWhTcyyJvMg/s1600/image.png" alt="left-small" /></p>

<p>La mouvance actuelle dit que tout projet qui se veut un minimum industrialisé doit pouvoir détecter les anomalies au plus tôt. Pour ce faire, il est dit qu'il doit disposer de tests, qu'ils soient unitaire, d'intégration, fonctionnel ou d'acceptance.</p>

<p> Pour adresser le problème des tests d'intégration, il est souvent utile de démarrer l'application cible de manière embedded.</p>

<p>Cette article montrera comment il est possible de faire pour un contexte donné.</p>

<p>En outre, vu que ce blog me sert également d'aide mémoire, cela me donnera une excuse pour marquer noir sur blanc des informations que je peine toujours à retrouver&hellip; ;&ndash;)</p>

<p>Pour les habitués de ce blog (oui, je sais, cela fait un moment que je n'ai rien écrit&hellip; ;&ndash;) , le plan sera toujours le même : dans un premier temps, le contexte sera décrit puis des ébauches de solutions seront proposées jusqu'à tendre vers celle qui a été retenue.</p>

<!-- more -->


<h1>Contexte</h1>

<p>Le contexte du projet est le suivant : l'application cible est composée de deux applications web qui suivent le même cycle de vie et qui sont dépendantes l'une de l'autre (au sens <em>runtime</em> en non compilation).</p>

<p>En effet, elle dispose d'une application web proposant un site web écrit en Java et utilisant un framework de type struts 2 (et qui sera nommée par la suite &ldquo;<em>application webapp</em>&rdquo;) et une application web servant un ensemble de ressources en proposant une interface REST (nommée par la suite &ldquo;<em>application rest</em>&rdquo;).</p>

<p>L'application webapp nécessitera, en plus de son rendu de page dynamique, des ressources offertes par l'application REST (appel ajax, &hellip;).</p>

<p><em>ndlr</em> : je sais que la mouvance actuelle dit que les framework web java sont le &ldquo;mal&rdquo; pour faire du web et qu'il est préférable de tendre vers une solution type framework javascript coté client. Cependant, dans notre cas, une forte contrainte SEO faisait qu'il était nécessaire de &ldquo;conserver&rdquo; un rendu dynamique des pages cotés serveur.</p>

<p>D'un point de vu technique, le projet s'appuiera sur Maven 3 (encore lui&hellip; ;&ndash;) ), et sur des technologies standards à base de Servlets (2.5+), de JSP, de JAX-RS, &hellip; enfin, de techno standard capable de tourner sur un conteneur de Servlet classique type Tomcat 6 ou 7.</p>

<p>L'arborescence du projet est la suivante :</p>

<p><img src="http://4.bp.blogspot.com/-1N_8WSbysb8/UTZKH2xIekI/AAAAAAAAA2c/itx2Qxav2CA/s1600/tree01.png" alt="center" /></p>

<p>Avant de commencer à rentrer dans le vif du sujet, il est important de remarquer qu'il existe de nombreux plugins Maven permettant de démarrer de manière <em>embedded</em> un artifact maven de type war via les goals adéquates (<code>mvn tomcat7:run</code>, <code>mvn jetty:run</code>, &hellip;). Cependant, pour rappel, notre objectif est de démarrer de manière conjointe nos deux applications web.</p>

<p>En outre, le but ultime (pour ceux qui ne l'auraient pas encore deviné ;&ndash;) ) étant d'exécuter de manière boite noire des tests d'integration/d'acceptance, le démarrage devra se faire dans un module Maven frère de nos deux modules webapp et restful.</p>

<p>L'arborescence attendue du projet est donc la suivante :</p>

<p><img src="http://2.bp.blogspot.com/-QYIOY3HI__s/UTZKLlWV1bI/AAAAAAAAA2k/HXtJ0QDW6BE/s1600/tree02.png" alt="center" /></p>

<p>Enfin, pour finir le tour de notre petit cahier des charges, le livrable généré ne devra pas dépendre de profils Maven particuliés (le but étant, bien sûr, de ne pas avoir un livrable dépendant d'une configuration donnée).</p>

<p>Cependant, afin d'avoir la main, lors des tests d'intégration/d'acceptance, sur le jeu de données qui sera injecté dans le système à tester, il devra être possible de modifier &ldquo;à chaud&rdquo; certaines configurations. Pour ce faire, une surcharge des fichiers de configuration des applications devra être faite.</p>

<p><em>ndlr</em> : l'application ayant un certain existant, elle ne dispose pas de fonctionnalités comme les <strong>Profile</strong> Spring ou l'utilisation de variables systèmes : toutes les propriétés de configuration se trouvent donc dans des fichiers properties ou dans des fichiers de contexte Spring.</p>

<h1>Le plugin tomcat 7</h1>

<p><img src="http://2.bp.blogspot.com/-vO0vp3GQG_4/UTbgJFKXJ5I/AAAAAAAAA3E/Z8EtqhZbPJU/s1600/tomcat.gif" alt="center" /></p>

<h2>Mise en oeuvre</h2>

<p>Le plugin <a href="http://tomcat.apache.org/maven-plugin-2.0/index.html">Maven Tomcat 7</a> est un plugin que j'apprécie pour sa simplicité d'utilisation et ses différentes <em>features</em> (merci <a href="https://twitter.com/olamy">@olamy</a> pour me l'avoir fait découvrir/redécouvrir ;&ndash;) ) et c'est donc naturellement que c'est le premier qui a été testé. De plus, la cible de déploiement étant Tomcat, cela tombait bien ;&ndash;) .</p>

<p>Pour répondre à notre cas d'usage, le plugin Tomcat 7 propose le goal <code>run-war-only</code> qui permet, via la configuration <code>&lt;warDirectory&gt;</code>, de préciser un répertoire où se trouve l'application web.</p>

<p>En effet, le war étant généré dans un module maven frère de celui où doit être démarré le Tomcat <em>embedded</em>, il doit, préalablement, être récupéré (en évitant, bien évidemment, les chemins relatifs). En outre, pour rappel, la nécessité de surcharger la configuration de certains fichiers à fait tendre la solution vers les étapes suivantes (opération spécifique à une application web) :</p>

<ul>
<li>récupération du war dans le repository maven,</li>
<li>dézippage du war dans le répertoire <code>target/webapp</code>,</li>
<li>copie des fichiers de configuration permettant la surcharge des fichiers de configuration de l'application dans le répertoire <code>target/webapp/WEB-INF/classes</code>,</li>
<li>un appel au goal <code>run-war-only</code> du plugin Tomcat en précisant l'emplacement du war éclaté à charger.</li>
</ul>


<p>Cela a été fait via la configuration Maven suivante :</p>

<p>```xml
<plugin>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <id>unzip-webapp</id>
            <phase>compile</phase>
            <goals>
                <goal>unpack</goal>
            </goals>
            <configuration>
                <artifactItems>
                     <artifactItem>
                         <groupId>${project.groupId}</groupId>
                         <artifactId>webapp</artifactId>
                         <version>${project.version}</version>
                         <type>war</type>
                     </artifactItem>
                </artifactItems>
 
                <outputDirectory>${project.build.directory}/webapp</outputDirectory>
                <overWriteSnapshots>true</overWriteSnapshots>
            </configuration>
        </execution>
    </executions>
</plugin>
 </p>

<!--use to copy test resources into webapp classpath-->


<p><plugin>
    <artifactId>maven-resources-plugin</artifactId>
    <executions>
        <execution>
            <id>copy-webapp-resources</id>
            <phase>process-test-resources</phase>
            <goals>
                <goal>copy-resources</goal>
            </goals>
            <configuration>
                <outputDirectory>${project.build.directory}/webapp/WEB-INF/classes</outputDirectory>
                <resources>
      <resource>
          <directory>src/test/resources/webapp</directory>
          <filtering>true</filtering>
      </resource>
                </resources>
            </configuration>
        </execution>
    </executions>
</plugin>
 
<plugin>
    <groupId>org.apache.tomcat.maven</groupId>
    <artifactId>tomcat7-maven-plugin</artifactId>
    <version>2.0</version>
 
    <executions>
        <execution>
            <id>tomcat-war-exec</id>
            <goals>
                <goal>run-war-only</goal>
            </goals>
            <phase>pre-integration-test</phase>
            <configuration>
                <warDirectory>${project.build.directory}/webapp/</warDirectory>
                <fork>true</fork>
                <ignorePackaging>true</ignorePackaging>
                <contextFile>src/test/resources/webapp/context.xml</contextFile>
            </configuration>
        </execution>
        <execution>
            <id>start-tomcat</id>
            <phase>pre-integration-test</phase>
            <goals>
                <goal>run</goal>
            </goals>
            <configuration>
            </configuration>
        </execution>
        <execution>
            <id>stop-tomcat</id>
            <phase>post-integration-test</phase>
            <goals>
                <goal>shutdown</goal>
            </goals>
        </execution>
    </executions>
 
    <configuration>
        <port>9090</port>
        <path>/</path>
    </configuration>
 
    <dependencies>
        <!-- les artéfacts des jars à mettre dans le classpath du serveur Tomcat tels que les drivers de connexion-->
    </dependencies>
</plugin>
```</p>

<p>Il est intéressant de noter plusieurs points :</p>

<ul>
<li>la précision du fichier <code>context.xml</code> qui contient, entre autre, le <strong>contextName</strong> de l'application web mais surtout, dans notre cas, la déclaration de notre base de données dans l'annuaire JNDI,</li>
<li>le rajout éventuel de jar dans le classpath serveur,</li>
<li>le fait de lancer le serveur en phase de <code>pre-integration-test</code> et de l'éteindre en phase de <code>post-integration-test</code>.</li>
</ul>


<p>Cependant, pour ceux qui auraient suivi, je rappelle que l'application cible était composée de deux applications web : webapp et restful&hellip;</p>

<p>Malheureusement, sauf erreur de ma part, le plugin Maven Tomcat7 ne propose pas de déployer deux applications web simultanément lorsque ces dernières sont éclatées dans un répertoire.</p>

<h2>Conclusion</h2>

<p>On a vu dans ce paragraphe comment il était possible de déployer simplement, via le plugin Maven Tomcat 7, une application web de manière <em>embedded</em> dans un processus Maven.</p>

<p>Malheureusement, le goal qui nous intéressait ne permettant pas démarrer deux applications web simultanément, il n'a pas pu répondre à notre besoin.</p>

<h1>Le plugin Jetty</h1>

<p><img src="http://3.bp.blogspot.com/-9CX6HuFGgPA/UTbgPT2O6gI/AAAAAAAAA3M/JQ_lOt2NnsI/s1600/jetty_logo.png" alt="center" /></p>

<h2>Mise en oeuvre</h2>

<p>Dans cette deuxième tentative, c'est le <a href="http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin">plugin Maven Jetty</a> qui a été utilisé.</p>

<p>Même s'il n'est pas la cible de déploiement, nos applications étant assez standards, il a été acté que le conteneur n'aurait que peu d'impacts sur les tests d'intégration/d'acceptance.</p>

<p>La philosophie mise en oeuvre est similaire à celle choisie avec le plugin Maven Tomcat 7, à savoir :</p>

<ul>
<li>récupération du war dans le repository maven,</li>
<li>dézippage du war dans le répertoire <code>target/webapp</code>,</li>
<li>copie des fichiers de configuration dans le répertoire <code>target/webapp/WEB-INF/classes</code>,</li>
<li>appel du bon goal du plugin Jetty en précisant l'emplacement du war éclaté à charger.</li>
</ul>


<p>Bien sûr, ici, le goal est propre au plugin Jetty, à savoir <code>run-exploded</code> :</p>

<p><code>xml
&lt;plugin&gt;
    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
    &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;7.6.9.v20130131&lt;/version&gt;    
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;jetty-war-exec&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;run-exploded&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;pre-integration-test&lt;/phase&gt;
            &lt;configuration&gt;
                &lt;daemon&gt;true&lt;/daemon&gt;            
                &lt;jvmArgs&gt;&lt;!-- eventuellement les options jvm--&gt;&lt;/jvmArgs&gt;
                &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;
                &lt;jettyConfig&gt;${basedir}/src/test/resources/jetty.xml&lt;/jettyConfig&gt;
                &lt;webAppConfig&gt;
                   &lt;contextPath&gt;/webapp&lt;/contextPath&gt;
                   &lt;jettyEnvXml&gt;${basedir}/src/test/resources/webapp/jetty-webapp-context.xml&lt;/jettyEnvXml&gt;
                &lt;/webAppConfig&gt;
                &lt;war&gt;${project.build.directory}/webapp&lt;/war&gt;
                &lt;connectors&gt;
                   &lt;connector implementation="org.eclipse.jetty.server.nio.SelectChannelConnector"&gt;
                       &lt;host&gt;127.0.0.1&lt;/host&gt;
                       &lt;port&gt;9090&lt;/port&gt;
                   &lt;/connector&gt;
                &lt;/connectors&gt;
 
                &lt;contextHandlers&gt;
                   &lt;contextHandler implementation="org.eclipse.jetty.webapp.WebAppContext"&gt;
                       &lt;war&gt;${project.build.directory}/restful&lt;/war&gt;
                       &lt;contextPath&gt;/restful&lt;/contextPath&gt;
                   &lt;/contextHandler&gt;
                &lt;/contextHandlers&gt;
 
            &lt;/configuration&gt;
        &lt;/execution&gt;
 
        &lt;execution&gt;
            &lt;id&gt;stop-jetty&lt;/id&gt;
            &lt;phase&gt;post-integration-test&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;stop&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;stopPort&gt;9999&lt;/stopPort&gt;
                &lt;stopKey&gt;stopKey&lt;/stopKey&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
 
    &lt;/executions&gt;
    &lt;dependencies&gt;
        &lt;!-- eventuellement les jar à ajouter au classpath du conteneur de servlet--&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</code></p>

<p>On peut remarquer que la configuration du plugin Jetty est beaucoup plus verbeuse que celle du plugin Tomcat avec, notamment, la nécessité de préciser :</p>

<ul>
<li>un fichier de configuration jetty permettant, dans notre cas, de préciser que Jetty doit démarrer son module pour charger l'annuaire JNDI (fichier <code>jetty.xml</code>),</li>
<li>la déclaration d'un connecteur pour pouvoir préciser le port de lancement du conteneur de Servlet,</li>
<li>le fichier <code>jetty-webapp-context.xml</code> pendant du <code>context.xml</code> de Tomcat,</li>
<li>l'obligation de rajouter l'élément <code>contextHandlers</code> pour pouvoir déclarer la deuxième application web à démarrer.</li>
</ul>


<p>A noter qu'il est également possible de déclarer les deux applications web via des <strong>contextHandler</strong>, permettant d'avoir une configuration plus symétrique :</p>

<p><code>xml
&lt;plugin&gt;
    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
    &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;7.6.9.v20130131&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;jetty-war-exec&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;start&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;pre-integration-test&lt;/phase&gt;
            &lt;configuration&gt;
                &lt;daemon&gt;true&lt;/daemon&gt;
                &lt;jvmArgs&gt;&lt;/jvmArgs&gt;
                &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;
                &lt;jettyConfig&gt;${basedir}/src/test/resources/jetty.xml&lt;/jettyConfig&gt;
                &lt;webAppConfig&gt;
                     &lt;jettyEnvXml&gt;${basedir}/src/test/resources/webapp/jetty-webapp-context.xml&lt;/jettyEnvXml&gt;
                &lt;/webAppConfig&gt;
                &lt;connectors&gt;
                     &lt;connector implementation="org.eclipse.jetty.server.nio.SelectChannelConnector"&gt;
                         &lt;host&gt;127.0.0.1&lt;/host&gt;
                         &lt;port&gt;9090&lt;/port&gt;
                     &lt;/connector&gt;
                &lt;/connectors&gt;
 
                &lt;contextHandlers&gt;
                     &lt;contextHandler implementation="org.eclipse.jetty.webapp.WebAppContext"&gt;
                         &lt;war&gt;${project.build.directory}/webapp&lt;/war&gt;
                         &lt;contextPath&gt;/webapp&lt;/contextPath&gt;
                     &lt;/contextHandler&gt;
 
                     &lt;contextHandler implementation="org.eclipse.jetty.webapp.WebAppContext"&gt;
                         &lt;war&gt;${project.build.directory}/restful&lt;/war&gt;
                         &lt;contextPath&gt;/restful&lt;/contextPath&gt;
                     &lt;/contextHandler&gt;
                &lt;/contextHandlers&gt;
 
            &lt;/configuration&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
            &lt;id&gt;stop-jetty&lt;/id&gt;
            &lt;phase&gt;post-integration-test&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;stop&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;stopPort&gt;9999&lt;/stopPort&gt;
                &lt;stopKey&gt;stopKey&lt;/stopKey&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
 
 
    &lt;/executions&gt;
    &lt;dependencies&gt;
         
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</code></p>

<p>A titre informatif, le fichier <code>jetty.xml</code> permettant de charger le module JNDI est le suivant :</p>

<p><code>xml
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure.dtd"&gt;
 
 
&lt;Configure id="Server" class="org.eclipse.jetty.server.Server"&gt;
    &lt;Array id="plusConfig" type="java.lang.String"&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.WebInfConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.WebXmlConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.MetaInfConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.FragmentConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.plus.webapp.EnvConfiguration&lt;/Item&gt;                  &lt;!-- add for JNDI --&gt;
        &lt;Item&gt;org.eclipse.jetty.plus.webapp.PlusConfiguration&lt;/Item&gt;                 &lt;!-- add for JNDI --&gt;
        &lt;Item&gt;org.eclipse.jetty.annotations.AnnotationConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.JettyWebXmlConfiguration&lt;/Item&gt;
        &lt;Item&gt;org.eclipse.jetty.webapp.TagLibConfiguration&lt;/Item&gt;
    &lt;/Array&gt;
 
    &lt;Call name="setAttribute"&gt;
        &lt;Arg&gt;org.eclipse.jetty.webapp.configuration&lt;/Arg&gt;
        &lt;Arg&gt;
            &lt;Ref id="plusConfig"/&gt;
        &lt;/Arg&gt;
    &lt;/Call&gt;
&lt;/Configure&gt;
</code></p>

<p>et le fichier <code>jetty-webapp-context.xml</code> pendant du fichier <code>context.xml</code> de Tomcat est :</p>

<p><code>xml
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure.dtd"&gt;
 
&lt;Configure class="org.eclipse.jetty.webapp.WebAppContext"&gt;
 
&lt;New id="myoracle" class="org.eclipse.jetty.plus.jndi.Resource"&gt;
    &lt;Arg&gt;jdbc/myoracle&lt;/Arg&gt;
    &lt;Arg&gt;
        &lt;New class="org.apache.commons.dbcp.BasicDataSource"&gt;
            &lt;Set name="driverClassName"&gt;driver.jdbc.class&lt;/Set&gt;
            &lt;Set name="url"&gt;jdbc:url_connection&lt;/Set&gt;
            &lt;Set name="username"&gt;login&lt;/Set&gt;
            &lt;Set name="password"&gt;password&lt;/Set&gt;
        &lt;/New&gt;
    &lt;/Arg&gt;
&lt;/New&gt;
 
&lt;/Configure&gt;
</code></p>

<h2>Conclusion</h2>

<p>On a pu constater que l'utilisation du plugin Maven Jetty a parfaitement répondu à notre petit cahier des charges. C'est vrai que cela peut sembler un peu poussif mais cela est surtout dû au fonctionnement même de Jetty.</p>

<p>Enfin, il est à noter que la configuration présentée dans le paragraphe précédent ne fonctionne pas pour la version 6 du plugin (connecteurs et packages différents, &hellip;) et qu'elle a été testé avec la version 7.6.9.v20130131. Normalement, cela devrait fonctionner avec la version 8 mais n'ayant pas testé, je ne pourrais pas le certifier&hellip;</p>

<h1>Conclusion</h1>

<p>En conclusion, cet article avait pour objectif de présenter quelques-unes des façons de démarrer de manière <em>embedded</em> des applications web dans des conteneurs de Servlet légés au sein d'un processus Maven.</p>

<p>Cela peut, notamment, être utile pour initialiser une ou plusieurs applications au sein du processus de tests pour, par exemple, exécuter de manière automatisée des tests d'intégration ou d'acceptance, chose qui est de plus en plus courante au sein de nos usine d'intégration continue.</p>

<p>Bien sûr, il existe de nombreuses autres solutions (par exemple, <a href="http://arquillian.org/">Arquillian</a>) mais aussi d'autres approches (le choix retenu ici a été celui de la boite noire) qui ont toutes leurs avantages et leurs inconvénients par rapport à un besoin donné.</p>
]]></content>
  </entry>
  
</feed>
