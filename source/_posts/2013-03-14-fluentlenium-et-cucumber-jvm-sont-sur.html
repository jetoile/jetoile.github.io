---
layout: post
title: "FluentLenium et Cucumber JVM sont sur un bateau..."
date: 2013-03-14
comments: false
categories:
 - java
 - intégration continue
 - fluentLenium
 - test
 - selenium
 - maven
---

<div class='post'>
<div style="text-align: justify;"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-R3ORi15Ei3Y/UTmwoq5A2II/AAAAAAAAA3o/uaIMSSZlq38/s1600/logo.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="209" src="http://4.bp.blogspot.com/-R3ORi15Ei3Y/UTmwoq5A2II/AAAAAAAAA3o/uaIMSSZlq38/s320/logo.png" width="320" /></a></div>Dans un <a href="http://blog.jetoile.fr/2013/03/demarrer-une-webapp-en-mode-embedded.html">article précédent</a>, j'avais abordé comment il était possible de démarrer une application web dans un conteneur de Servlet de manière embedded au sein de la phase integration de Maven. Bien sûr, cela n'a pas été fait que pour l'exercice de style et il y avait une petite idée derrière : pouvoir exécuter des tests d'acceptance en mode boite noire sur l'application.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour faire les tests d'acceptance, le choix de Cucumber JVM a été fait afin de permettre l'expression de tests d'acceptance avec une sémantique utilisant le pattern Given/When/Then mais également afin de permettre à des non développeurs de comprendre/écrire les scénarii de test à exécuter.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">L'application à tester étant une application web, un besoin s'est fait sentir de tester la partie rendue. Dans cet article, lorsque l'on parlera de tester la partie rendue, il sera question de vérifier que l'élément recherché se trouve bien dans le document html remonté dans le navigateur web. Pour rappel (cf. le paragraphe Contexte de ce <a href="http://blog.jetoile.fr/2013/03/demarrer-une-webapp-en-mode-embedded.html">post</a>), l'application testée s'appuie sur un framework web java de type Struts2.</div><div style="text-align: justify;">Aussi, il ne sera pas question, ici, de tester le rendu dans différents navigateurs.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il a été décidé de partir sur une solution s'appuyant sur un runtime à base de Selenium : en effet, un besoin latent étant, à terme, de tester le rendu de l'application web sur les différents navigateurs, cette solution semblait correspondre le mieux aux besoins. </div><div style="text-align: justify;">Bref, passons ce besoin pour revenir à notre objectif premier, à savoir, vérifier la présence des éléments dans l'arbre DOM remonté par l'application web.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour résumer, il a été décidé de partir sur : </div><ul><li style="text-align: justify;">Cucumber JVM pour la partie représentation/écriture des scénarii,</li><li style="text-align: justify;">Selenium pour la partie exécution des tests.</li></ul><div style="text-align: justify;">Cependant, la syntaxe sur la partie WebDriver de Selenium 2 étant assez verbeuse, il a été décidé d'utiliser le framework FluentLenium qui offre une API plus simple et plus naturelle (enfin plus fluent quoi! ;-) ). En outre, en plus d'une API plus facile d'utilisation, la notion native de Page de FluentLenium poussant à mieux découpler la représentation d'une page et son test, cela a joué en sa faveur ;-)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, cet article présentera comment il a été possible d'intégrer Cucumber JVM avec FluentLenium afin de pouvoir faire tourner des tests avec Selenium.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A noter que je ne m'attarderai pas, dans cet article, à présenter exhaustivement les différents protagonistes mais seulement les quelques points qu'il est nécessaires de connaitre afin d'intégrer ensemble ces différents framework.<br /><br /><b>[update]</b>&nbsp;Suite à discussion avec la créatrice de FluentLenium, un autre article a été initié et apporte de nombreux compléments mais également correction à cet article. Pour en savoir, plus, rendez vous <a href="http://blog.jetoile.fr/2013/04/fluentlenium-et-cucumber-jvm-complement.html">ici</a>...<br /><br /><!-- more --></div><h1>Présentation des protagonistes</h1><h2>Cucumber JVM</h2><div style="text-align: justify;"><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-vb7zd_BqITk/UTmwyd4yWsI/AAAAAAAAA3w/tYVxH4hxlig/s1600/cucumber2.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://2.bp.blogspot.com/-vb7zd_BqITk/UTmwyd4yWsI/AAAAAAAAA3w/tYVxH4hxlig/s200/cucumber2.jpg" width="200" /></a></div><br /><a href="https://github.com/cucumber/cucumber-jvm">Cucumber JVM</a> est un fork Java de <a href="http://cukes.info/">Cucumber</a> inialement développé en Ruby. </div><div style="text-align: justify;">Tout comme <a href="http://jbehave.org/">JBehave</a>, il est orienté BDD (<i>Behaviour Driven Development</i>) et il permet d'écrire ses <b>scénarii</b> de tests en suivant le pattern <a href="https://github.com/cucumber/cucumber/wiki/Given-when-then">Given/When/Then</a> qui correspond à déterminer un ensemble de <a href="https://github.com/cucumber/cucumber/wiki/Step-Definitions"><b>Step</b></a>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ces scénarii s'écrivent dans des fichiers <b>features</b> qui sont lus par Cucumber JVM. Ce dernier se charge alors de faire correspondre les <b>Steps</b> avec les fixtures associés. Ces <b>steps</b> sont des méthodes Java annotées par : </div><ul><li style="text-align: justify;">@Given(value = "")</li><li style="text-align: justify;">@When(value = "")</li><li style="text-align: justify;">@Then(value = "")</li></ul><div style="text-align: justify;">A noter que seule la valeur de l'annotation est utilisée par Cucumber JVM.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Alors que les steps à la sémantique Given permettront de poser les conditions nécessaires à l'exécution du scénario, les steps When exécuteront l'action à tester et les steps Then testeront que tout s'est bien passé en utilisant le framework d'assertion de son choix tels que JUnit, Fest-assert et/ou Harmcrest.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A noter également que pour passer un état d'une Step à une autre, Cucumber JVM nous oblige à stocker ces derniers dans des variables de classe ou à passer par son mécanisme d'injection à l'aide de framework IoC tels que&nbsp;<a href="http://picocontainer.codehaus.org/">Picocontainer</a>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, on peut résumer grossièrement en disant qu'un scénario est écrit dans un fichier <b>feature</b> et est composé d'un ensemble de <b>Step</b> qui sont associés à des méthodes qui correspondent aux différentes <b>fixtures</b>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pour plus d'informations sur le BDD, je vous renvoie sur un <a href="http://blog.soat.fr/2011/06/breizhcamp-behaviour-driven-development-par-olivier-billard-et-thierry-henrio/">compte rendu</a> d'une présentation d'Olivier Billard et de Thierry Henrio réalisé au BreizhCamp que j'avais fait à l'époque. </div><h2>Selenium 2</h2><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-xOJkyRycXEU/UTmxGd1a-nI/AAAAAAAAA4A/kMPuTOc5tpY/s1600/big-logo.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="180" src="http://4.bp.blogspot.com/-xOJkyRycXEU/UTmxGd1a-nI/AAAAAAAAA4A/kMPuTOc5tpY/s200/big-logo.png" width="200" /></a></div><div><br /></div><div style="text-align: justify;">Dans notre cas d'usage, il y a assez peu de chose à dire sur <a href="http://docs.seleniumhq.org/">Selenium</a> si ce n'est qu'il permet, en fournissant différents <b>WebDriver</b>, de tester le rendu d'une page HTML en simulant différentes actions telles que le <i>submit</i> de formulaires, le clique d'un bouton et en allant chercher différents éléments dans la page rendue. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il propose différentes implémentations de WebDriver tels que <b>FirefoxDriver</b> ou <b>HtmlUnitDriver</b>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Selenium offre également la possibilité d'exécuter les navigateurs qu'il lance sur différentes machines via Selenium Server mais, dans notre cas, cette fonctionnalité ne sera pas utile. De même, il ne sera pas abordé la partie Selenium IDE qui est peu exploitable car difficilement maintenable. En effet, il est courant et même fortement recommandé de séparer, pour des raisons évidentes, les scénarii à tester du rendu de la page (par exemple en utilisant le <a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a>).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Les liens suivants détaillent plus précisément ces différents points : </div><ul><li><a href="http://fr.slideshare.net/MathildeLemee/selenium-testng-selenium-grid-best-practices">http://fr.slideshare.net/MathildeLemee/selenium-testng-selenium-grid-best-practices</a></li><li><a href="http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-api-commands-and-operations">http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-api-commands-and-operations</a></li></ul><h2>FluentLenium</h2><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-fyH1CNEBvIw/UTmxNk5WZTI/AAAAAAAAA4I/obgbEW5Ae6w/s1600/code.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="130" src="http://1.bp.blogspot.com/-fyH1CNEBvIw/UTmxNk5WZTI/AAAAAAAAA4I/obgbEW5Ae6w/s200/code.png" width="200" /></a></div><div><br /></div><div style="text-align: justify;"><a href="https://github.com/FluentLenium/FluentLenium">FluentLenium</a> est un framework utilisant Selenium mais proposant une API plus simple et plus naturelle que celle offerte par ce dernier. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il a été pensé pour s'intégrer à des tests exécutés avec JUnit ou TestNG et se charge donc d'initialiser le <b>WebDriver</b> Selenium à chaque fois qu'il exécute un test.</div><div style="text-align: justify;">Pour ce faire, il utilise, au moment de l'écriture de ces lignes, le mécanisme de <b>Rule</b> JUnit qui fait, grosso modo, comme le @Before de JUnit mais qui peut être partagé entre les différentes classes de test.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En outre, FluentLenium s'appuie sur la notion de <b>FluentPage</b> et de <b>FluentTest</b>. En fait, pour faire simple, les classes de tests doivent étendre FluentTest, ce qui permet à toutes les méthodes annotées par @Test d'initialiser le WebDriver Selenium. La classe peut, de plus, bénéficier des méthodes portées par FluentTest.</div><div style="text-align: justify;">La notion de FluentPage permet, quant à elle, de représenter une page (au sens HTML). Cette implémentation du <i><a href="http://docs.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern">Page Object Design Pattern</a></i>&nbsp;incite&nbsp;ainsi l'utilisateur à découpler le test du contenu de la page qui sera alors la seule à être garante du rendu.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Enfin, via l'annotation <b>Page</b>, les classes qui étendent FluentPage peuvent être injectées directement dans l'implémentation du FluentTest. Les liens suivants détaillent plus précisément ces différents points : </div><ul><li><a href="http://fr.slideshare.net/MathildeLemee/fluentlenium">http://fr.slideshare.net/MathildeLemee/fluentlenium</a></li><li><a href="https://github.com/FluentLenium/FluentLenium">https://github.com/FluentLenium/FluentLenium</a></li></ul><h1>Etude sur la mise en oeuvre</h1><div style="text-align: justify;">On a vu dans le paragraphe précédent quelques-unes des notions nécessaires à l'intégration de nos trois comparses.</div><div style="text-align: justify;">Cependant, il est intéressant de noter que Cucumber JVM et FluentLenium s'appuient sur deux paradigmes potentiellement opposés. En effet, alors que Cucumber JVM dispose d'une représentation par Step formalisé par des méthodes java, FluentLenium propose une granularité par méthode.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En outre, deux points sont primordiaux : </div><ul><li style="text-align: justify;">FluentLenium s'appuie sur la notion de Rule JUnit pour instancier, démarrer puis stopper le webDriver,</li><li style="text-align: justify;">Cucumber JVM ne supporte pas la <a href="https://github.com/cucumber/cucumber-jvm/issues/393">notion de Rule</a> et refuse tout autre Runner différent que le sien.</li></ul><div style="text-align: justify;">Bien sûr, on peut se douter qu'il est possible de contourner le problème sinon cet article serait un peu mensongé... ;-)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En fait, la solution qui a été mise en place pour faire fonctionner conjointement ces deux framework est assez simple : faire que les classes déclarant les <b>Steps</b> Cucumber JVM délèguent à une classe étendant FluentTest les différentes actions et vérifications.</div><div style="text-align: justify;"><strike><br /></strike></div><div style="text-align: justify;">Cette classe pourra porter les différentes pages (au sens FluentLenium) et devra exposer les méthodes adéquates qui initialiseront et arrêteront le webDriver cible (méthodes fournies par FluentTest). <br /><br /></div><div style="text-align: justify;">A titre informatif, le fait d'utiliser l'<i>Autocloseable</i> (et plus précisément le <i>try-with-resources</i>) de Java 7 s'est traduit par un échec puisque le driver doit rester actif entre les différentes Steps.<br />De même, essayer d'injecter via Picocontainer les pages ne fonctionne pas car, à ce jour, l'implémentation même de FluentLenium fait que les annotations @Page qui permettent d'initialiser et d'instancier les <b>FluentPages</b> doivent être dans une implémentation de <b>FluentTest</b>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, cela pourrait se traduire par le code suivant :&nbsp;</div><div style="text-align: justify;"><br /></div><b>HomePageStep.java</b><br /><pre class="brush:java; wrap-lines: false; auto-links: false">import cucumber.api.java.en.Then;<br />import cucumber.api.java.en.When;<br />import org.fest.assertions.fluentlenium.FluentLeniumAssertions;<br /><br />public class HomePageStep {<br /><br />    private FluentTestDelegator fluentLeniumDelegate;<br /><br />    /**<br />     * injection par pico donc pas besoin d'initialiser le driver (deja fait par le delegator)<br />     * @param fluentLeniumDelegate<br />     */<br />    public HomePageStep(FluentTestDelegator fluentLeniumDelegate) {<br />        this.fluentLeniumDelegate = fluentLeniumDelegate;<br />    }<br /><br />    @When(value = "I go on home page")<br />    public void homePageIsDisplayed() {<br />            fluentLeniumDelegate.goTo(fluentLeniumDelegate.homePage).await().untilPage();<br />    }<br /><br />    @Then(value = "home page is displayed")<br />    public void homePageIsDisplayed() {<br />        FluentLeniumAssertions.assertThat(fluentLeniumDelegate.homePage).isAt();<br />    }<br /><br />    @When(value = "I submit the form")<br />    public void submitForm() {<br />        fluentLeniumDelegate.homePage.submit();<br />    }<br />}<br /></pre><br /><br /><b>ResultPageStep.java</b><br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class ResultPageStep {<br /><br />    private FluentTestDelegator fluentLeniumDelegate;<br /><br />    /**<br />     * injection par pico donc pas besoin d'initialiser le driver (deja fait par le delegator)<br />     * @param fluentLeniumDelegate<br />     */<br />    public ResultPageStep(FluentTestDelegator fluentLeniumDelegate) {<br />        this.fluentLeniumDelegate = fluentLeniumDelegate;<br />    }<br /><br />    @Then(value = "I am on result page")<br />    public void isOnPage() {<br />        FluentLeniumAssertions.assertThat(fluentLeniumDelegate.resultPage).isAt();<br />    }<br />}<br /></pre><br /><br /><b>CommonStep.java</b><br /><pre class="brush:java; wrap-lines: false; auto-links: false">import cucumber.api.java.en.When;<br /><br />public class CommonStep {<br /><br />    private FluentTestDelegator fluentLeniumDelegate;<br /><br />    public StepHelper(FluentTestDelegator fluentLeniumDelegate) {<br />        this.fluentLeniumDelegate = fluentLeniumDelegate;<br />    }<br /><br />    @When(value = "I stop my driver")<br />    public void webDrivercloser() {<br />        fluentLeniumDelegate.close();<br />    }<br />}<br /><br /></pre><br /><br /><b>FluentTestDelegator.java</b><br /><pre class="brush:java; wrap-lines: false; auto-links: false">import cucumber.api.java.en.When;<br />import org.fluentlenium.adapter.FluentTest;<br />import org.fluentlenium.core.annotation.Page;<br />import org.openqa.selenium.WebDriver;<br />import org.openqa.selenium.htmlunit.HtmlUnitDriver;<br />import org.openqa.selenium.remote.DesiredCapabilities;<br /><br />import java.io.File;<br />import java.io.IOException;<br /><br />public class FluentTestDelegator extends FluentTest implements AutoCloseable {<br />    @Page<br />    public HomePage homePage;<br /><br />    @Page<br />    public ResultPage resultPage;<br /><br />    public FluentTestDelegator() throws IOException {<br />        init();<br />    }<br /><br />    /**<br />    * Appel des operations faites par le Rule Junit de FluentTest<br />    */<br />    public void init() throws IOException {<br />        initFluent(new HtmlUnitDriver()).withDefaultUrl("http://localhost:9090");<br />//        initFluent(getDefaultDriver()).withDefaultUrl("http://localhost:9090");<br />        initTest();<br />        setDefaultConfig();<br />    }<br /><br />    @Override<br />    public void close() {<br />        if (getDriver() != null) {<br />            quit();<br />        }<br />    }<br />} <br /></pre><br /><br /><b>HomePage.jave</b><br /><pre class="brush:java; wrap-lines: false; auto-links: false">import cucumber.api.DataTable;<br />import org.fluentlenium.core.FluentPage;<br />import org.fluentlenium.core.domain.FluentList;<br />import org.fluentlenium.core.domain.FluentWebElement;<br /><br />import java.util.List;<br /><br />import static org.fest.assertions.Assertions.assertThat;<br />import static org.fluentlenium.core.filter.FilterConstructor.withText;<br />import static org.junit.Assert.assertEquals;<br /><br />public class HomePage extends FluentPage {<br /><br />    @Override<br />    public String getUrl() {<br />        return "/webapp/home";<br />    }<br /><br />    @Override<br />    public void isAt() {<br />        assertThat(title()).containsIgnoringCase("homePage");<br />    }<br /><br />    public void submit() {<br />        submit("#searchForm &gt; form").await().untilPage();<br />    }<br />}<br /></pre><br /><br /><b>ResultPage.jave</b>  <br /><pre class="brush:java; wrap-lines: false; auto-links: false">public class ResultPage extends FluentPage {<br /><br />    @Override<br />    public String getUrl() {<br />        return "/webapp/result";<br />    }<br /><br />    @Override<br />    public void isAt() {<br />        assertThat(title()).containsIgnoringCase("resultPage");<br />    }<br />}<br /></pre><br /><br /><b>scenario1.feature</b><br /><pre class="brush:text; wrap-lines: false; auto-links: false"># encoding: iso-8859-1<br /><br />Feature: homepage test<br /><br />  Scenario: homePage should be displayed<br />    When I go on home page<br />    Then home page is displayed<br />    Then I stop my driver<br />  <br />  Scenario: a submit on homePage should redirect to resultPage<br />    When I go on home page<br />    And I submit the form<br />    Then I am on result page<br />    Then I stop my driver<br /></pre><br /><br /><div style="text-align: justify;">On constate que le code est un peu plus verbeux que ce qu'on aurait souhaité avoir mais cela fonctionne sans soucis.</div><div style="text-align: justify;">A noter que via la méthode <i>init</i> de <b>FluentTestDelegator</b>, il est possible de préciser le <b>webDriver</b> à utiliser (dans notre cas, HtmlUnitDriver). </div><br /><h1>Mise en oeuvre</h1>On a vu dans le paragraphe précédent comment il était possible de faire fonctionner conjointement Cucumber JVM et FluentLenium.<br />Du coup, il n'y a plus grand chose à rajouter dans ce paragraphe si ce n'est la configuration de notre chef d'orchestre (à savoir Maven) qui a été utilisé pour faire fonctionner tout ce beau monde... ;-)  <br /><br /><pre class="brush:xml; wrap-lines: false; auto-links: false">    &lt;dependencies&gt;        <br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;<br />            &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;<br />            &lt;version&gt;1.3&lt;/version&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;<br />            &lt;groupId&gt;batik&lt;/groupId&gt;<br />            &lt;artifactId&gt;batik-ext&lt;/artifactId&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;        <br />        &lt;!-- pas de montee de version de junit pour cause de conflit avec hamcrest --&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;junit&lt;/groupId&gt;<br />            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br />            &lt;version&gt;4.11&lt;/version&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />            &lt;exclusions&gt;<br />                &lt;exclusion&gt;<br />                    &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;<br />                    &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;<br />                &lt;/exclusion&gt;<br />            &lt;/exclusions&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;info.cukes&lt;/groupId&gt;<br />            &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;info.cukes&lt;/groupId&gt;<br />            &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;<br />            &lt;groupId&gt;info.cukes&lt;/groupId&gt;<br />            &lt;artifactId&gt;cucumber-picocontainer&lt;/artifactId&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;<br />            &lt;artifactId&gt;fluentlenium-festassert&lt;/artifactId&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />            &lt;exclusions&gt;<br />                &lt;exclusion&gt;<br />                    &lt;groupId&gt;junit&lt;/groupId&gt;<br />                    &lt;artifactId&gt;junit-dep&lt;/artifactId&gt;<br />                &lt;/exclusion&gt;<br />            &lt;/exclusions&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.easytesting&lt;/groupId&gt;<br />            &lt;artifactId&gt;fest-assert&lt;/artifactId&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br />    &lt;/dependencies&gt;<br /><br />  &lt;build&gt;<br />   &lt;plugins&gt; <br />                    &lt;plugin&gt;<br />                        &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;<br />                        &lt;executions&gt;<br />                            &lt;execution&gt;<br />                                &lt;goals&gt;<br />                                    &lt;goal&gt;integration-test&lt;/goal&gt;<br />                                    &lt;goal&gt;verify&lt;/goal&gt;<br />                                &lt;/goals&gt;<br />                            &lt;/execution&gt;<br />                        &lt;/executions&gt;<br />                        &lt;configuration&gt;<br />                            &lt;includes&gt;<br />                                &lt;include&gt;**/RunCucumberFeatures.java&lt;/include&gt;<br />                            &lt;/includes&gt;<br />                        &lt;/configuration&gt;<br />                    &lt;/plugin&gt;<br /> <br />        &lt;/plugins&gt;             <br />  &lt;/build&gt;   <br /></pre><pre class="brush:java; wrap-lines: false; auto-links: false">import cucumber.api.junit.Cucumber;<br />import org.junit.runner.RunWith;<br /><br />@RunWith(Cucumber.class)<br />@Cucumber.Options(features = "classpath:fr/jetoile/webapp/acceptance", format = {"pretty", "html:target/cucumber", "json:target/cucumber.json"})<br />public class RunCucumberFeatures {<br />}<br /></pre><br /><h1>Conclusion</h1><div style="text-align: justify;">On a vu dans cet article (qui est la suite logique d'un <a href="http://blog.jetoile.fr/2013/03/demarrer-une-webapp-en-mode-embedded.html">article précédent</a>) comment il était possible de faire des tests d'acceptance en utilisant conjointement Cucumber JVM et FluentLenium.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A l'utilisation, cela s'avère agréable et rapide à écrire surtout avec quelques petits tweaks supplémentaires qui n'ont pas été exposés ici (profile Maven pour ne démarrer que le serveur embedded et exécution des scénarii Cucumber avec IntelliJ 12 avec possibilité de bénéficier du debugger que ce soit au niveau de l'exécution des tests (debugger ou utilisation d'un webDriver autre que HtmlUnitDriver) ou de l'application cible (via mvnDebug)).  </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Bref, en tout cas, même si la mise en oeuvre a été un peu galère, il a été possible de bénéficier du meilleur des deux framework sans avoir à se "taper" la lourdeux de Selenium... ;-). </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Bien sûr, il est existe bien d'autres solutions mais je te laisse, précieux lecteur, le soin de les évaluer ;-)</div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
C&#39;est fait ;-)<br />Je l&#39;ai précisé dans le post <a href="http://blog.jetoile.fr/2013/04/fluentlenium-et-cucumber-jvm-complement.html" rel="nofollow">qui suit</a>.<br /><br />Pour l&#39;instant il n&#39;est que sur mon github mais il faudrait que je le pull request chez FluentLenium... <br /><a href="https://github.com/jetoile/fluentlenium-cucumber/tree/multiNav" rel="nofollow">https://github.com/jetoile/fluentlenium-cucumber/tree/multiNav</a></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Pourrais tu me mettre ton POC sur github ?</div>
</div>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
Cool que ça puisse te servir. Cependant, suite à discussion avec Mathilde, le système a pas mal été refondu et il faudrait que j&#39;en fasse un autre article car pas mal de modifications (mais en mieux) et une approche plus juste ;-)</div>
</div>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
Merci Damien pour les encouragements. Thucydides, je ne connaissais pas. Si un jour j&#39;ai l&#39;occasion de regarder je te ferai signe ;-)</div>
</div>
<div class='comment'>
<div class='author'>Nicolas Huray</div>
<div class='content'>
Très cool cet article mec, j&#39;ai hâte de tester ça sur un projet. ++ Nico</div>
</div>
<div class='comment'>
<div class='author'>Damien Lepage</div>
<div class='content'>
Très bon article Khanh. Récemment j&#39;ai produit un POC pour faire du BDD pour web app avec Thucydides qui englobe JBehave et FluentLenium. Je recommande. Beaucoup de similarités avec ce que tu écris avec en plus des (plus ou moins) jolis graphiques de progression.</div>
</div>
<div class='comment'>
<div class='author'>Classe de 5ème année</div>
<div class='content'>
Ce commentaire a été supprimé par l'auteur.</div>
</div>
</div>
