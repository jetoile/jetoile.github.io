---
layout: post
title: "Spring Integration vs. Apache Camel"
date: 2010-03-15
comments: false
categories:
 - java
 - spring integration
 - apache camel
 - eip
 - jbi
 - soa
---

<div class='post'>
<div class="separator" style="clear: both; text-align: justify;"><a href="http://4.bp.blogspot.com/_XLL8sJPQ97g/S56PashF4SI/AAAAAAAAAJA/OVagPG4D-g0/s1600-h/apache_spring.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/_XLL8sJPQ97g/S56PashF4SI/AAAAAAAAAJA/OVagPG4D-g0/s320/apache_spring.png" /></a></div><div style="text-align: justify;">Lors d'un <a href="http://jetoile.blogspot.com/2009/12/eip-quest-ce-que-cest.html">post précédent</a>, j'avais parlé des EIPs (<i>Enterprise Integration Patterns</i>) en expliquant qu'il s'agissait de Patterns permettant de normaliser les échanges de messages dans un système asynchrone.</div><div style="text-align: justify;">Dans cet article, je vais tenter de présenter succinctement deux de ses implémentations : <a href="http://www.springsource.org/spring-integration">Spring Integration</a> et <a href="http://camel.apache.org/">Apache Camel</a>.</div><div style="text-align: justify;">En fait, pour être plus précis, je vais plutôt tenter de présenter la vision que j'en ai ainsi que la façon dont je les ai compris. </div><div style="text-align: justify;">Ainsi, ce post n'a pas pour objectif de les détailler de manière exhaustive car ils sont trop complets pour cela et qu'un seul post ne pourrait suffire à les aborder tous les deux (leurs documentations font d'ailleurs, pour Spring Integration, plus de 130 pages, et pour Apache Camel, plus de 580 pages... cqfd... ;-) ) mais juste, comme je l'ai dit précédemment dit, d'aider à comprendre leurs différences (quelles soient conceptuelles ou structurelles).</div><div style="text-align: justify;">Je ne reviendrai pas sur les concepts des EIPs ni de JBI que j'utiliserai dans la suite et pour cela, je vous renvoie sur internet ou sur mes posts précédents (<a href="http://jetoile.blogspot.com/2009/12/eip-quest-ce-que-cest.html">ici</a> et <a href="http://jetoile.blogspot.com/2009/12/jbi-une-solution-enterree.html">là</a>).</div><div style="text-align: justify;">Concernant les versions utilisées, cela n'a pas vraiment son importance ici car je m'intéresserai surtout aux principes de ces deux frameworks mais à titre indicatif, il s'agit des versions 2.0 pour Apache Camel et 1.3.0 pour Spring Integration (il me semble qu'il n'y a pas de modifications flagrantes dans les versions courantes qui sont 2.2.0 pour Camel et 2.0.0.M2 pour Spring Integration).</div><!-- more --><h1>Les concepts</h1><h2>Apache Camel</h2><div style="text-align: justify;">Apache Camel est un framework open-source qui est une implémentation des EIPs et qui propose pour sa configuration d'utiliser indifféremment :</div><ul style="text-align: justify;"><li>un fichier de configuration Spring (Spring DSL), <br /></li><li>un DSL interne (Java DSL), <br /></li><li>ou un DSL externe (Scala DSL).</li></ul><div style="text-align: justify;">Cependant, il définit ses propres concepts qui diffèrent de ceux des EIPs mais qui restent assez similaires.</div><div style="text-align: justify;">Ainsi, Apache Camel s'appuie sur la notion de routes (<b>Route</b>) qui relient deux points d'accès (<b>Endpoint</b>). Sur cette route transite des messages (<b>Message</b>) au travers d'échanges (<b>Exchange</b>). En fait un Exchange est le conteneur du message durant la phase de routage.</div><div style="text-align: justify;">Ces points d'accès peuvent être de différents types et peuvent supporter différentes technologies telles que :</div><ul style="text-align: justify;"><li>une destination (Topic ou Queue) JMS,</li><li>un service web,</li><li>un fichier se trouvant sur le système de fichier,</li><li>un serveur FTP,</li><li>une adresse mail,</li><li>ou encore un POJO (<i>Plain Old Java Object</i>).<br /></li></ul><div style="text-align: justify;">Si l'on fait un parallèle avec JBI (<i>Java Business Integration</i>) (cf. ici), un <b>Endpoint</b> peut être vu comme une <u>instance</u> d'un <b>Binding Component</b>.</div><div style="text-align: justify;">Une Route peut, quant à elle, être vue comme le chemin qu'emprunte le message d'un bout à l'autre de la chaîne de médiation. Ce chemin pouvant être entrecoupé par ce qu'on appelle des processeurs (<b>Processor</b>). </div><div style="text-align: justify;">Apache Camel introduit également la notion de Composants (<b>Component</b>) à partir desquels les <b>Endpoint</b> sont issus (toujours pour faire un parallèle avec JBI, un <b>Component</b> peut être vu comme un <b>Composant JBI</b> en mode fournisseur ou consommateur).</div><div style="text-align: justify;">Enfin, par composition à un <b>Endpoint</b>, Apache Camel utilise également les notions de <b>Producer</b> et <b>Consumer</b> qui permettent d'émettre (respectivement, recevoir) un message vers (resp. d') une application extérieure et qui peuvent être vu comme des <b>Binding Component</b> en mode fournisseur (resp. consommateur). </div><h2>Spring Integration</h2><div style="text-align: justify;">Spring Integration appartient au portfolio de Spring Framework et étend le modèle de programmation de Spring mais dans le domaine de la messagerie. Il supporte l'architecture basée sur les messages (<i>Message-Driven Architecture</i>) où l'inversion de contrôle est utilisée pour les problématiques d'exécution comme, par exemple, quand doivent être appelés les composants métiers ou encore où doivent être envoyées les réponses. En outre, il offre des mécanismes de routage et de transformation de messages afin de permettre aisément l'utilisation de protocoles de transport et des types de messages hétérogènes. Il propose pour sa configuration d'utiliser soit un fichier de configuration Spring soit le mécanisme d'annotations.</div><div style="text-align: justify;">Concernant ses concepts, ils collent parfaitement à ceux des EIPs puisque Spring Integration utilise la notion de :</div><ul style="text-align: justify;"><li><b>Message</b> dont la définition est identique à celle des EIPs, <br /></li><li><b>Message Channel </b> dont la définition est identique à celle des EIPs,</li><li>et de <b>Message Endpoint</b> qui regroupe :</li><ul><li>les Message Routing  dont la définition est identique à celle de Routing des EIPs</li><li>les Message Transformation   dont la définition est identique à celle de Transformation des EIPs</li><li>et les Message Endpoint   dont la définition est identique à celle des EIPs</li></ul></ul><h1>Mon avis avant utilisation</h1><h2>Apache Camel</h2><div style="text-align: justify;">Apache Camel est un framework issu de l'implémentation JBI Apache ServiceMix et qui est également utilisé dans OpenESB. Cela peut expliquer pourquoi ses concepts sont si proches de ceux de JBI (ou du moins que les modèles sont si facilement transposables). Cependant, à mon sens, même si ses concepts sont proches de ceux de JBI, les termes utilisés sont différents et, pour ceux qui connaissent JBI, un effort d'apprentissage supplémentaire doit être fait. En outre, la documentation d'Apache Camel est loin d'être aisée à lire et retrouver de l'information dans le wiki qui lui sert de documentation s'achèvent généralement avec des cheveux en moins, une souris torturée ou un écran ébréché... le tout accompagné par une flopée d'injures... </div><div style="text-align: justify;">Ainsi, à mon avis, pour un produit qui se veut être une implémentation des EIPs, il faut :</div><ul style="text-align: justify;"><li>d'une part, lire ou se familiariser avec les EIPs</li><li>et d'autre part, connaitre JBI ou, au moins, se familiarisé avec les concepts d'Apache Camel (comprendre la différence entre un composant, un endpoint qui est lui-même un processeur, les éléments pipeline et multicast qui sont eux-même des processeurs, etc, etc, etc...). Rien d'insurmontable mais il est quand même nécessaire de se faire quelques nœuds au cerveau...</li></ul><div style="text-align: justify;">Par contre, par rapports aux EIPs, Apache Camel masque la notion de Channel, ce qui peut s'avérer plaisant.</div><h2>Spring Integration</h2><div style="text-align: justify;">Spring Integration est un projet du portfolio Spring donc très propre, avec une documentation très bien faite et pas trop longue... En outre, pour quelqu'un qui est déjà familiarisé avec les EIPs, la prise en main de Spring Integration est immédiate. Le fait qu'il s'appuie sur Spring (tout comme Apache Camel d'ailleurs) permet une courbe d'apprentissage rapide. </div><h1>Mon avis après utilisation</h1><h2>Apache Camel</h2><div style="text-align: justify;">Apache Camel s'avère ardu à prendre en main malgré un forum actif. Cela en raison de sa documentation un peu (complètement?) fouillis mais également parce qu'il est possible de faire la même chose de multiples manières, ces manières ayant chacunes ses limitations. Si on utilise le framework simplement avec une description XML et des POJOs (qui sont, parfois, fortement couplé au framework Apache Camel au travers de son API (Exchange, Endpoint, ...) ... pas très propre tous ça... :( ), on peut arriver sans trop de douleur à faire ce que l'on veut. Par contre, si on se lance dans les DSLs internes ou externes (et même si j'aime bien le principe des DSLs...), cela n'exclue pas l'adhérence des POJOs à l'API d'Apache Camel et il est souvent nécessaire de faire intervenir la notion d'Exchange dans les signatures des méthodes.</div><div style="text-align: justify;">En outre, on se rend rapidement compte que la majorité des classes de l'API héritent de l'interface <b>Processor</b>. Pourquoi cela me pose problème? et bien parce que j'estime qu'il est bizarre et peu naturel que certaines classes comme Pipeline ou MulticastProcessor implémente (directement ou indirectement) Processor ou alors il aurait, au moins, été préférable de mettre ce type de classes dans un autre package que celui où se trouvent des classes comme Aggregator, FileProcessor, Resequencer ou encore RecipientList. Bon, je comprends qu'Apache Camel a été pensé dès le départ pour offrir une configuration simple à base de DSL et que, du coup, il a été nécessaire de faire certaines concessions mais lorsque l'on rentre dans le code du framework, ce n'est pas (et cela ne concerne que moi) une impression de propreté qui en ressort... </div><div style="text-align: justify;">Un autre point qui m'interpelle est le fait que lors de l'écriture des règles de médiations, il n'y a pas de différences sémantiques entre les différentes notions qu'offrent les EIPs : les Message Transformation, Message Routing ou Service Activator se représentent tous comme des Processor ou des Bean. Je trouve cela dommage de perdre la classification (qu'on aime ou pas) fournit par les EIPs et qui, à mon sens, permettait justement de clarifier toutes les notions utiles pour gérer les échanges de messages dans un système asynchrone. </div><div style="text-align: justify;">Par contre, comme je l'ai dit précédemment, il est vraiment appréciable de ne pas à avoir à déclarer ses propres Channels qui sont masqués par la notion de Route.</div><h2>Spring Integration</h2><div style="text-align: justify;">Spring Integration est extrèmement simple à prendre en main et son forum est très actif. La documentation est claire et c'est vrai qu'il est appréciable de pouvoir utiliser les notions des EIPs directement.</div><div style="text-align: justify;">Les annotations sont parlantes et les éléments (service-activator, splitter, filter, resequencer, aggregator, transformer, router, ...) à utiliser dans le fichier de configuration Spring permettent de classifier rapidement les différents éléments se trouvant dans la chaine de médiations.</div><div style="text-align: justify;">En outre, le code interne du framework est propre et permet de masquer la complexité des différents Message Endpoint.</div><div style="text-align: justify;"><br /></div><h1>Conclusion</h1><div style="text-align: justify;">Vous l'aurez compris, j'ai une petite préférence pour Spring Integration...</div><div style="text-align: justify;">Cependant, je dirai que le choix dépend aussi grandement de l'utilisation qu'on veut en faire (bon ok, je ne me mouille pas trop... ;-) ) : </div><ul style="text-align: justify;"><li>dans un ESB type ServiceMix ou OpenESB, il peut être préférable d'utiliser Apache Camel en raison de sa capacité à être configurée via un DSL qui peut être plus aisé que de manipuler des Channels et des fichiers XML,</li><li>par contre, pour les autres cas, je conseillerai plutôt Spring<br />Integration pour son modèle de programmation et ses concepts plus<br />simple...</li></ul><div style="text-align: justify;">mais là, je conseillerai à chacun de se faire sa propre idée... </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Un petit mot en plus sur les points non abordés ci-dessus : </div><ul style="text-align: justify;"><li>les mécaniques offertes pour manipuler des messages au format XML (XPath, ...),<br /></li><li>la gestion des erreurs,</li><li>le nombre de connecteurs fournis par ces derniers.</li></ul><div style="text-align: justify;">Sur ces deux derniers points, l'avantage va indéniablement à Apache Camel même s'il est aisé (modulo la connaissance du protocole utilisé) d'en redéfinir avec Spring Integration en utilisant un Service Activator mais, dans ce cas, il faut le faire à la main.</div><div style="text-align: justify;">Pour le premier point, je ne dirai rien car je n'ai pas eu l'occasion de l'utiliser...</div><div style="text-align: justify;">Enfin, il ne faut pas oublier que ces frameworks ont pour but principal d'offrir un moyen de faire de la médiation technique et non de gérer une orchestration de processus métier et que pour cette raison, ils doivent être utilisés à bon escient.</div><h1>Pour aller plus loin...</h1><ul style="text-align: justify;"><li>SOA : le guide de l’architecte de X. Fourner-Morel, P. Grojean, G. Plouin et C. Rognon chez Dunod</li><li>Enterprise Integration Patterns de G. Hohpe et B. Woolf chez Addisson Wesley</li></ul><ul style="text-align: justify;"><li>Site de Spring Integration : <a href="http://www.springsource.org/spring-integration">http://www.springsource.org/spring-integration</a></li><li>API de Spring Integration : <a href="http://static.springframework.org/spring-integration/apidocs/">http://static.springframework.org/spring-integration/apidocs/</a></li><li>Manuel de référence de Spring Integration : <a href="http://static.springframework.org/spring-integration/reference/htmlsingle/spring-integration-reference.html">http://static.springframework.org/spring-integration/reference/htmlsingle/spring-integration-reference.html</a></li><li>Site d'Apache Camel : <a href="http://camel.apache.org/">http://camel.apache.org/</a></li><li>API d'Apache Camel : <a href="http://camel.apache.org/javadoc.html">http://camel.apache.org/javadoc.html</a> </li><li>Manuel de référence d'Apache Camel : <a href="http://camel.apache.org/manual.html">http://camel.apache.org/manual.html</a></li><li>Spécification de JBI : <a href="http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html">http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html</a></li><li>Blog de Xebia sur les ESB légers : <a href="http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/">http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/</a></li><li>Blog de Xebia sur une revue de presse d'un article sur Spring Integration et Apache Camel : <a href="http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel">http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel</a></li></ul><ul style="text-align: justify;"><span style="font-size: small;"><span style="font-family: Arial,Helvetica,sans-serif;"> </span></span></ul></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Olivier</div>
<div class='content'>
@bdusauso<br />Merci des précisions, je ne l&#39;ai pas été assez. Effectivement, CXF fait aussi du contract first. Ce que je voulais mettre en évidence est qu&#39;il n&#39;est pas aisé, dans le cas que j&#39;ai rencontré de facilement, avec le support de CXF dans Camel, faire du transfert de message sans passer par une génération de Beans.<br /><br />Je n&#39;ai peut-être pas par manque de temps assez creusé la chose, mais dans mon cas, passer d&#39;un messages JMS (en entrée) au format XML à un appel web service en sortie de Camel avec ce même contenu en payload ne me paraissait pas simplement applicable. Par contre, l&#39;utilisation du client Spring Web Service m&#39;a permis de le réaliser en quelques lignes.<br /><br />J&#39;ai souscrit à la MEAP pour le bouquin Camel, et j&#39;avoue que je ne l&#39;ai pas encore lu, j&#39;attend de trouver un moment. Cependant, on m&#39;en a dit beaucoup de bien.<br /><br />L&#39;idée de post n&#39;était pas de dénigrer Camel (je l&#39;utilise et en suis content), mais plutôt à l&#39;époque d&#39;avertir les personnes souhaitant se lancer dans son utilisation de bien prévoir une montée en compétences assez raide, due au manque de documentation pertinente.</div>
</div>
<div class='comment'>
<div class='author'>bdusauso</div>
<div class='content'>
Je suis tombé sur ce billet à la suite de la lecture des articles concernant JMX.<br />J&#39;ai commencé à utiliser Apache Camel il y a un an, début 2010 donc.<br />Je me suis directement procuré l&#39;excellent livre &quot;Camel in Action&quot; de chez Manning, écrit par un des auteurs de Camel.<br />Il est vrai que le wiki était, à l&#39;époque, un peu limité en exemples, mais cela a bien changé : la documentation, ainsi que le code source de Camel, sont d&#39;une aide précieuse.<br />En outre, la mailing-list est très active et les réponses sont rapides et précises.<br /><br />Concernant les webservices, la remarque concernant CXF basé sur l&#39;approche code first est erronée. En effet CXF supporte les deux approches, tant code-first que contract-first.<br />De plus, il est extrêmement aisé de fournir une interface webservice (REST ou SOAP) comme point d&#39;entrée d&#39;une route. Cela m&#39;a pris quelques lignes, un bean dans ma configuration Spring et une servlet CXF dans mon web.xml.<br /><br />Je ne peux malheureusement pas donner d&#39;opinion sur Spring Integration, ne l&#39;ayant pas testé suffisamment.<br /><br />Pour ma part, Apache Camel m&#39;a vraiment convaincu et je l&#39;utilise intensivement dans mes projets, sans difficultés majeures.</div>
</div>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
merci Olivier pour ces remarques complémentaires.<br />Sinon, c&#39;est vrai qu&#39;Apache Camel offre un aspect test beaucoup plus développé que Spring Integration.</div>
</div>
<div class='comment'>
<div class='author'>Olivier</div>
<div class='content'>
Plutôt du même avis concernant Camel :<br /><br />. le DSL Java est peu documenté (Javadoc ?), et si le typage fort des arguments est mis en avant dans la documentation, aucun des exemples ne le présente réellement. Ce sont surtout les paramètres de type String qui sont utilisés. Un aveu d&#39;échec des bonnes intentions ?<br /><br />. le DSL Spring est très incomplet (multicast dynamique ?), buggé (l&#39;error handler ne marchait pas dans mon cas), et non documenté (présent dans peu d&#39;exemples valables, le XML Schema est vide de commentaires. On est très vite découragé de l&#39;utiliser.<br /><br />. les annotations sont assez intéressantes, mais à utiliser en combinaisons avec un des précédents DSL, car incomplet.<br /><br />. le support WS est basé sur CXF (code first), ce qui complique des cas qui devraient rester simples, comme le transfert de protocole (REST/SOAP, JMS/SOAP, etc). C&#39;était mon cas, et j&#39;ai du passer par un POJO composé d&#39;un client Spring WS.<br /><br />. par contre, l&#39;aspect test a été réellement pris en compte dans Camel ce qui est un point vraiment important.</div>
</div>
</div>
