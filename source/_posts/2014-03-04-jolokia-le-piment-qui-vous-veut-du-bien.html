---
layout: post
title: "Jolokia : le piment qui vous veut du bien"
date: 2014-03-04
comments: false
categories:
 - java
 - jmx
 - jolokia
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-6Xm2grUWMtI/UxTNAazymaI/AAAAAAAABPE/dXJ7fti_FLA/s1600/jolokia.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-6Xm2grUWMtI/UxTNAazymaI/AAAAAAAABPE/dXJ7fti_FLA/s1600/jolokia.png" /></a></div><div style="text-align: justify;">Dans des articles précédents, je m'étais déjà exprimé sur le fait que je trouvais qu'il était important de monitorer son application (qu'il s'agisse d'une application web, d'un batch ou d'une application standalone) (cf. <a href="http://blog.jetoile.fr/2010/05/jmx-ou-comment-administrer-et.html">ici</a>). J'avais même creusé un peu la spécification JMX (cf. <a href="http://blog.jetoile.fr/2010/10/jmx-pour-les-nuls-introduction.html">là</a>). </div><div style="text-align: justify;">Pour faire suite à ce besoin, je vais, dans cet article, faire un focus sur un outils que j'ai découvert récemment (merci Romain ;-) ) mais qui existe depuis un moment (la version 1.0.0 est apparue en octobre 2011 sur le repo Maven central et le premier commit apparaissant sur Github date de Juillet 2010) : cet outils est <b>Jolokia</b>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Comme à mon habitude, pour présenter cet outils, je m'appuierai sur la document officielle dans sa version courante, à savoir la 1.2.0.</div><div style="text-align: justify;"><br /></div><br /><div style="text-align: justify;">Cependant, je ne ferai pas un plagiat exhaustif de la documentation qui est très complète (et surtout, je n'ai pas envie de me traduire les 92 pages de cette dernière... ;-) ) mais j'essaierai de faire un focus sur les points que je trouve les plus intéressants (à savoir les principes ainsi que le mode agent JVM (cf. plus tard) ).</div><!-- more --><br /><h1>Principes et concepts</h1><h2>Jolokia... pour quoi faire?</h2><div style="text-align: justify;">Dans le monde Java, il existe un standard pour faire de l'administration/supervision : il s'agit de JMX (Java Management eXtension). Il est inclus depuis le JDK 1.5.&nbsp;</div><div style="text-align: justify;">Cependant, JMX est malheureusement un des parents pauvres de Java : souvent méconnu ou mal utilisé, il est aussi très orienté vers le monde Java (et cela, même s'il existe la <a href="https://jcp.org/en/jsr/detail?id=160">JSR 160 - Java Management eXtension Remote API</a>). </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">C'est la raison d'être de Jolokia qui offre une approche agent (qui cohabite avec la JSR 160) tout en offrant une interopérabilité via HTTP au moyen de JSON pour la partie <i>payload</i>. Cela lui permet d'exposer les couches d'administration/supervision JMX des applicatifs Java via une protocole interopérable de tous.  </div><div style="text-align: justify;"><br /></div><h2>Architecture</h2><div style="text-align: justify;">L'architecture de Jolokia diffère de celle de la JSR 160. En effet, la JSR 160 permet à un client d'invoquer de manière transparente un MBean qu'il soit dans un <i>MBeanServer</i> local ou distant.</div><div style="text-align: justify;">Cependant, même si cela est intéressant, c'est également une approche dangereuse puisque cela masque la partie transport qui peut entraîner un <i>overhead</i> mais cela expose aussi le modèle des objets qui transitent.&nbsp;</div><div style="text-align: justify;">En effet, il existe une adhérence implicite au protocole RMI (qui est d'ailleurs le protocole par défaut des connecteurs JMX) pour la partie mécanisme de sérialisation des objets. C'est ce dernier point qui pose un problème d'interopérabilité avec tout programme extérieur à une JVM.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ainsi, Jolokia, en offrant une approche différente via HTTP/JSon, permet de réconcilier ces différents mondes. Pour ce faire, il propose 2 modes : </div><ul><li style="text-align: justify;">un mode agent,</li><li style="text-align: justify;">un mode proxy.</li></ul><div style="text-align: justify;"><br /></div><h3>Le mode agent</h3><div style="text-align: justify;">Dans ce mode, Jolokia se présente comme un agent qui expose un protocole au format JSON via HTTP et qui permet de servir de <i>bridge</i> vers les MBeans JMX locaux. Cela se passe donc en dehors du scope de la JSR 160.</div><div style="text-align: justify;">Ainsi, il est possible d'exporter ce protocole de différentes manières dont la plus courante est via un conteneur de Servlet (qu'il soit légé ou pas).</div><div style="text-align: justify;">Cependant, il existe d'autres possibilités comme des agents spécialisés qui peuvent utiliser un service HTTP OSGI ou qui peuvent embarquer un serveur Jetty. </div><div style="text-align: justify;">Il est à noter que l'agent utilise le serveur HTTP embarqué dans toutes les JVM 6 d'Oracle et qu'il peut  donc s'attacher dynamiquement à toutes les processus Java.</div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-TnigS1cXxaI/UxTNwI9jtzI/AAAAAAAABPM/q0rHjKSMmq4/s1600/jolokia-agent.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-TnigS1cXxaI/UxTNwI9jtzI/AAAAAAAABPM/q0rHjKSMmq4/s1600/jolokia-agent.png" height="255" width="320" /></a></div><div style="text-align: justify;"><br /></div><h3>Le mode proxy</h3><div style="text-align: justify;">Ce mode peut être utilisé lorsqu'il n'est pas possible de déployer un agent Jolokia sur la plateforme cible. Pour ce mode, le seul prérequis est l'accès au serveur cible via une connexion à travers de la JSR 160. Cela peut être le cas si l'application ne peut pas être modifiée ou si l'application expose déjà ses MBeans via la JSR 160.</div><div style="text-align: justify;">Ce mode nécessite un conteneur de Servlet dans lequel sera déployée l'application web <b>jolokia.war</b> qui a, à sa charge, de "<i>proxyfier</i>" et qui, par défaut, supporte à la fois le mode agent et le mode proxy. </div><div style="text-align: justify;">Ainsi, dans ce mode, un client enverra une requête Jolokia avec une section supplémentaire spécifiant la cible qui doit être atteinte. Toutes les information de routage est donc contenu dans la requête elle-même de manière à ce que le proxy puisse agir sans configuration spécifique.   </div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-wf_ReDc9AKk/UxTN2msI-BI/AAAAAAAABPU/neUmwiePEs0/s1600/jolokia-proxy.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-wf_ReDc9AKk/UxTN2msI-BI/AAAAAAAABPU/neUmwiePEs0/s1600/jolokia-proxy.png" height="224" width="320" /></a></div><div style="text-align: justify;"><br /></div><h2>Les agents</h2><div style="text-align: justify;">Jolokia propose une approche orientée agent qui doit être, soit déployé sur la cible (mode agent), soit sur un serveur proxy (mode proxy). </div><div style="text-align: justify;">Pour ces deux modes, il existe 4 types d'agent : </div><ul><li style="text-align: justify;"><b>WAR agent</b> : cet agent est packagé sous forme de WAR.</li><li style="text-align: justify;"><b>OSGI agent</b> : cet agent au format OSGI (bundle) vient sous 2 formes : un agent minimal qui dispose d'une dépendance sur un OSGI <i>HTTService</i> qui doit être démarré et un agent "tout en un" qui embarque une implémentation de <i>HTTPService</i>.</li><li style="text-align: justify;"><b>Mule agent</b> : cet agent s'intègre à Mule et fourni une API d'adminitration/supervision dans lequel un agent jolokia dédié est intégré. Il inclut un serveur Jetty embarqué.</li><li style="text-align: justify;"><b>JVM agent</b> : Depuis la version 1.6 du JDK d'Oracle, la JVM embarque un serveur HTTP légé. En utilisant ce dernier, Jolokia expose ses fonctionnalité. Cependant, cet agent peut être un peu lent en raison du fait que le serveur HTTP embarqué dans la JVM ne soit pas optimisé pour les performances.</li></ul><div style="text-align: justify;">Les deux types d'agent qui seront un peu plus détaillés dans cet article sont les types WAR agent et JVM agent.</div><h3>WAR agent</h3><div style="text-align: justify;">Le type WAR agent se présente comme une application web standard (au format WAR). La configuration se fait alors via l'élément <i>init-param</i> du web.xml. </div><div style="text-align: justify;">Un autre moyen consiste à utiliser le context (dans le cas de Tomcat) qui permet de déporter la configuration en dehors du WAR. Ainsi, par exemple avec Tomcat, avec le context de l'application web se trouvant dans $TOMCAT_HOME/conf/Catalina/localhost, on peut avoir par exemple : </div><pre class="brush:xml; wrap-lines: false; auto-links: false">&lt;Context&gt;<br />&lt;Parameter name="maxDepth" value="1"&gt;<br />&lt;/Context&gt;<br /></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Au niveau paramétrage, je vous laisse aller voir la document officielle ;-). </div><div style="text-align: justify;">Du point de vue sécurité, il est possible de bénéficier de la sécurité du conteneur de Servlet via le web.xml.</div><br /><div style="text-align: justify;">Une autre manière de faire consite à intégrer Jolokia comme Servlet dans son application web. Pour ce faire, il suffit de tirer la bonne dépendance et de préciser le Servlet de Jolokia de manière classique via les éléments <i>servlet</i> et <i>servlet-mapping</i> du web.xml de l'application. </div><pre class="brush:xml; wrap-lines: false; auto-links: false">&lt;dependency&gt;<br />  &lt;groupId&gt;org.jolokia&lt;/groupId&gt;<br />  &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;<br />  &lt;version&gt;${jolokia.version}&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Comme il est possible de déployer de multiples WAR agents Jolokia sur une même JVM, puisque des MBeans spécifiques Jolokia sont déployé dans le <i>PlatformMBeansServer</i>, il faut préciser la valeur de l'élément <i>mbeanQualifier</i> dans les paramètres d'init.  </div><h3>JVM agent</h3><div style="text-align: justify;">Ce type d'agent Jolokia que j'ai testé IRL est très simple à utiliser et permet d'attacher un agent à une JVM afin qu'elle expose à la mode REST ses couches d'administration et de supervision. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il est possible de :</div><div style="text-align: justify;"></div><ul><li><i>bootstrapper</i>  l'agent JVM au démarrage de la JVM en lui fournissant le jar adéquate ainsi que les options qui vont bien :</li></ul><br /><pre class="brush:bash; wrap-lines: false; auto-links: false">java -javaagent:agent.jar=port=7777,host=localhost<br /></pre><div style="text-align: justify;"></div><ul><li><i>bootstrapper</i> l'agent JVM en lui fournissant directement une fichier de configuration :</li></ul><br /><pre class="brush:bash; wrap-lines: false; auto-links: false">java -javaagent:agent.jar=config=$FICHIER_CONFIG_JOLOKIA<br /></pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;">où un exemple de fichier de configuration peut être trouvé dans jar de l'agent (au nom de default-jolokia-agent.properties).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">où agent.jar peut être téléchargé de <a href="http://www.jolokia.org/download.html">http://www.jolokia.org/download.html</a> (artifact : JVM-Agent).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">De la même manière, un agent Jolokia peut être attaché à une processus Java à la demande (un peu comme lorsque JConsole se connecte à un processus local). Pour ce faire, il suffit de lancer la commande suivante :&nbsp;</div><div style="text-align: justify;"><pre class="brush:bash; wrap-lines: false; auto-links: false">java -jar agent.jar start &lt;PID&gt;</pre></div><div style="text-align: justify;"><br /></div><h2>Jolokia et la sécurité</h2><div style="text-align: justify;">Jolokia permet de configurer la sécurité assez finement. N'ayant pas tester, je ne m'attarderai pas trop sur le sujet.&nbsp;</div><div style="text-align: justify;">Cependant, il est intéressant de noter que Jolokia permet de filtrer l'accès des clients par IP mais offre également un accès plus fin pour l'accès aux MBeans (read/write/exec/list/search/version).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Point également important, Jolokia supporte la spécification W3C pour le Cross-Origin Resource Sharing (CORS) qui permet d'utiliser des outils comme <a href="http://hawt.io/">Hawt.io</a> (mais nous y reviendront plus tard...).</div><div style="text-align: justify;"><br /></div><h2>Le protocole Jolokia</h2><div style="text-align: justify;">Jolokia utilise un protocole JSON sur HTTP. La communication est basé sur le paradigme requête/réponse où chaque requête fournit une réponse.<br /><br /></div><div style="text-align: justify;">Les requêtes peuvent être envoyées de deux manières :  </div><ul><li style="text-align: justify;">soit avec une requête HTTP GET (dans ce cas, les paramètres sont encodés dans l'URL),</li><li style="text-align: justify;">soit avec une requête HTTP POST où la requête est incluse dans le corps de la requête au format JSON.</li></ul><div style="text-align: justify;">Les réponses retournées par l'agent sont, quant à elles, toujours envoyées en JSON.<br /><br /></div><div style="text-align: justify;">De plus, les requêtes au format HTTP GET peuvent prendre deux formes :  </div><ul><li style="text-align: left;">utiliser un format REST (ex : http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage)</li><li style="text-align: left;">utiliser un format où la requête est donnée par un paramètre p= (ex : http://localhost:8080/jolokia?p=/read/jboss.jmx:alias=jmx%2Frmi%2FRMIAdaptor/State)</li></ul><div style="text-align: justify;">A noter que Jolokia utilise le caractère "!" comme caractère d'échappement.<br /><br /></div><div style="text-align: justify;">Plutôt que de longs discours, quelques exemples issus de la documentation aideront à comprendre...</div><div style="text-align: justify;">Pour lire la valeur du MBean dont l'objectName est java.lang:type=Memory/HeapMemoryUsage, les requêtes suivantes sont équivalentes : </div><pre class="brush:bash; wrap-lines: false; auto-links: false">curl -XGET "http://127.0.0.1:8778/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used"<br /></pre><br /><pre class="brush:bash; wrap-lines: false; auto-links: false">curl -XGET "http://127.0.0.1:8778/jolokia/?p=/read/java.lang:type=Memory/HeapMemoryUsage/used"<br /></pre><br /><pre class="brush:bash; wrap-lines: false; auto-links: false">curl -XPOST -d '{"type" : "read", "mbean" : "java.lang:type=Memory", "attribute" : "HeapMemoryUsage", "path" : "used" }' http://127.0.0.1:8778/jolokia/<br /></pre><br />(soit en format lisible : <br /><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "type": "read",<br />    "mbean": "java.lang:type=Memory",<br />    "attribute": "HeapMemoryUsage",<br />    "path": "used"<br />}<br /></pre>)<br /><br />La réponse obtenue est de la forme :  <br /><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "timestamp": 1393865787,<br />    "status": 200,<br />    "request": {<br />        "mbean": "java.lang:type=Memory",<br />        "path": "used",<br />        "attribute": "HeapMemoryUsage",<br />        "type": "read"<br />    },<br />    "value": 162037504<br />}<br /></pre><div style="text-align: justify;"><br />Pour montrer le coté structuré de la réponse, à une requête de type : </div><pre class="brush:bash; wrap-lines: false; auto-links: false">http://127.0.0.1:8778/jolokia/read/java.lang:type=Memory<br /></pre>on obtient : <br /><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "timestamp": 1393866039,<br />    "status": 200,<br />    "request": {<br />        "mbean": "java.lang:type=Memory",<br />        "type": "read"<br />    },<br />    "value": {<br />        "Verbose": false,<br />        "ObjectPendingFinalizationCount": 0,<br />        "NonHeapMemoryUsage": {<br />            "max": 329252864,<br />            "committed": 218951680,<br />            "init": 19136512,<br />            "used": 139774968<br />        },<br />        "HeapMemoryUsage": {<br />            "max": 518979584,<br />            "committed": 518979584,<br />            "init": 134217728,<br />            "used": 179096552<br />        },<br />        "ObjectName": {<br />            "objectName": "java.lang:type=Memory"<br />        }<br />    }<br />}<br /></pre><div style="text-align: left;">Concernant les opérations possibles (dans l'exemple précédent, il s'agissait d'une lecture), il existe : </div><ul><li style="text-align: left;"><b>read</b> avec le format GET suivant :&nbsp;</li></ul>&lt;base-url&gt;/read/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;inner path&gt;<br /><div>(ex : http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used)<br /><ul><li style="text-align: left;"><b>write</b> avec le foramt GET suivant :&nbsp;</li></ul>&lt;base url&gt;/write/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;value&gt;/&lt;inner path&gt;&nbsp;</div><div>(ex : http://localhost:8080/jolokia/write/java.lang:type=Memory/Verbose/true)<br /><ul><li style="text-align: left;"><b>exec</b> avec le format GET suivant :&nbsp;</li></ul>&lt;base url&gt;/exec/&lt;mbean name&gt;/&lt;operation name&gt;/&lt;arg1&gt;/&lt;arg2&gt;/....&nbsp;</div><div>(ex : http://localhost:8080/jolokia/exec/java.lang:type=Memory/gc)<br /><ul><li style="text-align: left;"><b>search</b> avec le format GET suivant :&nbsp;</li></ul>&lt;base-url&gt;/search/&lt;pattern&gt;&nbsp;</div><div>(ex : http://localhost:8080/jolokia/search/*:j2eeType=J2EEServer,*)<br /><ul><li style="text-align: left;"><b>list</b> avec le format GET suivant :&nbsp;</li></ul>&lt;base-url&gt;/list/&lt;inner path&gt;&nbsp;</div><div>(ex : http://localhost:8080/jolokia/list/java.lang/type=Memory/attr)<br /><ul><li style="text-align: left;"><b>version</b> qui permet d'avoir la version du protocole utilisé ainsi qu'un ensemble de paramètre avec le format GET suivant :&nbsp;</li></ul>&lt;base-url&gt;/version&nbsp;</div><div>(ex : http://localhost:8080/jolokia/version)<br /><ul></ul><div style="text-align: left;"><br />Enfin, si le mode proxy est utilisé, seul le mode POST peut être utilisé et doit, alors, avoir le format suivant : </div><pre class="brush:js; wrap-lines: false; auto-links: false">{<br />    "type" : "read",<br />    "mbean" : "java.lang:type=Memory",<br />    "attribute" : "HeapMemoryUsage",<br />    "target" : { <br />         "url" : "service:jmx:rmi:///jndi/rmi://targethost:9999/jmxrmi",<br />         "user" : "jolokia",<br />         "password" : "s!cr!t"<br />    } <br />} <br /></pre><div style="text-align: justify;"><br />Je ne rentrerai pas plus en détaille sur cette partie là qui est beaucoup plus exhaustive dans la documentation officielle (comment les objets sont sérialisés, le mapping complet des MXBeans, la découverte des agents ou les différentes versions du protocole Jolokia - actuellement la version 7.1 - ) et si cela est nécessaire, je conseille d'aller directement se référer à la documentation.  <br /><br /></div><h1>Autres features</h1><div style="text-align: justify;">En plus des fonctionnalités présentées précédemment, Jolokia offre les fonctionnalités suivantes : </div><ul><li style="text-align: justify;">exposition de son propre MBean,</li><li style="text-align: justify;">différents clients (javascript, plugin cubism, java, Jmx4Perl),</li><li style="text-align: justify;">une API de programmation pour exposer sont MBeanServer,</li><li style="text-align: justify;">un JSonMBean,</li><li style="text-align: justify;">une integration Spring,</li></ul><div style="text-align: justify;"><br />Pour l'intégration avec Spring, cela se fait via l'import Maven suivant :  </div><pre class="brush:xml; wrap-lines: false; auto-links: false">&lt;dependency&gt;<br />  &lt;groupId&gt;org.jolokia&lt;/groupId&gt;<br />  &lt;artifactId&gt;jolokia-spring&lt;/artifactId&gt;<br />  &lt;version&gt;1.2.0&lt;/version&gt;<br />&lt;/dependency&gt;  <br /></pre><br />et le contexte Spring suivant : <br /><pre class="brush:xml; wrap-lines: false; auto-links: false">&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xmlns:jolokia="http://www.jolokia.org/jolokia-spring/schema/config"<br />       xsi:schemaLocation="<br />       http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd<br />       http://www.jolokia.org/jolokia-spring/schema/config  http://www.jolokia.org/jolokia-spring/schema/config/jolokia-config.xsd<br />       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br /><br />  &lt;jolokia:agent lookupConfig="true" systemPropertiesMode="never"&gt;<br />        &lt;jolokia:config<br />                autoStart="true"<br />                host="${jolokia.host}"<br />                port="${jolokia.port}"<br />                user="${jolokia.user}"<br />                password="${jolokia.password}"/&gt;<br />    &lt;/jolokia:agent&gt;<br /><br />    &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;<br />        &lt;property name="locateExistingServerIfPossible" value="true"/&gt;<br />    &lt;/bean&gt;<br />&lt;/beans&gt;<br /></pre><br /><h1>Conclusion</h1><div style="text-align: justify;">Dans cet article, une présentation succincte a été faite de Jolokia. J'espère qu'elle vous aura plu ;-)...<br /><br /></div><div style="text-align: justify;">Il s'agit d'un outils simple, pluggable très facilement à n'importe quelle application (une intégration à Cassandra s'est fait en 5 minutes).<br /><br /></div><div style="text-align: justify;">Cette présentation était surtout axé concepts et principes afin de bien comprendre ce que peut apporter cet outils.<br /><br /></div><div style="text-align: justify;">Cependant, un des gros avantage de Jolokia est un point qui n'a pas été abordé dans cet article : il s'agit de son intégration à <a href="http://hawt.io/">Hawt.io</a>. Cet outils ayant déjà fait le sujet d'article sur le blog de Zenika, je vous invite à y jeter un oeil : </div><ul><li style="text-align: justify;"><a href="http://blog.zenika.com/index.php?post/2014/01/07/HawtIO-la-console-web-polyvalente">HawtIO, la console web polyvalente</a></li><li style="text-align: justify;"><a href="http://blog.zenika.com/index.php?post/2014/01/14/HawtIO-ecrire-un-plugin">HawtIO, écrire un plugin</a></li></ul><div style="text-align: justify;"><br />Ainsi, en production, disposer du combo Hawt.io + Jolokia offre, à mon sens, d'énormes avantages comme, par exemple, accèder aux informations de n'importe quelle application qui, généralement, n'est pas accessible pour des raisons de sécurité (cf. <a href="http://blog.jetoile.fr/2010/05/jmx-et-firewall.html">http://blog.jetoile.fr/2010/05/jmx-et-firewall.html</a>). </div><div style="text-align: justify;">Bien sûr, il existe d'autres solutions comme l'utilisation de CraSH mais exposer ses MBeans via JSON over HTTP est tellement simple et peut surtout être exploité simplement par les équipes de production ;-) .   </div><h1 style="text-align: justify;">Pour aller plus loin...</h1><ul><li style="text-align: justify;"><a href="http://www.jolokia.org/">Site de Jolokia</a></li><li style="text-align: justify;"><a href="http://www.jolokia.org/reference/html/index.html">Site de documentation de Jolokia</a></li><li style="text-align: justify;"><a href="http://hawt.io/">Site d'Hawt.io</a></li></ul></div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Khanh Tuong Maudoux</div>
<div class='content'>
Salut Franck,<br /><br />Merci pour ton commentaire.<br />En effet, je suis tout à fait d&#39;accord avec toi quand au fait qu&#39;il n&#39;offre &quot;que&quot; un moyen d&#39;accès aux MBeans et qu&#39;il est plutôt accès pull.<br />Cependant, pour une prod qui a l&#39;habitude d&#39;aller configurer son Nagios ou autres pour aller requêter chaque application, cela est déjà pas mal ;-).<br /><br />Et en effet, si on dispose d&#39;un serveur (type Graphite ou autre) qui récolte les stats d&#39;un grand nombre de serveurs, une solution comme jmxtrans reste le plus adaptée.<br /><br />Après c&#39;est fonction des outils qu&#39;à l&#39;habitude d&#39;utiliser la prod et puis l&#39;un n&#39;empêche pas l&#39;autre ;-).<br /><br />Khanh</div>
</div>
<div class='comment'>
<div class='author'>Franck</div>
<div class='content'>
Jolokia est intéressant si on veut aller chercher des données JMX ou les afficher en local (un vieil article sur le sujet http://nurkiewicz.blogspot.fr/2011/03/jolokia-highcharts-jmx-for-human-beings.html pour faire sa console &quot;à la main&quot;).<br /><br />Dans un autre genre il y a jmxtrans qui permet de centraliser la collecte de différentes JVM et de publier vers différents serveurs de stats comme graphite.<br />On a fait une tentative mais cela n&#39;a pas trop bien marché: je pense que ce mode ne fonctionne pas bien quand on commence à avoir plus de 2 ou 3 JVM : il faut configurer le serveur pour aller chercher les infos, ouvrir les ports, à chaque ajout de JVM etc...<br />Je pense que dans ce cas du push est plus approprié c&#39;est à dire du composant vers le serveur.<br />Et dans ce il y a une version jmxtrans version embedded à intégrer dans chaque JVM qui collecte et qui push vers un serveur de stat.<br />Même sans serveur de stat, l&#39;écriture des indicateurs jmx dans un fichier local à la jvm permet d&#39;historiser les indicateurs.<br /><br />https://github.com/jmxtrans/embedded-jmxtrans<br />https://github.com/jmxtrans/jmxtrans-agent : la version agent si on ne peut pas modifier l&#39;appli<br /><br />@farnulfo</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Humm, ce bon piment. Bien grillé avec Jmx4Perl (http://search.cpan.org/~roland/jmx4perl/lib/JMX/Jmx4Perl.pm) et voilà nos chères applications et serveurs d&#39;application Java surveillée et monitorée par Nagios, Cacti, Munin. Et que dire de j4psh (Jmx4Perl power inside) qui propose un shell pour interroger des MBeans ... sans trop se piquer. Aïe, aïe, aïe !   </div>
</div>
</div>
