<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: soa | Jetoile]]></title>
  <link href="https://blog.jetoile.fr/blog/categories/soa/atom.xml" rel="self"/>
  <link href="https://blog.jetoile.fr/"/>
  <updated>2017-07-11T22:16:03+02:00</updated>
  <id>https://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Devoxx 2012 : Versionner son service dans une architecture SOA et/ou Cloud]]></title>
    <link href="https://blog.jetoile.fr/2012/11/devoxx-2012-versionner-son-service-dans.html"/>
    <updated>2012-11-21T15:12:51+01:00</updated>
    <id>https://blog.jetoile.fr/2012/11/devoxx-2012-versionner-son-service-dans</id>
    <content type="html"><![CDATA[<p><img src="http://1.bp.blogspot.com/-TdkQLPVtGoU/UKkTTw9Zn7I/AAAAAAAAAwM/kdDLDr0zwDw/s1600/devoxxLogo.png" alt="left-small" /></p>

<p>Ça y est&hellip; <a href="http://devoxx.com/">Devoxx</a> est fini&hellip; :&lsquo;(
Comme je l'ai dit dans un article précédent, je ne ferai pas de compte-rendu exhaustif de présentations auxquelles j'ai pu assisté à Devoxx.</p>

<p>Cependant, je tenais à revenir sur la présentation &ldquo;<em>Service Versioning in SOA and Cloud</em>&rdquo; par <strong>Ignaz Wanders</strong> (<a href="https://twitter.com/ignazw">@ignazw</a>) dont le synopsis était :</p>

<blockquote><p>Keeping versioning under control is essential in the success of a SOA. However, there are no industry standards for service versioning, thus leaving the responsibility of implementing a service versioning system up to the architects and developers within the IT enterprise.</p></blockquote>

<br/>


<blockquote><p>We often see design-type versioning, resulting in Big Bang governance strategies. A runtime versioning strategy may be, in fact, be preferable.</p></blockquote>

<br/>


<blockquote><p>Every change must be built, and every change must be governed. A &ldquo;cheap&rdquo; build may lead to a large governance impact. But conversely, a small governance cost may lead to a large build impact. Both build and governance costs need to be taken into account and carefully balanced when choosing and implementing a service versioning strategy.</p></blockquote>

<p>Dans cet article, je me contenterai de montrer quelques-uns des slides de la présentation de Ignaz Wanders qui définissent et synthétisent très bien les différentes stratégies possibles en partant de comment numéroter ses services pour arriver à une proposition qu'il aimerait avoir du coté du consortium OASIS avec un WS-Versioning. Les slides étant suffisant en eux-mêmes et n'ayant pas envie de répéter/déformer leur contenu, je ne mettrai donc que les photos prises pendant la conférence&hellip;</p>

<!-- more -->


<p><img src="http://3.bp.blogspot.com/-jQmsfBODkbk/UKwAQe5_3hI/AAAAAAAAAyI/U2o6JrWPC0A/s1600/_IMG_20121114_183004.jpg" alt="small" /></p>

<p>D'ailleurs, une version pdf dont le contenu est similaire (identique?) est accessible <a href="http://www.servicetechsymposium.com/dl/presentations/the_service_versioning_balancing_act.pdf">ici</a>.</p>

<p>Enjoy! ;&ndash;)</p>

<p><img src="http://4.bp.blogspot.com/-V3A7YsME1qc/UKv_rdwByZI/AAAAAAAAAww/dAFqcrxg9No/s1600/_IMG_20121114_180323.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-xbCED_gA8FI/UKv_u5wLLtI/AAAAAAAAAw4/ftroF40s15k/s1600/_IMG_20121114_180329.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-XgRKL4EkTAM/UKv_x_SQ17I/AAAAAAAAAxA/xFxPFfhuMvY/s1600/_IMG_20121114_180536.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-HVdfl4dxTkM/UKv_1JlCcsI/AAAAAAAAAxI/yc4CU7WU_64/s1600/_IMG_20121114_180815.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-EHMmEnybKBo/UKv_4XJenuI/AAAAAAAAAxQ/dIsguCfMjhw/s1600/_IMG_20121114_181020.jpg" alt="medium" /></p>

<p><img src="http://3.bp.blogspot.com/-Y4wEcftNOD8/UKv_8kw0TqI/AAAAAAAAAxY/w92mR9tPBoU/s1600/_IMG_20121114_181306.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-39pTw8YZvf0/UKv__6d0rNI/AAAAAAAAAxg/XFBaryDXQ5U/s1600/_IMG_20121114_181445.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-deIWO4ytlUU/UKwADCvsYGI/AAAAAAAAAxo/tWO4VBEzI6g/s1600/_IMG_20121114_182310.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-q8PAIg75_mU/UKwAFVcDg4I/AAAAAAAAAxw/ylFPvFhCyJM/s1600/_IMG_20121114_182732.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-6SCvJCOB0_A/UKwAI8wOZ1I/AAAAAAAAAx4/ffn8uhngv9A/s1600/_IMG_20121114_182754.jpg" alt="medium" /></p>

<p><img src="http://2.bp.blogspot.com/-LwnYPf2AUek/UKwAMZaiUKI/AAAAAAAAAyA/8VI-LkSn0Mg/s1600/_IMG_20121114_182903.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-nHjSNerL9nc/UKwAS7CkIhI/AAAAAAAAAyQ/8tXgU50Ohv0/s1600/_IMG_20121114_183054.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-aKBOUmyQc3g/UKwBv2ke-BI/AAAAAAAAAy4/-mtm_ERfCUk/s1600/_IMG_20121114_183135.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-7tcZYwkXHCY/UKwAZ-ouTlI/AAAAAAAAAyg/PqGdkqlXY_k/s1600/_IMG_20121114_183326.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-afWGOsx4Es4/UKwAcX7W76I/AAAAAAAAAyo/4g4lXp3N5JA/s1600/_IMG_20121114_183509.jpg" alt="medium" /></p>

<p><img src="http://3.bp.blogspot.com/-4i4O9yO_nSg/UKwAeejTZqI/AAAAAAAAAyw/9oa_EsrStMI/s1600/_IMG_20121114_183710.jpg" alt="medium" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Découpage de projets : projet vs. modules]]></title>
    <link href="https://blog.jetoile.fr/2012/08/decoupage-de-projets-projet-vs-modules.html"/>
    <updated>2012-08-28T11:47:11+02:00</updated>
    <id>https://blog.jetoile.fr/2012/08/decoupage-de-projets-projet-vs-modules</id>
    <content type="html"><![CDATA[<p><img src="http://2.bp.blogspot.com/-wz814rCkbHY/UC1JmXEpcyI/AAAAAAAAAoA/6YjiYTg7fzw/s1600/couteaux.png" alt="left-small" /></p>

<p>Lorsqu'un projet débute, il est important (à mon avis) de se poser la question sur la façon dont celui-ci sera découpé. Pour être plus précis, il existe deux types d'approches :</p>

<ul>
<li>le découper fonctionnellement,</li>
<li>le découper techniquement.</li>
</ul>


<p>En outre, en plus de ce type de découpage, il est également important de s'interroger sur la façon dont il sera représenté dans le SCM : faut-il tout mettre dans le même projet (au sens SVN ou git du terme) en utilisant éventuellement des sous modules maven si c'est ce dernier qui est utilisé, ou faut-il en créer plusieurs?</p>

<p>C'est de ce dernier point dont il sera question dans ce court article qui présentera l'avis que j'ai pu me faire concernant le découpage technique du projet ie. s'il vaut mieux le découper en projets séparés ou en module (au sens maven du terme).</p>

<p>Il s'agit d'une opinion très personnelle qui peut ne pas être partagée par tous mais je trouvais intéressant de fournir mon humble avis et de le marquer noir sur blanc. Si je venais à dire des bêtises, au moins, cet article servira d'amorce à la discussion ;&ndash;)</p>

<!-- more -->


<h1>Module ou projet?</h1>

<p>Comme mentionné en introduction, cet article traitera de comment architecturer son projet, à savoir, s'il vaut mieux découper son projet en différents projets ou en sous-modules. Bien sûr, ce point doit être pris en compte conjointement avec le découpage technique et/ou fonctionnel.</p>

<p>Dans la suite de l'article, les termes &ldquo;<em>projet</em>&rdquo; et &ldquo;<em>module</em>&rdquo; sont utilisés au sens maven du terme. Pour avoir les vraies définitions, il est quand même préférable de se référer à la documentation officielle, mais voilà comment je les décrirai succinctement :</p>

<ul>
<li><strong>projet</strong> : il contient ses propres modules et produit un seul livrable (<em>assembly</em>, <em>war</em>, <em>ear</em> ou autre). Il peut éventuellement hériter d'un super pom.</li>
<li><strong>module</strong> : il s'agit d'un module maven ie. qu'il suit le même versionning que son père (pour rappel, les bonnes pratiques maven demandent à ce que les sous-modules d'un projet hérite de la version et du groupId du père). Le fait de builder le module parent build également les sous-modules. Concrètement, le père déclare ses modules fils avec l'élément <em>module</em> et le <em>module</em> fils déclare son père avec l'élément parent</li>
</ul>


<p>En fait, pour moi, la seule chose qui va décider de découper un projet (au sens large du terme) en modules ou en différents projets se résume en 3 mots : <strong>cycle de vie</strong> :</p>

<ul>
<li>Si lors de la relivraison d'un sous composant tout le système doit être relivré car dépendant du premier, alors les composants sont dans le même projet, ie. qu'ils sont des modules. Ils héritent alors de la version du père et ne doivent pas être relivré indépendamment.</li>
<li>S'il est possible de livrer indépendamment un composant du projet et que cela n'a pas foncièrement d'impact sur les autres, alors il doit être dans un projet indépendant. Les autres composants l'utilisant auront alors dans leur pom un numéro de version figée et le verrons comme une boite noire.</li>
</ul>


<p>Bien sûr, le fait de gérer des projets indépendants complexifie le processus de livraison ainsi que l'usine logicielle (au nombre de jobs jenkins, sonar &amp; co.) et c'est aussi pourquoi, souvent, les composants se retrouvent déclarer en modules d'un seul et unique projet.</p>

<p>Pourtant je pense que ce choix est une fausse bonne idée à terme et que la question du cycle de vie des différents composants est primordiale. En effet, découper en briques disposant de leur propre cycle de livraison force à découpler l'architecture du produit et oblige les équipes de développement à réfléchir sur le design.</p>

<p>De même, coté vision globale, cela force à réfléchir sur une cartographie du système (processus aussi appelé <strong>urbanisation</strong>) en se forçant à raisonner service (au sens large du terme) (<em>ndlr</em> : désolé mais pour ceux qui ne me connaissent pas, je viens du monde SOA&hellip; ).</p>

<p>Bien sûr, si le projet se limite à une simple application web disposant de son controleur, de sa couche présentation et de sa couche modèle, alors un &ldquo;simple&rdquo; projet disposant de ses sous-modules est largement suffisant, mais s'il s'agit de composants nécessaires à la gestion du SI au sens plus large, la question mérite à être posée.</p>

<p>Enfin, juste pour conclure cette partie, concernant le SCM, il doit être découpé en conséquence. Si c'est Git qui est utilisé, pas de souci. Par contre, si c'est SVN (ou autre), alors il est primodiale de respecter les préconisations de ce dernier, ie. de ne pas avoir tous les projets sous trunk mais que chaque projet dispose de ses sous répertoires <code>trunk/branches/tags</code>. En effet, un projet doit avoir sa propre hiérarchie de tags et de branches. De plus, techniquement parlant, il peut arriver que le fait d'utiliser le plugin release de maven produise des informations fausses au niveau de l'élément <code>scm</code>.</p>

<p>Exemple :</p>

<p>Le projet des décomposé comme suit :</p>

<p><img src="http://2.bp.blogspot.com/-tB997UpDKpA/UCvnxlx4G5I/AAAAAAAAAnc/9bD09UesmJ4/s1600/scm-projets2.png" alt="center" /></p>

<p>Alors les valeurs des éléments scm pour trunk seront les suivantes :</p>

<p>```text
projet1                          scm : trunk/projet1</p>

<pre><code>  projet11                   scm : trunk/projet1/projet11
</code></pre>

<p>projet2                          scm : trunk/projet2
```</p>

<p>Par contre, si le plugin release est utilisée (par exemple le goal branches), on aura  la valeur de l'élément scm pour branches projet11 qui sera la suivante :</p>

<p><img src="http://1.bp.blogspot.com/-0Ha4zM3jOGU/UCvo1B6DknI/AAAAAAAAAnk/6CJBHQurR3c/s1600/scm-projets.png" alt="center" /></p>

<p><code>text
projet11                  scm : branches/projet1/projet11
</code></p>

<p>On constate que la transformation de la valeur de l'élément scm pour le projet11 est erronée. Cela n'influe en rien le livrable, cependant, il devient alors impossible de créer une branche ou de faire une release du projet11 avec le plugin maven release&hellip;</p>

<h1>Conclusion</h1>

<p>Pour conclure cet article, on peut voir que le choix entre module et projet n'est pas si complexe que cela mais qu'il est préférable (et même, à mon sens, indispensable) de se poser les bonnes questions. Pour ma part, j'aurai tendance à dire que plus cela est tôt dans le projet, mieux c'est. Cependant, il faut se méfier de l'overdesign et trop de découpage peut tuer le découpage&hellip; Certaines personnes préfèrent, d'ailleurs, n'avoir qu'un seul projet décomposé en différent sous module puis, en fonction de l'avancée du projet, effectuer un découpage : c'est également une possibilité qui se veut aussi plus pragmatique.</p>

<p>Après chacun fait comme il l'entend et c'est une question de goût. Cependant, si on pousse ce raisonnement à l'extrème, pourquoi, dans ce cas, ne pas faire un découpage par package? : cela est plus simple, on ne s'embête pas à gérer différents poms et c'est encore plus pragmatique non? ;&ndash;)</p>

<p>Une fois encore, lecteur, je te laisse seul juge. A toi de te faire ta propre expérience et de juger le pour et le contre. Moi j'ai le mien ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Présentation sur les problématiques liées à une architecture distribuée]]></title>
    <link href="https://blog.jetoile.fr/2011/09/presentation-aux-problematiques-dune.html"/>
    <updated>2011-09-23T23:17:00+02:00</updated>
    <id>https://blog.jetoile.fr/2011/09/presentation-aux-problematiques-dune</id>
    <content type="html"><![CDATA[<p>Ci-dessous se trouve une présentation que j'ai donné sur les problématiques liées aux architectures distribuées. Pour information, c'est un retour d'expérience d'une mission qui date un peu puisque c'était en 2007 mais les préconisations restent identiques à ce jour.</p>

<p>Enjoy et n'hésitez pas à commenter ;&ndash;)</p>

<div id="__ss_9387145" style="width: 425px;">
<strong style="display: block; margin: 12px 0 4px;"><a href="http://www.slideshare.net/jetoile/introduction-sur-les-problmatiques-dune-architecture-distribue" target="_blank" title="Introduction sur les problématiques d'une architecture distribuée">Introduction sur les problématiques d'une architecture distribuée</a></strong> <iframe frameborder="0" height="355" marginheight="0" marginwidth="0" scrolling="no" src="http://www.slideshare.net/slideshow/embed_code/9387145" width="425"></iframe> <br />
<div style="padding: 5px 0 12px;">
View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/jetoile" target="_blank">jetoile</a> </div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Orchestration ou Routage?]]></title>
    <link href="https://blog.jetoile.fr/2010/04/orchestration-ou-routage.html"/>
    <updated>2010-04-07T11:55:20+02:00</updated>
    <id>https://blog.jetoile.fr/2010/04/orchestration-ou-routage</id>
    <content type="html"><![CDATA[<p><img src="http://petals.ow2.org/img/petals_logo.png" alt="left-small" /></p>

<p>Orchestration ou routage? Telle est la question qui se pose souvent&hellip; En effet, il est important de se poser la question sur la solution à adopter pour gérer, par exemple, des transformations ou du routage de messages dans un système asynchrone : s'agit-il de médiation technique ou de quelque chose de plus complexe (ie. de logique métier)?</p>

<p><a href="http://petals.ow2.org/">PEtALS Link</a> vient de mettre à disposition un <a href="http://www.petalslink.com/sites/default/files/rsc/docs/whitepapers/White_paper_Orchestration_0.2_122009.pdf">livre blanc</a> traitant du sujet en proposant différentes pistes pour choisir la solution d'implémentation.</p>

<p>D'ailleurs, j'en profite également pour mettre le <a href="http://parleys.com/#id=1892&amp;st=5&amp;sl=40">lien</a> vers la présentation de PEtALS ESB qui a eu lieu au <a href="http://www.poitoucharentesjug.org/">JUG de Poitou Charentes</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Integration vs. Apache Camel]]></title>
    <link href="https://blog.jetoile.fr/2010/03/spring-integration-vs-apache-camel.html"/>
    <updated>2010-03-15T23:29:48+01:00</updated>
    <id>https://blog.jetoile.fr/2010/03/spring-integration-vs-apache-camel</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/S56PashF4SI/AAAAAAAAAJA/OVagPG4D-g0/s320/apache_spring.png" alt="left-small" />
Lors d'un <a href="/2009/12/eip-quest-ce-que-cest.html">post précédent</a>, j'avais parlé des <a href="/blog/2009/12/13/eip-quest-ce-que-cest/">EIPs</a> (<strong>Enterprise Integration Patterns</strong>) en expliquant qu'il s'agissait de Patterns permettant de normaliser les échanges de messages dans un système asynchrone.</p>

<p>Dans cet article, je vais tenter de présenter succinctement deux de ses implémentations : <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> et [Apache Camel](<a href="https://camel.apache.org/.">https://camel.apache.org/.</a></p>

<p>En fait, pour être plus précis, je vais plutôt tenter de présenter la vision que j'en ai ainsi que la façon dont je les ai compris.</p>

<p>Ainsi, ce post n'a pas pour objectif de les détailler de manière exhaustive car ils sont trop complets pour cela et qu'un seul post ne pourrait suffire à les aborder tous les deux (leurs documentations font d'ailleurs, pour Spring Integration, plus de 130 pages, et pour Apache Camel, plus de 580 pages&hellip; cqfd&hellip; ;&ndash;) ) mais juste, comme je l'ai dit précédemment dit, d'aider à comprendre leurs différences (quelles soient conceptuelles ou structurelles).</p>

<p>Je ne reviendrai pas sur les concepts des EIPs ni de JBI que j'utiliserai dans la suite et pour cela, je vous renvoie sur internet ou sur mes posts précédents (<a href="/2009/12/eip-quest-ce-que-cest.html">ici</a> et <a href="/2009/12/jbi-une-solution-enterree.html">là</a>).</p>

<p>Concernant les versions utilisées, cela n'a pas vraiment son importance ici car je m'intéresserai surtout aux principes de ces deux frameworks mais à titre indicatif, il s'agit des versions 2.0 pour Apache Camel et 1.3.0 pour Spring Integration (il me semble qu'il n'y a pas de modifications flagrantes dans les versions courantes qui sont 2.2.0 pour Camel et 2.0.0.M2 pour Spring Integration).</p>

<!-- more -->


<h1>Les concepts</h1>

<h2>Apache Camel</h2>

<p>Apache Camel est un framework open-source qui est une implémentation des EIPs et qui propose pour sa configuration d'utiliser indifféremment :</p>

<ul>
<li>un fichier de configuration Spring (Spring DSL),</li>
<li>un DSL interne (Java DSL),</li>
<li>ou un DSL externe (Scala DSL).</li>
</ul>


<p>Cependant, il définit ses propres concepts qui diffèrent de ceux des EIPs mais qui restent assez similaires.</p>

<p>Ainsi, Apache Camel s'appuie sur la notion de routes (<strong>Route</strong>) qui relient deux points d'accès (<strong>Endpoint</strong>). Sur cette route transite des messages (<strong>Message</strong>) au travers d'échanges (<strong>Exchange</strong>). En fait un Exchange est le conteneur du message durant la phase de routage.</p>

<p>Ces points d'accès peuvent être de différents types et peuvent supporter différentes technologies telles que :</p>

<ul>
<li>une destination (Topic ou Queue) JMS,</li>
<li>un service web,</li>
<li>un fichier se trouvant sur le système de fichier,</li>
<li>un serveur FTP,</li>
<li>une adresse mail,</li>
<li>ou encore un POJO (<em>Plain Old Java Object</em>).</li>
</ul>


<p>Si l'on fait un parallèle avec JBI (<em>Java Business Integration</em>) (cf. <a href="/2009/12/jbi-une-solution-enterree.html">ici</a>), un <strong>Endpoint</strong> peut être vu comme une instance d'un <strong>Binding Component</strong>.</p>

<p>Une <strong>Route</strong> peut, quant à elle, être vue comme le chemin qu'emprunte le message d'un bout à l'autre de la chaîne de médiation. Ce chemin pouvant être entrecoupé par ce qu'on appelle des processeurs (<strong>Processor</strong>).</p>

<p>Apache Camel introduit également la notion de Composants (<strong>Component</strong>) à partir desquels les <strong>Endpoint</strong> sont issus (toujours pour faire un parallèle avec JBI, un <strong>Component</strong> peut être vu comme un <strong>Composant JBI</strong> en mode fournisseur ou consommateur).</p>

<p>Enfin, par composition à un <strong>Endpoint</strong>, Apache Camel utilise également les notions de <strong>Producer</strong> et <strong>Consumer</strong> qui permettent d'émettre (respectivement, recevoir) un message vers (resp. d') une application extérieure et qui peuvent être vu comme des <strong>Binding Component</strong> en mode fournisseur (resp. consommateur).</p>

<h1>Spring Integration</h1>

<p>Spring Integration appartient au portfolio de Spring Framework et étend le modèle de programmation de Spring mais dans le domaine de la messagerie. Il supporte l'architecture basée sur les messages (<em>Message-Driven Architecture</em>) où l'inversion de contrôle est utilisée pour les problématiques d'exécution comme, par exemple, quand doivent être appelés les composants métiers ou encore où doivent être envoyées les réponses. En outre, il offre des mécanismes de routage et de transformation de messages afin de permettre aisément l'utilisation de protocoles de transport et des types de messages hétérogènes. Il propose pour sa configuration d'utiliser soit un fichier de configuration Spring soit le mécanisme d'annotations.</p>

<p>Concernant ses concepts, ils collent parfaitement à ceux des EIPs puisque Spring Integration utilise la notion de :</p>

<ul>
<li><strong>Message</strong> dont la définition est identique à celle des EIPs,</li>
<li><strong>Message Channel</strong> dont la définition est identique à celle des EIPs,</li>
<li>et de <strong>Message Endpoint</strong> qui regroupe :

<ul>
<li>les Message Routing dont la définition est identique à celle de Routing des EIPs</li>
<li>les Message Transformation dont la définition est identique à celle de Transformation des EIPs</li>
<li>et les Message Endpoint dont la définition est identique à celle des EIPs</li>
</ul>
</li>
</ul>


<h1>Mon avis avant utilisation</h1>

<h2>Apache Camel</h2>

<p>Apache Camel est un framework issu de l'implémentation JBI Apache ServiceMix et qui est également utilisé dans OpenESB. Cela peut expliquer pourquoi ses concepts sont si proches de ceux de JBI (ou du moins que les modèles sont si facilement transposables). Cependant, à mon sens, même si ses concepts sont proches de ceux de JBI, les termes utilisés sont différents et, pour ceux qui connaissent JBI, un effort d'apprentissage supplémentaire doit être fait. En outre, la documentation d'Apache Camel est loin d'être aisée à lire et retrouver de l'information dans le wiki qui lui sert de documentation s'achèvent généralement avec des cheveux en moins, une souris torturée ou un écran ébréché&hellip; le tout accompagné par une flopée d'injures&hellip;</p>

<p>Ainsi, à mon avis, pour un produit qui se veut être une implémentation des EIPs, il faut :</p>

<ul>
<li>d'une part, lire ou se familiariser avec les EIPs</li>
<li>et d'autre part, connaitre JBI ou, au moins, se familiarisé avec les concepts d'Apache Camel (comprendre la différence entre un composant, un endpoint qui est lui-même un processeur, les éléments pipeline et multicast qui sont eux-même des processeurs, etc, etc, etc&hellip;). Rien d'insurmontable mais il est quand même nécessaire de se faire quelques nœuds au cerveau&hellip;</li>
</ul>


<p>Par contre, par rapports aux EIPs, Apache Camel masque la notion de Channel, ce qui peut s'avérer plaisant.</p>

<h2>Spring Integration</h2>

<p>Spring Integration est un projet du portfolio Spring donc très propre, avec une documentation très bien faite et pas trop longue&hellip; En outre, pour quelqu'un qui est déjà familiarisé avec les EIPs, la prise en main de Spring Integration est immédiate. Le fait qu'il s'appuie sur Spring (tout comme Apache Camel d'ailleurs) permet une courbe d'apprentissage rapide.</p>

<h1>Mon avis après utilisation</h1>

<h2>Apache Camel</h2>

<p>Apache Camel s'avère ardu à prendre en main malgré un forum actif. Cela en raison de sa documentation un peu (complètement?) fouillis mais également parce qu'il est possible de faire la même chose de multiples manières, ces manières ayant chacunes ses limitations. Si on utilise le framework simplement avec une description XML et des POJOs (qui sont, parfois, fortement couplé au framework Apache Camel au travers de son API (Exchange, Endpoint, &hellip;) &hellip; pas très propre tous ça&hellip; :( ), on peut arriver sans trop de douleur à faire ce que l'on veut. Par contre, si on se lance dans les DSLs internes ou externes (et même si j'aime bien le principe des DSLs&hellip;), cela n'exclue pas l'adhérence des POJOs à l'API d'Apache Camel et il est souvent nécessaire de faire intervenir la notion d'Exchange dans les signatures des méthodes.</p>

<p>En outre, on se rend rapidement compte que la majorité des classes de l'API héritent de l'interface <code>Processor</code>. Pourquoi cela me pose problème? et bien parce que j'estime qu'il est bizarre et peu naturel que certaines classes comme Pipeline ou MulticastProcessor implémente (directement ou indirectement) Processor ou alors il aurait, au moins, été préférable de mettre ce type de classes dans un autre package que celui où se trouvent des classes comme Aggregator, FileProcessor, Resequencer ou encore RecipientList. Bon, je comprends qu'Apache Camel a été pensé dès le départ pour offrir une configuration simple à base de DSL et que, du coup, il a été nécessaire de faire certaines concessions mais lorsque l'on rentre dans le code du framework, ce n'est pas (et cela ne concerne que moi) une impression de propreté qui en ressort&hellip;</p>

<p>Un autre point qui m'interpelle est le fait que lors de l'écriture des règles de médiations, il n'y a pas de différences sémantiques entre les différentes notions qu'offrent les EIPs : les Message Transformation, Message Routing ou Service Activator se représentent tous comme des Processor ou des Bean. Je trouve cela dommage de perdre la classification (qu'on aime ou pas) fournit par les EIPs et qui, à mon sens, permettait justement de clarifier toutes les notions utiles pour gérer les échanges de messages dans un système asynchrone.</p>

<p>Par contre, comme je l'ai dit précédemment, il est vraiment appréciable de ne pas à avoir à déclarer ses propres Channels qui sont masqués par la notion de Route.</p>

<h2>Spring Integration</h2>

<p>Spring Integration est extrèmement simple à prendre en main et son forum est très actif. La documentation est claire et c'est vrai qu'il est appréciable de pouvoir utiliser les notions des EIPs directement.</p>

<p>Les annotations sont parlantes et les éléments (service-activator, splitter, filter, resequencer, aggregator, transformer, router, &hellip;) à utiliser dans le fichier de configuration Spring permettent de classifier rapidement les différents éléments se trouvant dans la chaine de médiations.</p>

<p>En outre, le code interne du framework est propre et permet de masquer la complexité des différents Message Endpoint.</p>

<h1>Conclusion</h1>

<p>Vous l'aurez compris, j'ai une petite préférence pour Spring Integration&hellip;</p>

<p>Cependant, je dirai que le choix dépend aussi grandement de l'utilisation qu'on veut en faire (bon ok, je ne me mouille pas trop&hellip; ;&ndash;) ) :</p>

<ul>
<li>dans un ESB type ServiceMix ou OpenESB, il peut être préférable d'utiliser Apache Camel en raison de sa capacité à être configurée via un DSL qui peut être plus aisé que de manipuler des Channels et des fichiers XML,</li>
<li>par contre, pour les autres cas, je conseillerai plutôt Spring
Integration pour son modèle de programmation et ses concepts plus
simple&hellip;</li>
</ul>


<p>mais là, je conseillerai à chacun de se faire sa propre idée&hellip;</p>

<p>Un petit mot en plus sur les points non abordés ci-dessus :</p>

<ul>
<li>les mécaniques offertes pour manipuler des messages au format XML (XPath, &hellip;),</li>
<li>la gestion des erreurs,</li>
<li>le nombre de connecteurs fournis par ces derniers.</li>
</ul>


<p>Sur ces deux derniers points, l'avantage va indéniablement à Apache Camel même s'il est aisé (modulo la connaissance du protocole utilisé) d'en redéfinir avec Spring Integration en utilisant un Service Activator mais, dans ce cas, il faut le faire à la main.</p>

<p>Pour le premier point, je ne dirai rien car je n'ai pas eu l'occasion de l'utiliser&hellip;</p>

<p>Enfin, il ne faut pas oublier que ces frameworks ont pour but principal d'offrir un moyen de faire de la médiation technique et non de gérer une orchestration de processus métier et que pour cette raison, ils doivent être utilisés à bon escient.</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li><strong>SOA : le guide de l’architecte</strong> de X. Fourner-Morel, P. Grojean, G. Plouin et C. Rognon chez Dunod</li>
<li><strong>Enterprise Integration Patterns</strong> de G. Hohpe et B. Woolf chez Addisson Wesley</li>
<li>Site de Spring Integration : <a href="http://www.springsource.org/spring-integration">http://www.springsource.org/spring-integration</a></li>
<li>API de Spring Integration : <a href="http://static.springframework.org/spring-integration/apidocs/">http://static.springframework.org/spring-integration/apidocs/</a></li>
<li>Manuel de référence de Spring Integration : <a href="http://docs.spring.io/spring-integration/docs/4.0.0.M3/reference/html/">http://docs.spring.io/spring-integration/docs/4.0.0.M3/reference/html/</a></li>
<li>Site d'Apache Camel : <a href="http://camel.apache.org/">http://camel.apache.org/</a></li>
<li>API d'Apache Camel : <a href="http://camel.apache.org/javadoc.html">http://camel.apache.org/javadoc.html</a></li>
<li>Manuel de référence d'Apache Camel : <a href="http://camel.apache.org/manual.html">http://camel.apache.org/manual.html</a></li>
<li>Spécification de JBI : <a href="http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html">http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html</a></li>
<li>Blog de Xebia sur les ESB légers : <a href="http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/">http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/</a></li>
<li>Blog de Xebia sur une revue de presse d'un article sur Spring Integration et Apache Camel : <a href="http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel">http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
