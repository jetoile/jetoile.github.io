---
layout: post
title: "RTFM ou de l'importance de savoir lire une documentation"
date: 2010-05-15
comments: false
categories:
 - java
 - réflexion
---

<div class='post'>
<div class="separator" style="clear: both; text-align: justify;"><a href="http://farm1.static.flickr.com/100/291194341_5d141633c8.jpg" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="200" src="http://farm1.static.flickr.com/100/291194341_5d141633c8.jpg" width="200" /></a></div><div style="text-align: justify;">Ce petit article est plus une tranche de vie ayant pour objectif de montrer l'importance de savoir lire une documentation qu'un "vrai" post intéressant... </div><div style="text-align: justify;">Il est vrai que savoir trouver son information s'applique énormément dans le monde Open Source où il est crucial de savoir fouiller (documentation, forum, ...) lorsqu'un fait technique (anomalie? framework incomplet? cas d'usage délirant? ...) a lieu mais cela s'applique aussi dans notre vie de programmeur de tous les jours.</div><!-- more --><br /><div style="text-align: justify;">&nbsp; </div><div style="text-align: justify;">Bien sur, le monde Open Source n'est pas le seul où doit s'appliquer ce principe.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Je vais donc raconter mon anecdote (stupide, j'en conviens donc soyez indulgent avec moi)...</div><h1>Contexte</h1><div style="text-align: justify;">Alors que j'étais tranquillement en train de farfouiller dans le code source du projet sur lequel je travaille, je tombe sur le code suivant (j'ai élagué le contrôle de la taille de mon tableau pour éviter d'alourdir les exemples...) :</div><div style="text-align: justify;"><pre class="brush:java; wrap-lines: false; auto-links: false">&nbsp;&nbsp;&nbsp; static public String[] troncateString(String[] input) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int inputSize = input.length;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String[] output = new String[inputSize - 1];<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 1; i &lt; inputSize; i++) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; output[i-1] = input[i];<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return output;<br />&nbsp;&nbsp;&nbsp; }</pre></div><div style="text-align: justify;">Là, je me dis : mais qu'est ce que c'est que ça!!!... je commence alors à m'agiter sur ma chaise et je me dis, tiens, n'y aurait-t-il pas un petit gain en passant par une Collection. Essayons! J'écris alors un petit programme de test : </div><div style="text-align: justify;"><pre class="brush:java; wrap-lines: false; auto-links: false">&nbsp;&nbsp;&nbsp; static public String[] troncateString2(String[] input) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; List&lt;String&gt; output = Arrays.asList(input);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; output.remove(0);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return output.toArray(new String[0]);<br />&nbsp;&nbsp;&nbsp; }</pre></div><div style="text-align: justify;">Je le lance confiant, et là, c'est la douche froide : un horrible message s'affiche :  </div><div style="text-align: justify;"><pre class="brush:bash; wrap-lines: false; auto-links: false">Exception in thread "main" java.lang.UnsupportedOperationException<br />&nbsp;&nbsp;&nbsp; at java.util.AbstractList.remove(AbstractList.java:144)<br />&nbsp;&nbsp;&nbsp; at Test.troncateString2(Test.java:21)</pre></div><div style="text-align: justify;">Je me dis alors : Mince, qu'est ce que j'ai encore fait comme bêtise... (je vous le fais en version censurée là... ;-)) Je prends donc mon ami la javadoc et je vérifie rapidement la méthode asList, je ne vois toujours rien... J'ajoute alors un getClass() qui me sort un class java.util.Arrays$ArrayList... bizarre...  En désespoir de cause, je me dis : allez, faisons un petit F3 (je suis sous eclipse) pour aller voir les entrailles de la bête. J'obtiens donc : </div><div style="text-align: justify;"><pre class="brush:java; wrap-lines: false; auto-links: false">&nbsp;&nbsp;&nbsp; public static &lt;T&gt; List&lt;T&gt; asList(T... a) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new ArrayList&lt;T&gt;(a);<br />&nbsp;&nbsp;&nbsp; }</pre></div><div style="text-align: justify;">puis ça : </div><div style="text-align: justify;"><pre class="brush:java; wrap-lines: false; auto-links: false">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;<br />&nbsp;&nbsp;&nbsp; implements RandomAccess, java.io.Serializable<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; private static final long serialVersionUID = -2764017481108945198L;<br />&nbsp;&nbsp;&nbsp; private final E[] a;<br /><br />&nbsp;&nbsp;&nbsp; ArrayList(E[] array) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (array==null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new NullPointerException();<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a = array;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; ...<br />}</pre></div><div style="text-align: justify;">Je cherche alors ma méthode remove() mais ne la trouve pas... tous s'explique : mon horrible UnsupportedOperationException vient de AbstractList...  Mais pourquoi Sun a-t-il fait un truc aussi bizarre que de redéfinir son ArrayList en inner class de Arrays et en plus en n'implémentant pas certaines méthodes susceptibles de créer des erreurs au Runtime... ? Je râle, je vais en parler à un collègue et là, il me dit : ben oui, dans la javadoc, il est indiqué la chose suivante : </div><div style="text-align: justify;"><blockquote>Returns a fixed-size list backed by the specified array.</blockquote></div><div style="text-align: justify;">En plus, première ligne... je n'avais pas lu le fixed-size... :(  Voilà, conclusion, 15 minutes de perdu... tout ça parce que, trop confiant, je n'ai pas lu consciencieusement la documentation. Bien sûr, cela s'applique à tous types de cas et cette anecdote n'en est qu'un exemple... (il n'empêche que je trouve quand même cela vraiment trompeur cette méthode asList... :( ).<br /><br />[<b>update </b>: un collègue m'a fait remarqué que je n'avais pas été très précis quant au pourquoi du comment j'avais eu cette erreur... : le fait que la classe interne ArrayList de Arrays n'implémente pas la méthode <i>remove()</i> implique que c'est l'implémentation de la méthode <i>remove()</i> de AbstractList qui est utilisée. Cette méthode lançant un <i>UnsupportedOperationException</i>, c'est donc ce qui remonte. Ce choix ayant été fait en raison de la volonté de renvoyer un ArrayList de taille fixe et donc de ne pas implémenter cette méthode.]</div><h1>Conclusion</h1><div style="text-align: justify;">Lisez la documentation lorsqu'un problème se présente. Si vous ne le faites pas, et si vous "osez" poser la question sur un forum sans recherche préalable, ne vous vexez pas si comme toute réponse vous obtenez un jolie RTFM... En outre, le risque pour vous est de vous faire "griller" sur le forum où plus personne ne daignera vous répondre. De même, quoi de plus énervant quand un collègue vous pose une question alors qu'un simple coup de google aurait pu le renseigner et, en plus, si cela vous a fait perdre votre idée alors que vous veniez de trouver la solution du siècle! ;-) </div><h1>Epilogue</h1><div style="text-align: justify;">Ci-joint le code que j'aurai dû utiliser : </div><div style="text-align: justify;"><pre class="brush:java; wrap-lines: false; auto-links: false">&nbsp;&nbsp;&nbsp; static public String[] troncateString(String[] input) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; List&lt;String&gt; output = new ArrayList&lt;String&gt;(Arrays.asList(input));<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; output.remove(0);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return output.toArray(new String[0]);<br />&nbsp;&nbsp;&nbsp; }</pre></div><div style="text-align: justify;">A noter que j'aurais également pu faire un simple : </div><div style="text-align: justify;"><pre class="brush:java; wrap-lines: false; auto-links: false">&nbsp;&nbsp;&nbsp; static public String[] troncateString(String[] input) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Arrays.copyOfRange(input, 1, input.length);<br />&nbsp;&nbsp;&nbsp; }</pre></div><div style="text-align: justify;">Ce qui me donne au final les résultats suivants pour un tableau de String de 100000 éléments (Jdk 1.6) : </div><div style="text-align: justify;"><pre class="brush:bash; wrap-lines: false; auto-links: false">time : 11 == version avec boucle for et décalage<br />time : 9 == version avec utilisation d'une liste intermédiaire<br />time : 2 == version avec le copyOfRange</pre></div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Eric</div>
<div class='content'>
Trop d&#39;humilité tue l&#39;humilité Khanh...<br />Ceci étant dit, RTFM n00b !</div>
</div>
</div>
