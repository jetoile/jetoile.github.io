<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: spring integration | Jetoile]]></title>
  <link href="http://blog.jetoile.fr/blog/categories/spring-integration/atom.xml" rel="self"/>
  <link href="http://blog.jetoile.fr/"/>
  <updated>2015-10-09T15:28:38+02:00</updated>
  <id>http://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lecture et traitement de fichiers : comment faire simple?]]></title>
    <link href="http://blog.jetoile.fr/2014/04/lecture-et-traitement-de-fichiers-comment-faire-simple.html"/>
    <updated>2014-04-10T14:15:44+02:00</updated>
    <id>http://blog.jetoile.fr/2014/04/lecture-et-traitement-de-fichiers-comment-faire-simple</id>
    <content type="html"><![CDATA[<p><img src="/images/batch/logo.png" alt="left-small" /></p>

<p>De nombreuses applications ou systèmes d'informations nécessitent le chargement de données issues de fichiers.</p>

<p>Bien souvent, cet import est exécuté par <em>batch</em>, mais il peut aussi être intéressant de faire cet import au fil de l'eau.</p>

<p>En outre, bien souvent, les fichiers à importer sont, soient nombreux, soient volumineux. Du coup, écrire un code simple et fiable peut devenir plus ardu que ce qu'il n'y parait. Si, de plus, on veut ajouter des logs parlant (c'est à dire avec, au minimum, le temps de traitement d'un fichier et son nom), cela a tendance a rajouter du bruit au code. Sans oublier que lire un fichier est bien mais que, souvent, un traitement est effectué dessus&hellip;</p>

<p>Enfin, lors d'une forte volumétrie, une scalabilité horizontale peut être intéressante surtout dans le contexte actuel où la quantité d'information vient à exploser.</p>

<p>Cet article parlera donc de la problématique d'import de fichiers dans une application en s'appuyant sur des framework comme <a href="http://projects.spring.io/spring-batch/">Spring Batch</a> ou <a href="http://projects.spring.io/spring-integration/">Spring Integration</a>. Le mot d'ordre sera de le faire le plus simplement possible en s'appuyant au maximum sur ces framework.</p>

<!-- more -->


<h1>Solution à base de <em>batch</em></h1>

<p>Ecrire un batch permettant de traiter des fichiers peut sembler simple mais lorsque le nombre de ces derniers vient à augmenter ou lorsque la taille des fichiers est volumineux, il arrive souvent que des bugs apparaissent. En outre, il convient alors de gérer manuellement les logs ainsi que la partie supervision.</p>

<p>Pour répondre à ce besoin, il est peut être avantageux d'utiliser <a href="http://projects.spring.io/spring-batch/">Spring Batch</a> (ou une autre implémentation de la <a href="https://jcp.org/en/jsr/detail?id=352">JSR 352</a>).</p>

<p><em>ndlr</em> : je ne présenterai pas le fonctionnement de Spring Batch à base de <strong>Job</strong> et <strong>Step</strong> puisque cela se trouve très facilement dans les documents officiels, livres ou articles de blog et je mettrai plutôt l'accent sur la faisabilité de tel ou tel chose.</p>

<p><img src="/images/batch/spring-batch-reference-model.png" title="crédit photo : http://docs.spring.io/spring-batch/trunk/reference/html-single/index.html" alt="center" /></p>

<p>Spring Batch offre nativement la possibilité de traiter les fichiers par <em>chunk</em> via :</p>

<ul>
<li><code>FlatFileItemReader</code> qui permet de lire un fichier plat ligne par ligne et où chaque ligne dispose de la même information (il est également possible de traiter des types de lignes différentes issues du même fichier avec <code>PatternMatchingCompositeLineMapper</code>).</li>
<li><code>StaxEventItemReader</code> pour lire fichiers xml composés de format de <em>fragments</em> identiques :
<img src="/images/batch/xmlinput.png" title="crédit photo : http://docs.spring.io/spring-batch/trunk/reference/html-single/index.html" alt="center" /></li>
</ul>


<p>avec :</p>

<p>```xml
<bean id="itemReader" class="org.springframework.batch.item.xml.StaxEventItemReader"></p>

<pre><code>&lt;property name="fragmentRootElementName" value="trade" /&gt;
&lt;property name="resource" value="data/iosample/input/input.xml" /&gt;
&lt;property name="unmarshaller" ref="tradeMarshaller" /&gt;
</code></pre>

<p></bean></p>

<p>&lt;bean id=&ldquo;tradeMarshaller&rdquo;</p>

<pre><code>  class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
&lt;property name="aliases"&gt;
    &lt;util:map id="aliases"&gt;
        &lt;entry key="trade"
               value="org.springframework.batch.sample.domain.Trade" /&gt;
        &lt;entry key="price" value="java.math.BigDecimal" /&gt;
        &lt;entry key="name" value="java.lang.String" /&gt;
    &lt;/util:map&gt;
&lt;/property&gt;
</code></pre>

<p></bean>
```</p>

<p>Généralement, il est nécessaire de préciser le nom du fichier à traiter mais il est également possible d'en traiter plusieurs de même type dans la même <em>Step</em> via la classe <code>MultiResourceItemReader</code>.</p>

<p>```xml
<bean id="multiResourceReader" class="org.springframework.batch.item.file.MultiResourceItemReader"></p>

<pre><code>&lt;property name="resources" value="classpath:data/input/file-*.txt" /&gt;
&lt;property name="delegate" ref="flatFileItemReader" /&gt;
</code></pre>

<p></bean>
```</p>

<p>Spring Batch supporte également la scalabilité horizontale en permettant de préciser un <code>taskExecutor</code> au niveau de la <em>Step</em>.</p>

<p>```xml
<step id="loading"></p>

<pre><code>&lt;tasklet task-executor="taskExecutor"&gt;...&lt;/tasklet&gt;
</code></pre>

<p></step>
```</p>

<p>Ainsi, on constate que Spring Batch offre nativement la possibilité de traiter des fichiers volumineux en les découpant par <em>chunk</em>.</p>

<p>De même, il offre nativement la possibilité de passer sur du traitement parallèle.</p>

<p>Concernant la partie supervision, vu que l'on est dans un environnement Spring, on bénéficie, bien sûr, de toute la partie JMX.</p>

<p>Pour la partie gestion des erreurs, Spring Batch permet de les gérer de manière très simple.</p>

<p>Cependant, on perd un grand intérêt si, par fichier, il n'y a qu'une seule donnée. En effet, le mécanisme de <em>chunk</em> devient alors inutile. Il reste cependant possible d'utiliser la scalabilité horizontale.</p>

<p>Concernant la partie log, j'avoue ne pas avoir creuser, je ne dirai donc rien sur ce point&hellip;</p>

<h1>Solution à base d'EIP</h1>

<p>Dans le cas où la volonté serait de traiter les fichiers au fil de l'eau, Spring Batch n'est pas la solution la plus adaptée&hellip;</p>

<p>Cependant, Spring Integration répond à ce besoin de manière très simple.</p>

<p>En effet, en utilisant un simple <strong>Service Activator</strong> (au sens EIP) de type <code>inbound-channel-adapter</code>, il devient alors possible de <em>poller</em> un répertoire et d'envoyer le contenu du fichier vers un <em>filter</em> (au sens EIP).</p>

<p>```xml
&lt;file:inbound-channel-adapter id=&ldquo;fileAdapter&rdquo; auto-startup=&ldquo;true&rdquo; auto-create-directory=&ldquo;true&rdquo;</p>

<pre><code>                          filename-pattern="*.xml"
                          directory="file:/tmp"
                          scanner="recursiveScanner"
                          prevent-duplicates="true"
                          channel="inputChannel"&gt;
&lt;int:poller fixed-delay="30000" max-messages-per-poll="500"/&gt;
</code></pre>

<p>&lt;/file:inbound-channel-adapter></p>

<p>&lt;file:file-to-string-transformer charset=&ldquo;UTF-8&rdquo; delete-files=&ldquo;true&rdquo; input-channel=&ldquo;inputChannel&rdquo;</p>

<pre><code>                                 output-channel="toLogger"/&gt;
</code></pre>

<p>&lt;int:logging-channel-adapter auto-startup=&ldquo;true&rdquo; channel=&ldquo;toLogger&rdquo; level=&ldquo;DEBUG&rdquo; log-full-message=&ldquo;true&rdquo;/></p>

<p>&lt;int:channel id=&ldquo;inputChannel&rdquo;/>
&lt;int:channel id=&ldquo;toLogger&rdquo;/>
```</p>

<p>D'un point de vue scalabilité horizontale, il suffit de renseigner (tout comme pour Spring Batch) un <code>taskExecutor</code> au niveau du <em>Channel</em> et&hellip; c'est tout!</p>

<p>```xml
&lt;task:executor id=&ldquo;someExecutor&rdquo;</p>

<pre><code>               pool-size="20"
               keep-alive="2400"/&gt;
</code></pre>

<p>&lt;int:channel id=&ldquo;toLogger&rdquo;></p>

<pre><code>&lt;int:dispatcher task-executor="someExecutor"/&gt;
</code></pre>

<p>&lt;/int:channel>
```</p>

<p>Enfin, disposer d'une supervision est des plus aisé puisqu'il suffit de rajouter l'élément <code>message-history</code> :</p>

<p><code>xml
&lt;int:message-history/&gt;
</code></p>

<p>L'ajout de cet élément indique à Spring Integration qui doit ajouter automatiquement dans le <em>header</em> du message le temps d'exécution de chaque <em>Filter</em>. Concernant le nom du fichier et son chemin, il se trouve renseigner automatiquement dans le header par l'<em>adapter</em> <code>file:inbound-channel-adapter</code>.</p>

<p>Coté gestion des erreurs, Spring Integration permet de les gérer très simplement sur le principe du canal d'erreur qui peut récupérer tous les messages en erreur.</p>

<p>Cependant, avec Spring Integration, si le fichier est volumineux, il n'est plus possible de le traiter en <em>chunk</em> et un risque de contention mémoire existe.</p>

<h1>Solution à base d'EIP et de batch</h1>

<p>On a vu dans les deux paragraphe précédent que Spring Integration était une très bonne solution pour traiter des fichiers au fil de l'eau alors que Spring Batch était plutôt orienté traitement par batch.</p>

<p>Cependant, il est très facile de composer les 2 modes. Cela permet, par exemple, de déclencher un traitement d'un fichier volumineux dès sa réception (via Spring Integration) et de bénéficier du mode <em>chunk</em> de Spring Batch pour le traitement.</p>

<p>Dans ce cas, bien sûr, il n'est pas question de faire de traitement sur le contenu du fichier dans la partie Spring Integration (seul l'objet <code>File</code> est transmis dans le corps du message) et c'est le jobs Spring Batch qui s'occupera du traitement à proprement parler.</p>

<p>Cela engendre peut être un <em>overhead</em> conséquent mais on est, au moins sûr, d'éviter le <em>Out Of Memory</em> dans le cas de fichiers volumineux. En outre, cela permet de bénéficier de la puissance des EIP (routage ou filtrage sur le nom du fichier par exemple) tant que le fichier n'a pas à être chargé.</p>

<p><img src="/images/batch/archi_combo.png" alt="large" /></p>

<h1>Conclusion</h1>

<p>On a vu dans cet article comment il pouvait être trivial de traiter l'import de fichiers sans avoir à gérer manuellement des pools de thread ou des logs d'audit.</p>

<p>Je ne suis pas rentré dans les détails mais mon objectif était surtout de montrer qu'en utilisant les bons outils/framework, il était possible de produire du code minimaliste et donc moins propice aux erreurs.</p>

<p>Pour avoir mis en oeuvre ces solutions, je peux vous assurer que le code écrit (ainsi que le temps passé) était minimaliste sinon nul (si on considère qu'écrire du xml n'est pas du code&hellip;). Bien sûr, je ne parle pas du code de traitement qui doit être écrit quoiqu'il arrive mais, encore une fois, le fait d'expédier la partie plomberie a permis de se concentrer sur le réel besoin métier.</p>

<p>Enfin, il est important de préciser que dans certains cas, une telle approche ne fonctionnera pas (si un fichier contient, par exemple, des dépendances à des données issues d'autres fichiers) et qu'il peut même être dangereux de vouloir absoluement utiliser ce type de framework au risque de leur faire faire des choses pour lesquelles ils ne sont pas prévus&hellip; Par exemple, il ne faut pas oublier que dans <strong>EIP</strong>, le <strong>I</strong> signifie Intégration!! Si le besoin est autre, il est fortement recommandé d'utiliser autre chose ou de le faire manuellement mais, par pitié, ne tordez pas le coup aux outils&hellip;! (si si, je l'ai vu&hellip; d'où mon désarroi&hellip;).</p>

<p><em>ndlr</em> : bon, j'admets que la partie qui a dû être la plus longue a sûrement été le <em>tuning</em> du pool de thread afin de tirer le meilleur partie de la machine mais, même si cela avait été fait de manière programmatique, cela aurait été nécessaire&hellip;</p>

<p><em>ndlr</em> : j'ai parlé, dans cet article, de Spring Integration pour la partie EIP mais il est tout aussi simple d'utiliser Apache Camel.</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li><strong>Spring Integration in Action</strong> de Mark Fisher, Jonas Partner, Marius Bogoevici et Iwein Fuld chez Manning</li>
<li><strong>Camel in Action</strong> de Claus Ibsen et Jonathan Anstey chez Manning</li>
<li><strong>Spring Batch in Action</strong> de Arnaud Cogoluegnes, Thierry Templier, Gary Gregory et Olivier Bazoud chez Manning</li>
<li><strong>Enterprise Integration Patterns</strong> de G. Hohpe et B. Woolf chez Addisson Wesley</li>
<li><a href="http://www.eaipatterns.com/">http://www.eaipatterns.com/</a></li>
<li><a href="http://projects.spring.io/spring-integration/">http://projects.spring.io/spring-integration/</a></li>
<li><a href="http://projects.spring.io/spring-batch">http://projects.spring.io/spring-batch</a></li>
<li><a href="http://www.technologies-ebusiness.com/langages/spring-batch-spring-integration-une-usine-de-batchs-a-moindre-cout">http://www.technologies-ebusiness.com/langages/spring-batch-spring-integration-une-usine-de-batchs-a-moindre-cout</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAXRS, Netty4 et Spring Integration : ils reviennent et ils ne sont pas content!]]></title>
    <link href="http://blog.jetoile.fr/2014/03/jaxrs-netty4-et-spring-integration-ils.html"/>
    <updated>2014-03-24T19:12:29+01:00</updated>
    <id>http://blog.jetoile.fr/2014/03/jaxrs-netty4-et-spring-integration-ils</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/-XR47rmCwXK0/Ux8gpmR-TLI/AAAAAAAABR0/T1h_RtvDED0/s1600/resteasy_jolokia_metrics_orig3.png" alt="left-small" /></p>

<p>Pour faire suite à mes articles <a href="/2014/03/jaxrs-netty-et-bien-plus-encore-mode.html">resteasy-netty</a> et <a href="/2014/03/jaxrs-netty-4-jackon-2-les-memes-mais.html">resteasy-netty4</a>, nous allons voir, dans cet article, comment il est possible de créer un service activator avec <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> qui exposera via resteasy-netty4 un service REST.</p>

<p>Ce service REST esposera simplement une opération en POST qui, via Spring Integration, écrira dans un fichier et qui, pour le fun, écrira également sur la console.</p>

<p>Pour ce faire, rien de plus simple, un <a href="http://www.eaipatterns.com/MessagingAdapter.html">Service Activator</a> de type <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">gateway</a> a été utilisé.</p>

<p>Cet article montrera donc comment il est possible d'intégrer Spring Integration à notre petite stack basé sur Resteasy-Netty4, Jackson, <a href="http://metrics.codahale.com/">Metrics</a>, <a href="https://helloreverb.com/developers/swagger">Swagger</a> et <a href="http://www.jolokia.org/">Jolokia</a>.</p>

<p>Le code se trouve sur Github <a href="https://github.com/jetoile/spring-integration-netty4">ici</a>.</p>

<!-- more -->


<h1>Présentation du usecase</h1>

<p>Le service qui est exposé est un service de type REST répondant à un appel de type POST et acceptant du JSON.</p>

<p>Il répondra à une requête de type :
<code>bash
curl -XPOST -H "Content-Type: application/json" -d '{"message": "hello", "time": "2014-03-05T10:55:39.835+01:00"}'  http://127.0.0.1:8081/sample/write
</code>
et écrira un fichier par requête reçue dans le répertoire <code>/tmp</code>. En outre, il loggera sur la console le message reçu.</p>

<p>Ainsi, avec la commande suivante, on devrait voir un incrément du nombre à chaque réception de message.
<code>bash
watch 'ls *.msg | wc -l'
</code></p>

<h1>Mise en oeuvre</h1>

<h2>Dépendances</h2>

<p>A titre informatif, les dépendances ainsi que leurs versions sont les suivantes (au format gradle) :
```text
dependencies {</p>

<pre><code>compile group: 'org.springframework.integration', name: 'spring-integration-core', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-jmx', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-http', version:'3.0.1.RELEASE'
compile group: 'org.springframework.integration', name: 'spring-integration-file', version:'3.0.1.RELEASE'
compile group: 'io.netty', name: 'netty-all', version:'4.0.17.Final'
compile group: 'org.jboss.resteasy', name: 'jaxrs-api', version:'3.0.4.Final'
compile group: 'org.jolokia', name: 'jolokia-spring', version:'1.1.2'
compile group: 'com.wordnik', name: 'swagger-jaxrs_2.10', version:'1.3.0'
compile group: 'com.wordnik', name: 'swagger-annotations_2.10', version:'1.3.0'
compile group: 'javax.servlet', name: 'servlet-api', version:'2.5'
compile group: 'com.ryantenney.metrics', name: 'metrics-spring', version:'3.0.0-RC4'
compile group: 'org.jboss.resteasy', name: 'resteasy-netty4', version:'3.0.6.Final'
compile group: 'org.jboss.resteasy', name: 'resteasy-jackson-provider', version:'3.0.6.Final'
compile group: 'commons-configuration', name: 'commons-configuration', version:'1.9'
compile group: 'commons-collections', name: 'commons-collections', version:'3.2.1'
compile group: 'commons-io', name: 'commons-io', version:'2.4'
compile group: 'joda-time', name: 'joda-time', version:'2.3'
compile(group: 'com.google.guava', name: 'guava', version:'15.0') {exclude(module: 'jsr305')}
</code></pre>

<p>}
```</p>

<p>Pour le lecteur averti, il constatera que la version de Jackson utilisé ici est la 1 (ie. avec le groupId <strong>org.codehaus</strong>). En effet, Jackson 2 et JodaTime m'ont fait des misères et je n'ai pas réussi à les résoudre rapidement, donc, par flemme, je suis repassé en version 1&hellip; ;&ndash;)</p>

<h2>DTO</h2>

<p>Un DTO annoté JAX-B (compris par Jackson) sera utilisé pour représenter le JSON reçu dans le corps du POST.</p>

<p>Il se présente comme suit :
```java
@XmlRootElement
public class DtoRequest {</p>

<pre><code>private String message;
private DateTime time;

public String getMessage() { return message; }

public void setMessage(String message) { this.message = message; }

public DateTime getTime() { return time; }

public void setTime(DateTime time) { this.time = time; }

@Override
public String toString() {
    return "DtoRequest{" +
            "message='" + message + '\'' +
            ", time=" + time +
            '}';
}
</code></pre>

<p>}
```</p>

<p>Ici, la méthode <code>toString()</code> a été overridé car utilisé lors de l'affichage du message par le loggueur sur la console.</p>

<p>Jusque là, ça ne casse pas trois pattes à un canard ;&ndash;)</p>

<h2>Intégration complète de Spring Integration</h2>

<p>Pour rappel, Spring Integration est une implémentation des <a href="/2009/12/eip-quest-ce-que-cest.html">EIP</a> (<em>Enterprise Integration Patterns</em>) et propose donc une mise en oeuvre de l'architecture <strong>Pipes and Filters</strong>.</p>

<p><img src="http://3.bp.blogspot.com/-Pd_JIILTp_0/Ux8fIIRV-tI/AAAAAAAABRQ/hevpIqdQU4M/s1600/si-netty4-graph.png" alt="large" /></p>

<p>Au niveau écriture dans un répertoire, le <code>file-outbound-adapter</code> offert par Spring Integration sera utilisé :
```xml
file:outbound-channel-adapter id=&ldquo;fileAdapter&rdquo; auto-create-directory=&ldquo;true&rdquo;</p>

<pre><code>                                   directory="file:${out.directory}"
                                   channel="channel"/&gt;
</code></pre>

<p>```</p>

<p>Coté loggueur, ce sera le composant logging :
<code>xml
 &lt;int:logging-channel-adapter auto-startup="true" channel="channel" level="INFO" log-full-message="true"/&gt;
</code>
et où on aura un Pipe (channel) en mode <code>Publish-Subscribe</code> :
<code>xml
 &lt;int:publish-subscribe-channel id="channel"/&gt;
</code></p>

<p>Au niveau des namespaces et autres informations, on aura ce qui suit :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;
    &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
    &lt;property name="locations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/conf.properties&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
    &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
&lt;/bean&gt;

&lt;int-jmx:mbean-export default-domain="fr.jetoile.sample" server="mbeanServer"/&gt;

&lt;int:message-history/&gt;    
...
</code></pre>

<p></beans>
```</p>

<p>On y remarque la lecture du fichier de configuration, ainsi que les activations jmx adéquate afin d'avoir un peu d'informations ;&ndash;) Concernant l'élément message-history, cela permet de préciser à Spring Integration d'ajouter dans les headers du message (qui, pour rappel, transite via les Pipes entre les différents Filters) des informations de temps d'exécution.</p>

<p>En soit, il s'agit d'une configuration extrèmement simple pour toute personne connaissant un minimum Spring Integration, donc encore une fois, rien de compliqué&hellip; ;&ndash;)</p>

<h2>Gateway Spring Integration</h2>

<p>Afin de rentrer dans le vif du sujet, ce paragraphe montrera comment il est possible de transformer notre petit serveur Resteasy-Netty4 en une Gateway Spring Integration.</p>

<p>Pour ce faire, il suffit de définir une interface (NettyGateway) qui sera utilisée par Spring Integration.
Ci dessous un petit extract de la <a href="http://docs.spring.io/spring-integration/docs/3.0.1.RELEASE/reference/html/messaging-endpoints-chapter.html#gateway">documentation officielle</a> :</p>

<blockquote><p>Le rôle principale d'une Gateway est de chacher l'API de messaging fournit par Spring Integration. Cela permet à la logique business de l'application de s'abstraire complètement de l'API de Spring Integration et, en utilisant une Gateway générique, le code n'interagit qu'avec une simple interface.</p>

<p>&hellip;</p>

<p>En fait, Spring Integration fournit un GatewayProxyFactoryBean qui génère un proxy pour n'importe quelle interface et qui, en interne, invoque la méthode de la Gateway. Ainsi, en utilisant l'injection de dépendance, il est possible d'exposer l'interface aux méthodes business.</p></blockquote>

<p>```java
public interface NettyGateway {</p>

<pre><code>void send(DtoRequest msg);
</code></pre>

<p>}
```</p>

<p>Ainsi, notre service REST se présentera comme suit :
```java
@Path(&ldquo;/sample&rdquo;)
public class SimpleService {</p>

<pre><code>private NettyGateway messageProducer;

public void setGateway(NettyGateway messageProducer) {
    this.messageProducer = messageProducer;
}

@POST
@Path("/write")
@Consumes(MediaType.APPLICATION_JSON)
public Response write(DtoRequest message) {
    this.messageProducer.send(message);
    return Response.ok().build();
}
</code></pre>

<p>}
```</p>

<p>On y constatera que l'inteface NettyGateway lui a été injecté afin qu'il puisse servir de passe plat.</p>

<p>Coté Spring, la configuration est la suivante :
```xml
&lt;int:gateway id=&ldquo;nettyGateway&rdquo; service-interface=&ldquo;fr.jetoile.sample.gateway.NettyGateway&rdquo;</p>

<pre><code>             default-request-channel="channel"/&gt;
</code></pre>

<p><bean id="simpleService" class="fr.jetoile.sample.service.SimpleService"></p>

<pre><code>&lt;property name="gateway" ref="nettyGateway"/&gt;
</code></pre>

<p></bean>
<code>
Du coté de démarrage de notre serveur Resteasy-Netty4, cela ne sera, bien sûr, plus fait dans le `main()`, mais dans notre bean Spring à qui sera injectée notre classe implémentant notre service REST :
</code>xml
<bean id="nettyContainer" class="fr.jetoile.sample.gateway.NettyContainer"></p>

<pre><code>&lt;constructor-arg ref="simpleService"/&gt;
</code></pre>

<p></bean>
```</p>

<p>Avec :
```java
public class NettyContainer {</p>

<pre><code>private static final Logger LOGGER = LoggerFactory.getLogger(NettyContainer.class);

public static final String CONF_PROPERTIES = "conf.properties";

private static Configuration config;

private SimpleService simpleService;

public NettyContainer(SimpleService simpleService) {
    try {
        config = new PropertiesConfiguration(CONF_PROPERTIES);

    } catch (ConfigurationException e) {
        throw new IllegalArgumentException("bad config");
    }
    this.simpleService = simpleService;
    initServer();
}


private void initServer() {
    ResteasyDeployment deployment = new ResteasyDeployment();

    int nettyPort = 8081;

    if (config != null) {
        deployment.setAsyncJobServiceEnabled(config.getBoolean("netty.asyncJobServiceEnabled", false));
        deployment.setAsyncJobServiceMaxJobResults(config.getInt("netty.asyncJobServiceMaxJobResults", 100));
        deployment.setAsyncJobServiceMaxWait(config.getLong("netty.asyncJobServiceMaxWait", 300000));
        deployment.setAsyncJobServiceThreadPoolSize(config.getInt("netty.asyncJobServiceThreadPoolSize", 100));

        nettyPort = config.getInt("netty.port", TestPortProvider.getPort());
    } else {
        LOGGER.warn("is going to use default netty config");
    }

    deployment.setResources(Arrays.&lt;Object&gt;asList(simpleService));

    MyNettyJaxrsServer netty = new MyNettyJaxrsServer();

    netty.setDeployment(deployment);
    netty.setPort(nettyPort);
    netty.setRootResourcePath("");
    netty.setSecurityDomain(null);
    netty.start();
}
</code></pre>

<p>}
```</p>

<p>Et voilà&hellip; c'est tout!</p>

<p>Ne reste plus que la classe implémentant notre main() qui ne fera que charger le contexte spring :
```java
public class Client {</p>

<pre><code>public static void main(String[] args) throws ConfigurationException {
    new ClassPathXmlApplicationContext("springintegration-config.xml");
}
</code></pre>

<p>}
```</p>

<p>Juste un dernier point : le lecteur un peu concentré aura remarqué qu'il y a, ici, un petit meli melo dans la lecture des fichiers de configuration (parfois chargé par Spring, parfois chargé via commons-configuration). Je laisse cependant ces points en suspens et à la discrétion de la personne qui utilisera et lira cet article (ou qui aura atteint ce point&hellip;) (s'il y en a&hellip; ;&ndash;) ).</p>

<h2>Intégration de Metrics</h2>

<p>L'objectif de cet article étant de monter une stack &ldquo;presque complète&rdquo;, il est, bien sûr, primordial de fournir les bonnes métriques.</p>

<p>Comme dans mon article précédent, ce sera Metrics qui sera utilisé.</p>

<p>Cependant, alors que cela avait été fait programmatiquement, ce coup-ci, cela sera fait via Spring (parce que sinon ce n'est pas drôle&hellip; ;&ndash;) ).</p>

<p>Pour ce faire, c'est très simple, en tirant la dépendance <strong>&lsquo;com.ryantenney.metrics&rsquo;, name: &lsquo;metrics-spring&rsquo;, version:&lsquo;3.0.0-RC4&rsquo;</strong> au lieu de <strong>&lsquo;com.codahale.metrics&rsquo;, name: &lsquo;metrics-core&rsquo;</strong>, il ne reste qu'à ajouter à notre service REST l'annotation <code>@Timed</code> et d'ajouter dans la configuration Spring les éléments suivants :</p>

<p>```java
@POST
@Path(&ldquo;/write&rdquo;)
@Consumes(MediaType.APPLICATION_JSON)
@Timed
public Response write(DtoRequest message) {</p>

<pre><code>this.messageProducer.send(message);
return Response.ok().build();
</code></pre>

<p>}
```</p>

<p>Avec la configuration Spring suivante :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:metrics="http://www.ryantenney.com/schema/metrics"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd
              http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;

&lt;metrics:metric-registry id="metrics" /&gt;

&lt;metrics:annotation-driven metric-registry="metrics" /&gt;

&lt;metrics:reporter type="jmx" metric-registry="metrics" /&gt;
...
</code></pre>

<p></beans>
```</p>

<p>Pour montrer que je ne mens pas, on a donc (ici, utilisation de Hawt.io via Jolokia) :</p>

<p><img src="http://4.bp.blogspot.com/-CZebCZS47aE/Ux8fk-EwKQI/AAAAAAAABRY/C7OwMBMZNEc/s1600/si-hawtio-connextion.png" alt="medium" /></p>

<p><img src="http://2.bp.blogspot.com/-H-LmsIrivjA/Ux8fo7ORYpI/AAAAAAAABRg/EIp_-F6LzF4/s1600/si-hawtio-metrics.png" alt="medium" /></p>

<p>On constate encore une fois la simplicité de la chose!</p>

<h2>Intégration de Jolokia</h2>

<p>De même que pour notre paragraphe précédent, l'intégration de Jolokia se fera ici par configuration Spring plutôt que de manière programmatique.</p>

<p>Pour ce faire, il suffit de tirer la dépendance <strong>&lsquo;org.jolokia&rsquo;, name: &lsquo;jolokia-spring&rsquo;, version:&lsquo;1.1.2&rsquo;</strong> au lieu de <strong>&lsquo;org.jolokia&rsquo;, name: &lsquo;jolokia-jvm&rsquo;</strong>, et d'ajouter le bon bean à Spring :
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:file="http://www.springframework.org/schema/integration/file"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:metrics="http://www.ryantenney.com/schema/metrics"
   xmlns:int-jmx="http://www.springframework.org/schema/integration/jmx"
   xmlns:jolokia="http://www.jolokia.org/jolokia-spring/schema/config"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
              http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
              http://www.springframework.org/schema/integration/jmx http://www.springframework.org/schema/integration/jmx/spring-integration-jmx.xsd
              http://www.jolokia.org/jolokia-spring/schema/config http://www.jolokia.org/jolokia-spring/schema/config/jolokia-config.xsd
              http://www.ryantenney.com/schema/metrics http://www.ryantenney.com/schema/metrics/metrics-3.0.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" id="corePlaceHolder"&gt;
    &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
    &lt;property name="locations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/conf.properties&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;jolokia:agent lookupConfig="true" systemPropertiesMode="never"&gt;
    &lt;jolokia:config
            autoStart="true"
            host="${jolokia.host}"
            port="${jolokia.port}"
            user="${jolokia.user}"
            password="${jolokia.password}"/&gt;
&lt;/jolokia:agent&gt;
...
</code></pre>

<p></beans>
```</p>

<p>Et&hellip; c'est tout&hellip; Jolokia est intégré à notre petite stack.</p>

<h2>Intégration de Swagger</h2>

<p>Concernant l'intégration de Swagger, cela ne diffère en rien de mon article précédent. Même problème de CORS, même hack&hellip;</p>

<p><img src="http://4.bp.blogspot.com/-ev6GX1U7SEs/Ux8fxhWTl_I/AAAAAAAABRo/srY62BOqZS4/s1600/si-swagger.png" alt="medium" /></p>

<h2>Branchement des plugins Maven Appassembler et Assembly</h2>

<p>De même que pour Swagger, rien à signaler de particulier par rapport à mon article précédent&hellip; cela fonctionne sans problème ;&ndash;)</p>

<h1>Conclusion</h1>

<p>En conclusion, on peut constater que l'intégration de Spring integration dans notre petite stack est tout aussi trivial que le reste!</p>

<p>Encore une fois, simple et efficace ;&ndash;)</p>

<p>Ainsi, on peut bénéficier du meilleur des deux mondes.</p>

<p>Bien sûr, on peut se poser la question de l'intérêt de brancher quelques choses de véloce (Netty) avec un framework succeptible d'entrainer un Overhead (spring integration) et qui serait, alors, le point de contension. La question est légitime mais je n'y répondrai pas&hellip; ;&ndash;) (pour bien faire, il faudrait faire un benchmark).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Integration vs. Apache Camel]]></title>
    <link href="http://blog.jetoile.fr/2010/03/spring-integration-vs-apache-camel.html"/>
    <updated>2010-03-15T23:29:48+01:00</updated>
    <id>http://blog.jetoile.fr/2010/03/spring-integration-vs-apache-camel</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/S56PashF4SI/AAAAAAAAAJA/OVagPG4D-g0/s320/apache_spring.png" alt="left-small" />
Lors d'un <a href="/2009/12/eip-quest-ce-que-cest.html">post précédent</a>, j'avais parlé des <a href="/blog/2009/12/13/eip-quest-ce-que-cest/">EIPs</a> (<strong>Enterprise Integration Patterns</strong>) en expliquant qu'il s'agissait de Patterns permettant de normaliser les échanges de messages dans un système asynchrone.</p>

<p>Dans cet article, je vais tenter de présenter succinctement deux de ses implémentations : <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> et [Apache Camel](<a href="https://camel.apache.org/.">https://camel.apache.org/.</a></p>

<p>En fait, pour être plus précis, je vais plutôt tenter de présenter la vision que j'en ai ainsi que la façon dont je les ai compris.</p>

<p>Ainsi, ce post n'a pas pour objectif de les détailler de manière exhaustive car ils sont trop complets pour cela et qu'un seul post ne pourrait suffire à les aborder tous les deux (leurs documentations font d'ailleurs, pour Spring Integration, plus de 130 pages, et pour Apache Camel, plus de 580 pages&hellip; cqfd&hellip; ;&ndash;) ) mais juste, comme je l'ai dit précédemment dit, d'aider à comprendre leurs différences (quelles soient conceptuelles ou structurelles).</p>

<p>Je ne reviendrai pas sur les concepts des EIPs ni de JBI que j'utiliserai dans la suite et pour cela, je vous renvoie sur internet ou sur mes posts précédents (<a href="/2009/12/eip-quest-ce-que-cest.html">ici</a> et <a href="/2009/12/jbi-une-solution-enterree.html">là</a>).</p>

<p>Concernant les versions utilisées, cela n'a pas vraiment son importance ici car je m'intéresserai surtout aux principes de ces deux frameworks mais à titre indicatif, il s'agit des versions 2.0 pour Apache Camel et 1.3.0 pour Spring Integration (il me semble qu'il n'y a pas de modifications flagrantes dans les versions courantes qui sont 2.2.0 pour Camel et 2.0.0.M2 pour Spring Integration).</p>

<!-- more -->


<h1>Les concepts</h1>

<h2>Apache Camel</h2>

<p>Apache Camel est un framework open-source qui est une implémentation des EIPs et qui propose pour sa configuration d'utiliser indifféremment :</p>

<ul>
<li>un fichier de configuration Spring (Spring DSL),</li>
<li>un DSL interne (Java DSL),</li>
<li>ou un DSL externe (Scala DSL).</li>
</ul>


<p>Cependant, il définit ses propres concepts qui diffèrent de ceux des EIPs mais qui restent assez similaires.</p>

<p>Ainsi, Apache Camel s'appuie sur la notion de routes (<strong>Route</strong>) qui relient deux points d'accès (<strong>Endpoint</strong>). Sur cette route transite des messages (<strong>Message</strong>) au travers d'échanges (<strong>Exchange</strong>). En fait un Exchange est le conteneur du message durant la phase de routage.</p>

<p>Ces points d'accès peuvent être de différents types et peuvent supporter différentes technologies telles que :</p>

<ul>
<li>une destination (Topic ou Queue) JMS,</li>
<li>un service web,</li>
<li>un fichier se trouvant sur le système de fichier,</li>
<li>un serveur FTP,</li>
<li>une adresse mail,</li>
<li>ou encore un POJO (<em>Plain Old Java Object</em>).</li>
</ul>


<p>Si l'on fait un parallèle avec JBI (<em>Java Business Integration</em>) (cf. <a href="/2009/12/jbi-une-solution-enterree.html">ici</a>), un <strong>Endpoint</strong> peut être vu comme une instance d'un <strong>Binding Component</strong>.</p>

<p>Une <strong>Route</strong> peut, quant à elle, être vue comme le chemin qu'emprunte le message d'un bout à l'autre de la chaîne de médiation. Ce chemin pouvant être entrecoupé par ce qu'on appelle des processeurs (<strong>Processor</strong>).</p>

<p>Apache Camel introduit également la notion de Composants (<strong>Component</strong>) à partir desquels les <strong>Endpoint</strong> sont issus (toujours pour faire un parallèle avec JBI, un <strong>Component</strong> peut être vu comme un <strong>Composant JBI</strong> en mode fournisseur ou consommateur).</p>

<p>Enfin, par composition à un <strong>Endpoint</strong>, Apache Camel utilise également les notions de <strong>Producer</strong> et <strong>Consumer</strong> qui permettent d'émettre (respectivement, recevoir) un message vers (resp. d') une application extérieure et qui peuvent être vu comme des <strong>Binding Component</strong> en mode fournisseur (resp. consommateur).</p>

<h1>Spring Integration</h1>

<p>Spring Integration appartient au portfolio de Spring Framework et étend le modèle de programmation de Spring mais dans le domaine de la messagerie. Il supporte l'architecture basée sur les messages (<em>Message-Driven Architecture</em>) où l'inversion de contrôle est utilisée pour les problématiques d'exécution comme, par exemple, quand doivent être appelés les composants métiers ou encore où doivent être envoyées les réponses. En outre, il offre des mécanismes de routage et de transformation de messages afin de permettre aisément l'utilisation de protocoles de transport et des types de messages hétérogènes. Il propose pour sa configuration d'utiliser soit un fichier de configuration Spring soit le mécanisme d'annotations.</p>

<p>Concernant ses concepts, ils collent parfaitement à ceux des EIPs puisque Spring Integration utilise la notion de :</p>

<ul>
<li><strong>Message</strong> dont la définition est identique à celle des EIPs,</li>
<li><strong>Message Channel</strong> dont la définition est identique à celle des EIPs,</li>
<li>et de <strong>Message Endpoint</strong> qui regroupe :

<ul>
<li>les Message Routing dont la définition est identique à celle de Routing des EIPs</li>
<li>les Message Transformation dont la définition est identique à celle de Transformation des EIPs</li>
<li>et les Message Endpoint dont la définition est identique à celle des EIPs</li>
</ul>
</li>
</ul>


<h1>Mon avis avant utilisation</h1>

<h2>Apache Camel</h2>

<p>Apache Camel est un framework issu de l'implémentation JBI Apache ServiceMix et qui est également utilisé dans OpenESB. Cela peut expliquer pourquoi ses concepts sont si proches de ceux de JBI (ou du moins que les modèles sont si facilement transposables). Cependant, à mon sens, même si ses concepts sont proches de ceux de JBI, les termes utilisés sont différents et, pour ceux qui connaissent JBI, un effort d'apprentissage supplémentaire doit être fait. En outre, la documentation d'Apache Camel est loin d'être aisée à lire et retrouver de l'information dans le wiki qui lui sert de documentation s'achèvent généralement avec des cheveux en moins, une souris torturée ou un écran ébréché&hellip; le tout accompagné par une flopée d'injures&hellip;</p>

<p>Ainsi, à mon avis, pour un produit qui se veut être une implémentation des EIPs, il faut :</p>

<ul>
<li>d'une part, lire ou se familiariser avec les EIPs</li>
<li>et d'autre part, connaitre JBI ou, au moins, se familiarisé avec les concepts d'Apache Camel (comprendre la différence entre un composant, un endpoint qui est lui-même un processeur, les éléments pipeline et multicast qui sont eux-même des processeurs, etc, etc, etc&hellip;). Rien d'insurmontable mais il est quand même nécessaire de se faire quelques nœuds au cerveau&hellip;</li>
</ul>


<p>Par contre, par rapports aux EIPs, Apache Camel masque la notion de Channel, ce qui peut s'avérer plaisant.</p>

<h2>Spring Integration</h2>

<p>Spring Integration est un projet du portfolio Spring donc très propre, avec une documentation très bien faite et pas trop longue&hellip; En outre, pour quelqu'un qui est déjà familiarisé avec les EIPs, la prise en main de Spring Integration est immédiate. Le fait qu'il s'appuie sur Spring (tout comme Apache Camel d'ailleurs) permet une courbe d'apprentissage rapide.</p>

<h1>Mon avis après utilisation</h1>

<h2>Apache Camel</h2>

<p>Apache Camel s'avère ardu à prendre en main malgré un forum actif. Cela en raison de sa documentation un peu (complètement?) fouillis mais également parce qu'il est possible de faire la même chose de multiples manières, ces manières ayant chacunes ses limitations. Si on utilise le framework simplement avec une description XML et des POJOs (qui sont, parfois, fortement couplé au framework Apache Camel au travers de son API (Exchange, Endpoint, &hellip;) &hellip; pas très propre tous ça&hellip; :( ), on peut arriver sans trop de douleur à faire ce que l'on veut. Par contre, si on se lance dans les DSLs internes ou externes (et même si j'aime bien le principe des DSLs&hellip;), cela n'exclue pas l'adhérence des POJOs à l'API d'Apache Camel et il est souvent nécessaire de faire intervenir la notion d'Exchange dans les signatures des méthodes.</p>

<p>En outre, on se rend rapidement compte que la majorité des classes de l'API héritent de l'interface <code>Processor</code>. Pourquoi cela me pose problème? et bien parce que j'estime qu'il est bizarre et peu naturel que certaines classes comme Pipeline ou MulticastProcessor implémente (directement ou indirectement) Processor ou alors il aurait, au moins, été préférable de mettre ce type de classes dans un autre package que celui où se trouvent des classes comme Aggregator, FileProcessor, Resequencer ou encore RecipientList. Bon, je comprends qu'Apache Camel a été pensé dès le départ pour offrir une configuration simple à base de DSL et que, du coup, il a été nécessaire de faire certaines concessions mais lorsque l'on rentre dans le code du framework, ce n'est pas (et cela ne concerne que moi) une impression de propreté qui en ressort&hellip;</p>

<p>Un autre point qui m'interpelle est le fait que lors de l'écriture des règles de médiations, il n'y a pas de différences sémantiques entre les différentes notions qu'offrent les EIPs : les Message Transformation, Message Routing ou Service Activator se représentent tous comme des Processor ou des Bean. Je trouve cela dommage de perdre la classification (qu'on aime ou pas) fournit par les EIPs et qui, à mon sens, permettait justement de clarifier toutes les notions utiles pour gérer les échanges de messages dans un système asynchrone.</p>

<p>Par contre, comme je l'ai dit précédemment, il est vraiment appréciable de ne pas à avoir à déclarer ses propres Channels qui sont masqués par la notion de Route.</p>

<h2>Spring Integration</h2>

<p>Spring Integration est extrèmement simple à prendre en main et son forum est très actif. La documentation est claire et c'est vrai qu'il est appréciable de pouvoir utiliser les notions des EIPs directement.</p>

<p>Les annotations sont parlantes et les éléments (service-activator, splitter, filter, resequencer, aggregator, transformer, router, &hellip;) à utiliser dans le fichier de configuration Spring permettent de classifier rapidement les différents éléments se trouvant dans la chaine de médiations.</p>

<p>En outre, le code interne du framework est propre et permet de masquer la complexité des différents Message Endpoint.</p>

<h1>Conclusion</h1>

<p>Vous l'aurez compris, j'ai une petite préférence pour Spring Integration&hellip;</p>

<p>Cependant, je dirai que le choix dépend aussi grandement de l'utilisation qu'on veut en faire (bon ok, je ne me mouille pas trop&hellip; ;&ndash;) ) :</p>

<ul>
<li>dans un ESB type ServiceMix ou OpenESB, il peut être préférable d'utiliser Apache Camel en raison de sa capacité à être configurée via un DSL qui peut être plus aisé que de manipuler des Channels et des fichiers XML,</li>
<li>par contre, pour les autres cas, je conseillerai plutôt Spring
Integration pour son modèle de programmation et ses concepts plus
simple&hellip;</li>
</ul>


<p>mais là, je conseillerai à chacun de se faire sa propre idée&hellip;</p>

<p>Un petit mot en plus sur les points non abordés ci-dessus :</p>

<ul>
<li>les mécaniques offertes pour manipuler des messages au format XML (XPath, &hellip;),</li>
<li>la gestion des erreurs,</li>
<li>le nombre de connecteurs fournis par ces derniers.</li>
</ul>


<p>Sur ces deux derniers points, l'avantage va indéniablement à Apache Camel même s'il est aisé (modulo la connaissance du protocole utilisé) d'en redéfinir avec Spring Integration en utilisant un Service Activator mais, dans ce cas, il faut le faire à la main.</p>

<p>Pour le premier point, je ne dirai rien car je n'ai pas eu l'occasion de l'utiliser&hellip;</p>

<p>Enfin, il ne faut pas oublier que ces frameworks ont pour but principal d'offrir un moyen de faire de la médiation technique et non de gérer une orchestration de processus métier et que pour cette raison, ils doivent être utilisés à bon escient.</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li><strong>SOA : le guide de l’architecte</strong> de X. Fourner-Morel, P. Grojean, G. Plouin et C. Rognon chez Dunod</li>
<li><strong>Enterprise Integration Patterns</strong> de G. Hohpe et B. Woolf chez Addisson Wesley</li>
<li>Site de Spring Integration : <a href="http://www.springsource.org/spring-integration">http://www.springsource.org/spring-integration</a></li>
<li>API de Spring Integration : <a href="http://static.springframework.org/spring-integration/apidocs/">http://static.springframework.org/spring-integration/apidocs/</a></li>
<li>Manuel de référence de Spring Integration : <a href="http://docs.spring.io/spring-integration/docs/4.0.0.M3/reference/html/">http://docs.spring.io/spring-integration/docs/4.0.0.M3/reference/html/</a></li>
<li>Site d'Apache Camel : <a href="http://camel.apache.org/">http://camel.apache.org/</a></li>
<li>API d'Apache Camel : <a href="http://camel.apache.org/javadoc.html">http://camel.apache.org/javadoc.html</a></li>
<li>Manuel de référence d'Apache Camel : <a href="http://camel.apache.org/manual.html">http://camel.apache.org/manual.html</a></li>
<li>Spécification de JBI : <a href="http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html">http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html</a></li>
<li>Blog de Xebia sur les ESB légers : <a href="http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/">http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/</a></li>
<li>Blog de Xebia sur une revue de presse d'un article sur Spring Integration et Apache Camel : <a href="http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel">http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
