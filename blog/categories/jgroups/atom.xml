<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jgroups | Jetoile]]></title>
  <link href="http://blog.jetoile.fr/blog/categories/jgroups/atom.xml" rel="self"/>
  <link href="http://blog.jetoile.fr/"/>
  <updated>2015-10-09T15:28:38+02:00</updated>
  <id>http://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pour les gouverner tous - partie 3/3]]></title>
    <link href="http://blog.jetoile.fr/2011/02/pour-les-gouverner-tous-partie-33.html"/>
    <updated>2011-02-24T18:49:13+01:00</updated>
    <id>http://blog.jetoile.fr/2011/02/pour-les-gouverner-tous-partie-33</id>
    <content type="html"><![CDATA[<p><img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/TUcoTratqiI/AAAAAAAAAUQ/Gmc1h0rvA2w/s1600/jmx_jgroups01.png" alt="left-small" /></p>

<p>Cet article fait suite à mes précédents posts (<a href="/2011/01/pour-les-gouverner-tous-partie-13.html">ici</a> et <a href="/2011/02/pour-les-gouverner-tous-partie-23.html">là</a>) et à pour objectif d'intégrer la partie JMX à mon petit POC JGroups afin d'offrir une solution permettant de rendre complètement scalable la partie supervision/administration par JMX d'une application distribuée (ie. d'aggréger tous les MBeans au sein de tous les serveurs JMX). Pour rappel, le post précédent introduisait JGroups dans une petite application qui permettait à chaque instance d'une application d'obtenir la valeur d'une donnée offerte par les autres instances.</p>

<!-- more -->


<h1>Expression du besoin et conception</h1>

<p>Comme je l'ai expliqué <a href="/2011/01/pour-les-gouverner-tous-partie-13.html">ici</a>, le principe est simple : en démarrant son application qui aura à sa charge d'appeler un petit bout de code de notre toolkit, tous les MBeans se trouvant sur les autres serveurs JMX (modulo que l'application qui les ait démarrés ait démarré en instanciant notre toolkit) doivent être remonter dans notre serveur JMX courant. Réciproquement, tous les MBeanServer devront enregistrer les MBeans offerts par notre instance d'application.</p>

<p>Pour ce faire, notre toolkit gérera la partie JMX, c'est-à-dire qu'il créera un connecteur JMX serveur (connecteur s'appuyant sur le protocole RMI) permettant d'accéder au MBeanServer courant (ie. il utilisera le MBeanServer s'il en existe un ou, dans le cas échéant, il en créera un) et qu'il l'exposera aux autres instances en fournissant un stub de la partie connecteur JMX cliente. Ce stub permettra aux autres instances d'instancier la couche de communication nécessaire vers le MBeanServer cible. C'est ce stub qui sera transmis par JGroups (et qui remplacera donc la donnée partagée de notre <em>POC</em> JGroups).</p>

<p>Ca va? Tout le monde suit? Bon, on va pouvoir accélérer&hellip; ;&ndash;)</p>

<p>Ainsi, lorsqu'une nouvelle instance sera démarrée dans le système, les instances déjà présentes seront notifiées de l'arrivé d'un nouveau membre dans la vue (<a href="/2010/12/jgroups-tour-d.html">concepts JGroups</a> et cf. <a href="/2011/02/pour-les-gouverner-tous-partie-23.html">post précédent</a>). Suite à cela, elles récupèreront le stub du JMXConnector du nouveau MBeanServer (toujours cf. <a href="/2011/02/pour-les-gouverner-tous-partie-23.html">post précédent</a>) qui leur permettra de créer un proxy dynamique correspondant aux MBeans présents dans le MBeanServer cible. Ce proxy dynamique sera instancié et enregistré comme étant un nouveau MBean dans le MBeanServer de l'instance courante.</p>

<p>Cependant, ce proxy dynamique ne pourra pas être utilisé directement (sinon ça serait trop simple). En effet, la méthode statique <code>JMX.newMBeanProxy()</code> permet de créer un proxy dynamique du MBean standard d'un MBeanServer distant ou local. Cependant, il n'est pas possible de l'enregistrer comme MBean au sein d'un MBeanServer car il ne répond alors pas à la règle : &ldquo;un MBean doit implémenter une interface de type MBean ou DynamicMBean&rdquo;. Aussi, la solution retenue a été de wrapper ce proxy dynamique dans un MBean dynamique. Ce wrapper fera donc passe-plat (en utilisant la réflexion) avec le proxy dynamique récupéré par la méthode <code>JMX.newMBeanProxy()</code> lors de l'invocation d'opérations dessus (pour ce faire, il s'appuiera sur les normes spécifiées par JMX pour l'accès en lecture/écriture aux variables d'instance).</p>

<p>En outre, pour le cas spécifique des MXBeans (un certain nombre de MXBean est spécifié par JMX : <a href="http://download.oracle.com/javase/6/docs/api/">http://download.oracle.com/javase/6/docs/api/</a>), un traitement particulier sera effectué. En effet, JMX offre la possibilité de créer directement un proxy de l'interface d'un MXBean donné via la méthode statique <code>ManagementFactory.newPlatformMXBeanProxy()</code>. Aussi, pour les MXBeans, notre wrapper ne sera pas utilisé puisqu'il est possible d'enregistrer directement au sein de notre MBeanServer courant le MXBean distant.</p>

<p>Bien sûr, encore une fois, cela aurait été trop simple s'il n'y avait pas un mais&hellip; ;&ndash;) En effet, la spécification JMX précise qu'il est possible d'avoir plusieurs MXBeans de type <code>MemoryPoolMXBean</code>, <code>MemoryManagerMXBean</code> et <code>GarbageCollector</code> (cf. <a href="http://download.oracle.com/javase/6/docs/api/">http://download.oracle.com/javase/6/docs/api/</a>). Dans ces cas précis, ce sont les propriétés de ces MXBeans qui permettent de les différencier : un traitement particulier sera donc effectué dans ces cas précis puisqu'une recherche pour décrouvrir les propritétés du MXBean sera faite.</p>

<p>En outre, un cas particulier lié à la JRE 6 de Sun (Hostpot) a, ici, été traité (du coup, cela rend le code proposé adhérent à notre jdk&hellip;) puisque le MXBean <code>HotpostDiagnostic</code> a fait l'objet d'une attention particulière&hellip;</p>

<h1>Mise en oeuvre</h1>

<h2>Intégration de JMX</h2>

<p><u>Note</u> : à noter que le code présenté dans cet article comporte quelques raccourcis et n'a pour objectif que de montrer les points clé. Aussi, certaines portions (comme, entre autre, la gestion des threads, des exceptions ou les méthodes <code>equals()</code>, <code>hashCode()</code> ou <code>toString()</code>) ne sont pas présentes par soucis de clarté. Le code complet peut être trouvé sur GitHub : <a href="https://github.com/jetoile/jmanager4all.">https://github.com/jetoile/jmanager4all.</a></p>

<p>Ici, la donnée, traduite par la classe <code>Data</code> dans mon article précédent, sera remplacée par le stub au <code>JMXConnector</code>. Ce stub sera créé par la classe utilisée pour instancier les objets nécessaires à la bonne initalisation du toolkit et il sera encapsulé dans la classe <code>JManagerConnector</code> (à noter, bien sûr que la classe <code>RMIConnector</code> (implémentation de l'interface <code>JMXConnector</code>) utilisée ici est sérialisable) lors de sa transmission entre les différentes instances de l'application.</p>

<p>```java
public class JManagerConnector implements Serializable {
 private String location;
 private JMXConnector connector;</p>

<p> public JManagerConnector() {
 }</p>

<p> public String getLocation() {
  return location;
 }</p>

<p> public void setLocation(final String location) {
  this.location = location;
 }</p>

<p> public JMXConnector getConnector() {
  return connector;
 }</p>

<p> public void setConnector(final JMXConnector connector) {
  this.connector = connector;
 }
}
<code>``
Du point de vue création des objets JMX exposés (ie. le</code>JMXConnector<code>et son stub) et de l'initialisation de ces derniers (ie. démarrage du connecteur), cela sera fait, comme dit précédemment, par notre classe qui nous servira de point d'entrée à notre toolkit</code>JManager4All` :</p>

<p>```java
public class JManager4All {</p>

<pre><code>final static private Logger LOGGER = LoggerFactory.getLogger(JManager4All.class);

private static final String CONNECTOR_PROTOCOL = "rmi";

private JMXConnectorServer jmxConnector;
private JMXServiceURL jmxServiceUrl;
final private JManagerConnector jmanagerConnector = new JManagerConnector();
private final MBeanServer mBeanServer;
final private JMXConnectorStubCache connectorsStub = new JMXConnectorStubCache();

private JGroupsBindingComponent jmanagerBindingComponent;
public JManager4All(final int port) {
    try {
        this.jmxServiceUrl = new JMXServiceURL(CONNECTOR_PROTOCOL, null, port);
    } catch (MalformedURLException e) {
        LOGGER.error("unable to create JMXServiceURL: {}", e);
    }
    this.mBeanServer = ManagementFactory.getPlatformMBeanServer();
    init();
}

private void init() {
    try {
        this.jmxConnector = JMXConnectorServerFactory.newJMXConnectorServer(this.jmxServiceUrl, null, mBeanServer);
        this.jmxConnector.start();

        final ObjectName objectName = new ObjectName(":type=csserver, name=csserver");
        mBeanServer.registerMBean(this.jmxConnector, objectName);
        this.jmanagerConnector.setConnector(this.jmxConnector.toJMXConnector(null));

        this.jmanagerBindingComponent = new JGroupsBindingComponent(this.jmanagerConnector);
        this.jmanagerBindingComponent.setConnectorsStub(this.connectorsStub);
    } catch (Exception e) {
        LOGGER.error("unable to init: {}", e);
    }
}

public void stop() throws IOException {
    this.jmxConnector.stop();
    this.jmanagerBindingComponent.stop();
}

public void start() {
    this.jmanagerBindingComponent.start();
}

public JManagerConnector getStubConnector() {
    return this.jmanagerConnector;
}
</code></pre>

<p>}
```</p>

<p>On remarquera également que cette classe instancie et démarre une instance d'un <code>JGroupsBindingComponent</code> qui s'occupe de la couche communication pour récupérer nos stubs du système (ici, ça sera JGroups). Je ne reviendrai pas sur les détails d'implémentation de cette partie puisque cela a déjà été traité <a href="/2011/02/pour-les-gouverner-tous-partie-23.html">ici</a>.</p>

<p>A noter également que nos stubs seront conservés dans un cache <code>JMXConnectorStubCache</code> qui déclenchera, lorsqu'un élément (ie. un stub d'un <code>JMXConnector</code>) sera ajouté ou supprimé, la récupération de nos MBean distant et leur enregistrement au sein du MBeanServer courant (resp. leur suppression).</p>

<p>```java
public class JMXConnectorStubCache implements Serializable {</p>

<p> volatile private Map&lt;JManagerAddress, JMXConnector> connectorsStub = Collections.synchronizedMap(new HashMap&lt;JManagerAddress, JMXConnector>());</p>

<p> synchronized public Map&lt;JManagerAddress, JMXConnector> getValue() {
  return this.connectorsStub;
 }</p>

<p> synchronized public JMXConnector put(JManagerAddress key, JMXConnector value) {
  JMXConnector result = this.connectorsStub.put(key, value);
  MBeanHandler mBeanHandler = new MBeanHandler(key, value);
  mBeanHandler.handleAdd();
  return result;
 }</p>

<p> synchronized public JMXConnector remove(JManagerAddress key) {
  JMXConnector result = this.connectorsStub.remove(key);
  MBeanHandler mBeanHandler = new MBeanHandler(key, result);
  mBeanHandler.handleRemove();
  return result;
 }
}
```
Ce dernier point nous amène au paragraphe suivant, à savoir la récupération des MBeans distants et leur enregistrement.</p>

<h1>Récupération des MBeans distants et enregistrement</h1>

<p>La récupération des MBeans distants est globalement simple et suit le schéma suivant (cet algorithme ne s'applique pas aux MXBeans) :</p>

<ul>
<li>à partir du <code>JMXConnector</code> client, récupération du <code>MBeanServerConnection</code>,</li>
<li>à partir du <code>MBeanServerConnection</code>, une recherche est lancée sur le <code>MBeanServer</code> distant pour récupérer l'ensemble des <code>ObjectInstance</code> présenst sur ce dernier,</li>
<li>pour chaque <code>ObjectInstance</code> qui n'est pas dans le domaine JMX <em>&ldquo;remote&rdquo;</em> (qui sera le domaine utilisé pour stocker les proxy des MBeans distants), création d'un proxy dynamique représentant l'objet exposé par le MBean et encapsulation de ce dernier dans la classe <code>MBeanWrapper</code> qui est un <code>DynamicMBean</code>,</li>
<li>enfin enregistrement de chaque <code>DynamicMBean</code> créé dans le <code>MBeanServer</code> local via un <code>ObjectName</code> défini grâce à :

<ul>
<li>ses propriétés,</li>
<li>son domaine JMX distant sous forme de propriété <em>&ldquo;subdomain&rdquo;</em>,</li>
<li>mais également avec une propriété permettant de connaitre la provenance du MBean (propriété qui sera appelée <em>&ldquo;instance&rdquo;</em>).</li>
</ul>
</li>
</ul>


<p><code>java
public class MBeanHandler {
 private static final String DOMAIN_REMOTE = "remote";
 
 private static final Logger LOGGER = LoggerFactory.getLogger(MBeanHandler.class);
 
 private final MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
 private final JMXConnector connector;
 private final JManagerAddress address;
 
 public MBeanHandler(final JManagerAddress address, final JMXConnector connector) {
  this.connector = connector;
  this.address = address;
 }
 
 void handleAdd() throws Exception {
  if (connector != null) {
   connector.connect();
   ObjectName objectName = new ObjectName("*:*");
   final MBeanServerConnection mBeanServerConnection = connector.getMBeanServerConnection();
 
   final Set&lt;ObjectInstance&gt; instances = mBeanServerConnection.queryMBeans(objectName, null);
 
   for (ObjectInstance objectInstance : instances) {
    final ObjectName distantObjectName = objectInstance.getObjectName();
    if (DOMAIN_REMOTE.equals(distantObjectName.getDomain())) {
     continue;
    }
    final ObjectName newObjectName = new ObjectName(DOMAIN_REMOTE + ":instance=" + address + ", " + "subdomain=" + distantObjectName.getDomain()
      + ", " + distantObjectName.getKeyPropertyListString());
    final MBeanInfo mBeanInfo = mBeanServerConnection.getMBeanInfo(distantObjectName);
    registerRemoteMBean(mBeanServerConnection, distantObjectName, newObjectName, mBeanInfo);
   }
  }
 }
 
 private void registerRemoteMBean(final MBeanServerConnection mBeanServerConnection, final ObjectName distantObjectName, final ObjectName newObjectName,
   final MBeanInfo mBeanInfo) throws Exception {
  Object mBean = getRemoteMBean(mBeanServerConnection, mBeanInfo, distantObjectName);
  if (mBean != null) {
   mbeanServer.registerMBean(mBean, newObjectName);
  }
 }
 
 public Object getRemoteMBean(final MBeanServerConnection mBeanServerConnection, final MBeanInfo mBeanInfo, final ObjectName distantObjectName)
   throws Exception {
  if (!Boolean.parseBoolean((String) mBeanInfo.getDescriptor().getFieldValue("mxbean"))) {
   LOGGER.debug("current mxBeanInfo : {}", mBeanInfo);
   final Class&lt;?&gt; clazz = Class.forName(mBeanInfo.getClassName());
   final Class&lt;?&gt;[] interfazes = clazz.getInterfaces();
   if (interfazes.length == 1) {
    LOGGER.debug("current interface : {}", interfazes[0]);
    final Object proxy = JMX.newMBeanProxy(mBeanServerConnection, distantObjectName, interfazes[0]);
    final MBeanWrapper mBeanWrapper = new MBeanWrapper(mBeanInfo, proxy);
    return mBeanWrapper;
   }
  }
  return null;
 }
}
</code></p>

<br/>


<p>```java
public class MBeanWrapper implements DynamicMBean {</p>

<p> static final private Logger LOGGER = LoggerFactory.getLogger(MBeanWrapper.class);</p>

<p> private final MBeanInfo mBeanInfo;
 private final Object proxy;</p>

<p> public MBeanWrapper(final MBeanInfo mBeanInfo, final Object proxy) {
  this.mBeanInfo = mBeanInfo;
  this.proxy = proxy;
 }</p>

<p> @Override
 public Object getAttribute(String attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  MBeanAttributeInfo[] mBeanAttributeInfos = mBeanInfo.getAttributes();
  for (MBeanAttributeInfo mBeanAttributeInfo : mBeanAttributeInfos) {
   if (StringUtils.equals(attribute, mBeanAttributeInfo.getName())) {</p>

<pre><code>if (mBeanAttributeInfo.isReadable()) {
 return invokeGetter(attribute, mBeanAttributeInfo);
} else {
 return null;
}
</code></pre>

<p>   }
  }
  return null;
 }</p>

<p> Object invokeGetter(String attribute, MBeanAttributeInfo mBeanAttributeInfo) {
  try {
   Method method = null;
   if (mBeanAttributeInfo.isIs()) {</p>

<pre><code>method = this.proxy.getClass().getMethod("is" + StringUtils.capitalize(attribute), new Class[0]);
return method.invoke(this.proxy, new Object[0]);
</code></pre>

<p>   } else {</p>

<pre><code>method = this.proxy.getClass().getMethod("get" + StringUtils.capitalize(attribute), new Class[0]);
return method.invoke(this.proxy, new Object[0]);
</code></pre>

<p>   }
  } catch (Exception e) {
   LOGGER.error(&ldquo;unable to get remote attribute info {}: {}&rdquo;, attribute, e);
  }
  return null;
 }</p>

<p> @Override
 public void setAttribute(Attribute attribute) throws AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException {
  MBeanAttributeInfo[] mBeanAttributeInfos = mBeanInfo.getAttributes();
  for (MBeanAttributeInfo mBeanAttributeInfo : mBeanAttributeInfos) {
   if (StringUtils.equals(attribute.getName(), mBeanAttributeInfo.getName())) {</p>

<pre><code>if (mBeanAttributeInfo.isWritable()) {
 invokeSetter(attribute, mBeanAttributeInfo);
} else {
 return;
}
</code></pre>

<p>   }
  }
  return;
 }</p>

<p> void invokeSetter(Attribute attribute, MBeanAttributeInfo mBeanAttributeInfo) {
  try {
   Method method = null;
   if (mBeanAttributeInfo.isIs()) {</p>

<pre><code>method = this.proxy.getClass().getMethod("set" + StringUtils.capitalize(attribute.getName()), boolean.class);
method.invoke(this.proxy, attribute.getValue());
</code></pre>

<p>   } else {</p>

<pre><code>method = this.proxy.getClass().getMethod("set" + StringUtils.capitalize(attribute.getName()), attribute.getValue().getClass());
method.invoke(this.proxy, attribute.getValue());
</code></pre>

<p>   }
  } catch (Exception e) {
   LOGGER.error(&ldquo;unable to set remote attribute info {}: {}&rdquo;, attribute, e);
  }
 }</p>

<p> @Override
 public AttributeList getAttributes(String[] attributes) {
  AttributeList result = new AttributeList();
  for (String attribute : attributes) {
   Attribute currentAttribute;
   try {</p>

<pre><code>currentAttribute = new Attribute(attribute, getAttribute(attribute));
result.add(currentAttribute);
</code></pre>

<p>   } catch (Exception e) {</p>

<pre><code>LOGGER.error("unable to get remote attribute info {}: {}", attribute, e);
</code></pre>

<p>   }
  }
  return result;
 }</p>

<p> @Override
 public AttributeList setAttributes(AttributeList attributes) {
  AttributeList result = new AttributeList();
  for (int i = 0; i &lt; attributes.size(); i++) {
   Attribute attribute = (Attribute) attributes.get(i);
   try {</p>

<pre><code>setAttribute(attribute);
result.add(attribute);
</code></pre>

<p>   } catch (Exception e) {</p>

<pre><code>LOGGER.error("unable to set remote attribute {}: {}", attribute.getName(), e);
</code></pre>

<p>   }
  }
  return result;
 }</p>

<p> @Override
 public Object invoke(String actionName, Object[] params, String[] signature) throws MBeanException, ReflectionException {
  Class[] paramTypes = null;
  if (signature != null) {
   paramTypes = new Class[signature.length];
   for (int i = 0; i &lt; signature.length; ++i) {</p>

<pre><code>paramTypes[i] = signature[i].getClass();
</code></pre>

<p>   }
  }</p>

<p>  try {
   Method method = this.proxy.getClass().getMethod(actionName, paramTypes);
   return method.invoke(this.proxy, params);
  } catch (Exception e) {
   LOGGER.error(&ldquo;unable to invoke {}: {}&rdquo;, actionName, e);
  }
  return null;
 }</p>

<p> @Override
 public MBeanInfo getMBeanInfo() {
  return this.mBeanInfo;
 }
}
```</p>

<p>On voit donc que le processus n'est pas vraiment compliqué. Pour le cas des MXBeans, cela est un peu plus sioux&hellip; mais globalement pas compliqué non plus ;&ndash;)</p>

<p>En effet, plusieurs cas se présentent :</p>

<ul>
<li>Pour les <code>MXBeans</code> de types (type au sens propriété JMX) <strong>Compilation</strong>, <strong>ClassLoading</strong>, <strong>Memory</strong>, <strong>OperationSystem</strong>, <strong>Runtime</strong> et <strong>Threading</strong>, cela ne pose pas de problèmes puisque la spécification JMX nous dit qu'il n'y a qu'un seul MBean de ce type dans le <code>MBeanServer</code> pour domaine <em>java.lang</em>. Dans ce cas, il suffit juste d'instancier un proxy dynamique du MXBean lui-même et de l'enregistrer avec le &ldquo;bon&rdquo; <code>ObjectName</code>.</li>
<li>par contre, pour les <code>MXBeans</code> de types <strong>MemoryPool</strong>, <strong>GarbageCollector</strong> et <strong>MemoryManager</strong>, vu qu'il peut y en avoir plusieurs, une recherche est effectuée (en limitant la recherche aux <code>MBeans</code> voulus bien sûr&hellip;) sur le <code>MBeanServer</code> distant afin d'obtenir (mais également d'instancier) le bon type de proxy dynamique mais également les bonnes propriétés sous lequel il est enregistré.</li>
</ul>


<p><code>java
final private static Map&lt;String, Class&lt;?&gt;&gt; MXBEAN_MAP = new HashMap&lt;String, Class&lt;?&gt;&gt;();
 static {
  MXBEAN_MAP.put(ManagementFactory.COMPILATION_MXBEAN_NAME, CompilationMXBean.class);
  MXBEAN_MAP.put(ManagementFactory.CLASS_LOADING_MXBEAN_NAME, ClassLoadingMXBean.class);
  MXBEAN_MAP.put(ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);
  MXBEAN_MAP.put(ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME, OperatingSystemMXBean.class);
  MXBEAN_MAP.put(ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
  MXBEAN_MAP.put(ManagementFactory.THREAD_MXBEAN_NAME, ThreadMXBean.class);
  MXBEAN_MAP.put("java.util.logging:type=Logging", LoggingMXBean.class);
 }
 
 public RemoteMXBeanHandler() {
 }
 
 public Object getRemoteMBean(final MBeanServerConnection mBeanServerConnection, final MBeanInfo mBeanInfo, final ObjectName distantObjectName)
   throws Exception {
  if (Boolean.parseBoolean((String) mBeanInfo.getDescriptor().getFieldValue("mxbean"))) {
   LOGGER.debug("current mxBeanInfo : {}", mBeanInfo);
   Object proxy = getMxBeanProxy(mBeanServerConnection, mBeanInfo, distantObjectName);
   return proxy;
  }
  return null;
 }
 
 private Object getMxBeanProxy(final MBeanServerConnection mBeanServerConnection, final MBeanInfo mBeanInfo, final ObjectName distantObjectName)
   throws IOException {
  String distantName = distantObjectName.toString();
  int index = distantName.indexOf(",");
  String substring = distantName.substring(0, (index != -1) ? index : distantName.length());
  Class&lt;?&gt; mBeanClass = MXBEAN_MAP.get(substring);
  if (mBeanClass != null) {
   return ManagementFactory.newPlatformMXBeanProxy(mBeanServerConnection, distantName, mBeanClass);
  } else if (!StringUtils.equals(ManagementFactory.MEMORY_POOL_MXBEAN_DOMAIN_TYPE, substring)
    &amp;&amp; !StringUtils.equals(ManagementFactory.GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE, substring)
    &amp;&amp; !StringUtils.equals(ManagementFactory.MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE, substring)
    &amp;&amp; !StringUtils.contains(substring, "com.sun.management")) {
   return ManagementFactory.newPlatformMXBeanProxy(mBeanServerConnection, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
  } else {
   return null;
  }
 }
 
 private void handleSpecificMXBean(final MBeanServerConnection mBeanServerConnection) throws Exception {
  // cf. http://download.oracle.com/javase/6/docs/api/
 
  // traitement particulier pour les MXBeans de type MemoryPoolMXBean
  registerOtherMxBean(mBeanServerConnection, ManagementFactory.MEMORY_POOL_MXBEAN_DOMAIN_TYPE, MemoryPoolMXBean.class);
  // traitement particulier pour les MXBeans de type MemoryManagerMXBean
  registerOtherMxBean(mBeanServerConnection, ManagementFactory.MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE, MemoryManagerMXBean.class);
  // traitement particulier pour les MXBeans de type GarbageCollector
  registerOtherMxBean(mBeanServerConnection, ManagementFactory.GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE, GarbageCollectorMXBean.class);
 
  // traitement particulier pour les MXBeans de type Hotspot
  registerOtherMxBean(mBeanServerConnection, "com.sun.management:type=HotSpotDiagnostic", HotSpotDiagnosticMXBean.class);
 }
 
 private void registerOtherMxBean(final MBeanServerConnection mBeanServerConnection, String type, Class&lt;?&gt; clazz) throws Exception {
  final ObjectName requestedObjectName = new ObjectName(type + ",*");
  final Set&lt;ObjectName&gt; objectNames = mBeanServerConnection.queryNames(requestedObjectName, null);
  for (ObjectName objectName : objectNames) {
   final Object proxy = ManagementFactory.newPlatformMXBeanProxy(mBeanServerConnection, objectName.getCanonicalName(), clazz);
   final ObjectName newObjectName = new ObjectName("remote:instance=" + address + ", " + "subdomain=" + objectName.getDomain() + ", "
     + objectName.getKeyPropertyListString());
   mbeanServer.registerMBean(proxy, newObjectName);
  }
 }
</code>
Pour le cas particulier du <code>MXBean HotspotDiagnostic</code>, je vous laisse le soin de jeter un oeil sur le code&hellip; ;&ndash;)</p>

<h1>Désenregistrement d'une instance (et donc de ses MBeans associés)</h1>

<p>Bien entendu, si une instance venait à disparaitre, il est nécessaire de désenregistrer ses <code>MBeans</code> pour chaque instance de l'application encore présente.</p>

<p>Là encore, la principe est ultra-simple puisqu'il suffit de récupérer l'ensemble des MBeans qui se trouvent dans le domaine JMX <em>&ldquo;remote&rdquo;</em> (qui pour rappel est le domaine utilisé pour enregistrer tous nos proxy) avec la &ldquo;bonne&rdquo; propriété (à savoir la propriété <code>instance</code> qui doit valoir la valeur de l'adresse de l'instance à supprimer) et de les désenregistrer du <code>MBeanServer</code> local.</p>

<p><code>java
void handleRemove() throws Exception {
  final ObjectName queryObjectName = new ObjectName(DOMAIN_REMOTE + ":instance=" + address + ",*");
  final Set&lt;ObjectName&gt; objectNames = mbeanServer.queryNames(queryObjectName, null);
  for (ObjectName objectName : objectNames) {
   LOGGER.debug("remove from mBeanServer objectName : {}", objectName);
   mbeanServer.unregisterMBean(objectName);
  }
 }
</code></p>

<h1>Conclusion</h1>

<p>On a vu tout au long de cette article comment il était possible d'utiliser JMX coté client (on récupère des <code>MBeans</code> distants) mais également coté serveur (on créé des <code>MBeans</code>). Bien sûr, la couche JGroups n'est qu'un prétexte mais je trouvais intéressant de pouvoir s'appuyer sur ce dernier pour être notifié de changement dans le système. Si je suis motivé, j'intégrerais peut être une implémentation NoSQL pour stocker et partager les JMXConnector ou un truc du genre&hellip; ;&ndash;)</p>

<p>Par contre, je n'ai pas testé le comportement dans le cas où des notifications seraient émises&hellip; en outre, si un service de <strong>Relation</strong> JMX était utilisé, je pense que cela pourrait poser quelques soucis&hellip;</p>

<p>A noter que je suis tombé tout récemment sur une <a href="http://blog.infin-it.fr/2010/08/05/aggregateur-jmx-2/">autre solution</a> (que je n'ai pas testé) qui permet d'aggréger des informations JMX au sein d'un même serveur <code>MBeanServer</code>. La cible n'est pas tout à fait identique mais peut être suffisante pour la plupart des cas&hellip; par contre, il faut aimer Spring&hellip; ;&ndash;)</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li>Site officiel de JGroups : <a href="http://www.jgroups.org/">http://www.jgroups.org/</a></li>
<li>Wiki de JGroups : <a href="http://community.jboss.org/wiki/JGroups">http://community.jboss.org/wiki/JGroups</a></li>
<li>Site de la JSR 3 &ndash; Java Management Extensions (JMX) Specification : <a href="http://www.jcp.org/en/jsr/detail?id=3">http://www.jcp.org/en/jsr/detail?id=3</a></li>
<li>Site de la JSR 160 &ndash; Java Management Extensions (JMX) Remote API : <a href="http://jcp.org/en/jsr/detail?id=160">http://jcp.org/en/jsr/detail?id=160</a></li>
<li>Site officiel d'Oracle sur JMX : <a href="http://www.oracle.com/technetwork/java/javase/tech/docs-jsp-135989.html">http://www.oracle.com/technetwork/java/javase/tech/docs-jsp-135989.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pour les gouverner tous - partie 2/3]]></title>
    <link href="http://blog.jetoile.fr/2011/02/pour-les-gouverner-tous-partie-23.html"/>
    <updated>2011-02-20T18:41:34+01:00</updated>
    <id>http://blog.jetoile.fr/2011/02/pour-les-gouverner-tous-partie-23</id>
    <content type="html"><![CDATA[<p><img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/TUcoTratqiI/AAAAAAAAAUQ/Gmc1h0rvA2w/s1600/jmx_jgroups01.png" alt="left-small" /></p>

<p>Cet article fait suite à mon <a href="/2011/01/pour-les-gouverner-tous-partie-13.html">article précédent</a> et a pour objectif de présenter un petit POC (<em>Proof Of Concept</em>) simplicime mettant en oeuvre JGroups en version 2.11.0.GA (la dernière version stable à ce jour). Le principe est de montrer comment il est possible d'utiliser JGroups pour permettre à plusieurs instances d'une même application de se partager les valeurs d'une donnée. Enfin, pour être plus précis, cet objet partagé ne le sera pas vraiment (ndlr : partagé) par toutes les instances mais il s'agira plutôt de permettre à chaque nouvelle instance de récupérer la valeur d'une donnée auprès des autres instance déjà présentes dans le système. En outre, les autres instances déjà présentes devront recevoir directement la valeur de la donnée de la nouvelle instance.</p>

<p>L'autre raison d'être de cet article permettra d'introduire la couche protocolaire utilisée par mon petit POC qui permet de rendre distribuable un agent JMX dans une architecture distribuée.</p>

<!-- more -->


<h1>Spécification des besoins/pré-requis</h1>

<p>Ce projet s'appuiera sur les pré-requis suivant :</p>

<ul>
<li><a href="http://www.slf4j.org/">slf4j</a>/<a href="http://logback.qos.ch/">logback</a> pour la partie log</li>
<li><a href="http://maven.apache.org/index.html">maven 3</a> (ou 2 au choix) pour la partie build</li>
<li>et&hellip; <a href="http://www.jgroups.org/">JGroups</a> dans sa version 2.11.0.GA ;&ndash;)</li>
</ul>


<p>Coté tests unitaires, je m'excuse préalablement auprès de vous, mais il n'y en aura pas&hellip; et cela pour deux raisons que je vous laisse choisir :</p>

<ul>
<li>je suis flemmard ;&ndash;) mais surtout, je n'ai pas envie de mocker la terre entière.</li>
<li>ce petit programme est plus une utilisation basique de JGroups et, le produit fonctionnant bien, je ne vois pas l'intérêt de le retester. En outre, ici, il est plus intéressant de tester de manière intégrée que de manière unitaire en raison de l'aspect distribué de l'application.</li>
</ul>


<p>Comme je l'ai mentionné précédemment dans l'introduction, le but de cet article est simple : une application dispose de plusieurs instances qui se trouvent sur des JVM distinctes (il peut donc s'agir d'instances exécutées sur une ou plusieurs machines).</p>

<ul>
<li>Si une nouvelle instance est démarrée, elle doit pouvoir demander à toutes les autres instances de l'application la valeur d'une donnée X afin, par exemple, de connaître leur état.</li>
<li>De plus, toutes les instances déjà existantes dans le système doivent pouvoir être notifiées de l'arrivée d'une nouvelle instance et, par la même occasion, recevoir sa valeur courante de la donnée X.</li>
<li>Enfin, si une instance disparait du sytème (arrêt, &hellip;), toutes les instances doivent automatiquement supprimer en leur sein la valeur de la donnée de l'instance incriminée.</li>
</ul>


<p>Coté configuration de JGroups, cet article s'appuiera sur une configuration par défaut, c'est à dire une configuration en UDP.</p>

<h1>Architecture de l'application</h1>

<p>Comme vous pouvez vous en douter, l'architecture de l'application sera simple puisque JGroups fournit nativement de nombreuses possibilités. Aussi, je ne présenterai pas de super conception.</p>

<p>Par contre, si les termes <strong>ReceiverAdapter</strong>, <strong>MembershipListener</strong> ou <strong>View</strong> ne vous parlent pas, je vous renverrai :</p>

<ul>
<li>soit, à mon <a href="http://jetoile.blogspot.com/2010/12/jgroups-tour-d.html">article</a> sur JGroups ;&ndash;)</li>
<li>soit (mieux), à la <a href="http://www.jgroups.org/ug.html">documentation</a> officielle de ce dernier.</li>
</ul>


<p>Notre application sera composée de trois parties :</p>

<ul>
<li>La partie donnée : la classe <code>Data</code> représentera la donnée à faire transiter. Il s'agira d'un simple POJO qui sera, bien sûr, sérialisable.</li>
<li>La partie notification de changement de l'infrastructure (ie. arrivé ou arrêt d'une instance dans le système) : la classe <code>ChangeInfraListener</code> qui implémentera l'interface <code>MembershipListener</code> et donc la méthode <code>viewAccepted()</code> <em>call-backé</em> par JGroups pour notifier d'un changement au niveau d'une des ses vues.</li>
<li>La partie qui aura à sa charge l'exposition de la donnée représentée par la classe <code>Data</code> et qui aura initialisera l'application : la classe <code>JGroupsClient</code> qui étendra la classe <code>ReceiverAdapter</code> afin de permettre aux autres instances d'interargir avec.</li>
</ul>


<p>Coté canaux, l'application en utilisera un seul canal : le canal <em>&ldquo;channel&rdquo;</em> qui sera utilisé pour être être notifié de changement d'état sur la vue (il sera donc connecté à la classe implémentant l'interface <code>MembershipListener</code> (ie. <code>ChangeInfraListener</code>) et qui sera également utilisé pour la communication point à point entre les différentes instances : pour rappel, à un membre d'une vue est associée une adresse unique et une vue contient l'ensemble des membres de cette dernière.</p>

<p>A noter que pour la récupération de la donnée au démarrage d'une instance, il aurait également été possible d'implémenter les méthodes <code>getState()</code> et <code>setState()</code> (en combinaison de l'utilisation de la méthode <code>connect(&lt;String&gt; , &lt;Address&gt;, &lt;String&gt;, &lt;long&gt;)</code> sur l'instance de <code>Channel</code> utilisée). Cependant, il était, quand même nécessaire d'implémenter la méthode <code>viewAccepted()</code> afin d'être notifié du démarrage ou de l'arrêt d'une instances dans le système et cela aurait été redondant avec les notifications reçues (en effet, récupérer l'état des autres instances des membres de la vue ne dispense pas de recevoir l'état de la vue via la méthode <code>viewAccepted()</code>). Aussi, je n'ai pas utilisé cette fonctionnalité de JGroups.</p>

<p>Diagramme de séquence lors de la connexion d'une nouvelle instance de l'application au système, coté nouvelle instance mais aussi coté instances déjà présentes dans le système :</p>

<p><img src="http://4.bp.blogspot.com/-DsKcW_KWIZM/TWFDF_0MbsI/AAAAAAAAAUw/EAXva9PJsm8/s1600/jgroups_seq_diagram.png" alt="medium" /></p>

<h1>Mise en oeuvre</h1>

<p>A noter que le code écrit ici ne contiendra pas les imports par souci de lisibilité.</p>

<h2>La classe JGroupsClient</h2>

<p>Commençons donc par la mise en oeuvre de la classe <code>JGroupsClient</code> :</p>

<p>```java
package com.jetoile.jgroups.sample;
public class JGroupsClient extends ReceiverAdapter {</p>

<pre><code>final static private Logger LOGGER = LoggerFactory.getLogger(JGroupsClient.class);

final private Data data = new Data();
private RpcDispatcher rpcDispatcher;
private Channel channel;

public JGroupsClient(final String data) {
    this.data.setData(data);
}

public void stop() throws IOException {
    this.channel.close();
}

public void start() throws ChannelException {
    this.channel = new JChannel("default-udp.xml");

    final ChangeInfraListener changeSetListener = new ChangeInfraListener(channel);
    rpcDispatcher = new RpcDispatcher(this.channel, null, changeSetListener, this);
    changeSetListener.setRpcDispatcher(rpcDispatcher);
    this.channel.connect("privateChannel");
    this.data.setAddress(this.channel.getAddress());
}

public Data getData() {
    return this.data;
}
</code></pre>

<p>}
```</p>

<p>Dans cette classe, on observe donc que l'on a :</p>

<ul>
<li>la méthode <code>start()</code> qui a à sa charge la partie connexion à JGroups,</li>
<li>la méthode <code>getData()</code> qui correspond à la méthode exposée utilisée pour transmettre la valeur de la donnée aux autres instances.</li>
</ul>


<h2>La classe ChangeInfraListener</h2>

<p>Pour la classe <code>ChangeInfraListener</code>, nous aurons :
```java
package com.jetoile.jgroups.sample;</p>

<p>public class ChangeInfraListener implements MembershipListener {</p>

<pre><code>final static private Logger LOGGER = LoggerFactory.getLogger(ChangeInfraListener.class);

final private Map&lt;Address, String&gt; dataCache = new HashMap&lt;Address, String&gt;();

final private Channel privateChannel;

private RpcDispatcher rpcDispatcher;

public ChangeInfraListener(final Channel privateChannel) {
    this.privateChannel = privateChannel;
}

public void setRpcDispatcher(RpcDispatcher rpcDispatcher) {
    this.rpcDispatcher = rpcDispatcher;
}

@Override
public void viewAccepted(View new_view) {
    // when a new member is up
    List&lt;Address&gt; newAddresses = getNewAddresses(new_view.getMembers());

    newAddresses.remove(privateChannel.getAddress());

    List&lt;Address&gt; ads = new ArrayList&lt;Address&gt;();
    for (Address ad : newAddresses) {
        if (!dataCache.containsKey(ad)) {
            ads.add(ad);
        }
    }

    if (!ads.isEmpty()) {
        MethodCall methodCall = new MethodCall("getData", new Object[] {}, new Class[] {});
        LOGGER.debug("invoke remote getData on: {}", ads);

        RspList resps = rpcDispatcher.callRemoteMethods(ads, methodCall, RequestOptions.SYNC);
        LOGGER.debug("after invoke getData - nb result {}", resps.numReceived());

        if (resps.numReceived() == 0) {
            LOGGER.debug("retry...");
            resps = rpcDispatcher.callRemoteMethods(ads, methodCall, RequestOptions.SYNC);
        }

        for (Object resp : resps.getResults()) {
            Data data = (Data) resp;
            LOGGER.debug("new data: {}", data);
            dataCache.put(data.getAddress(), data.getData());
        }
    }

    List&lt;Address&gt; olds = getObsoleteAddresses(new_view.getMembers());
    for (Address old : olds) {
        LOGGER.debug("remove data: {}", old);
        dataCache.remove(old);
    }
}

@Override
public void suspect(Address suspected_mbr) {
    // NOTHING TO DO
}

@Override
public void block() {
    // NOTHING TO DO
}

List&lt;Address&gt; getNewAddresses(Vector&lt;Address&gt; newMembers) {
    List&lt;Address&gt; result = new ArrayList&lt;Address&gt;();
    for (Address address : newMembers) {
        if (!this.dataCache.containsKey(address)) {
            result.add(address);
        }
    }
    return result;
}

List&lt;Address&gt; getObsoleteAddresses(Vector&lt;Address&gt; newMembers) {
    List&lt;Address&gt; result = new ArrayList&lt;Address&gt;();
    for (Address address : this.dataCache.keySet()) {
        if (!newMembers.contains(address)) {
            result.add(address);
        }
    }
    return result;
}
</code></pre>

<p>}
```</p>

<p>Dans cette classe, on observe que la méthode <code>viewAccepted()</code> (qui est la méthode <em>call-backé</em> par JGroups lors d'une modification de la vue (ie. lors de la connexion ou de la déconnexion d'un autre membre du groupe)), invoque, si un nouveau membre est apparu, l'appel de la méthode distante <code>getData()</code> sur la nouvelle instance en question.</p>

<p>Il est intéressant de noter l'utilisation qui est faite de la classe <code>RequestOptions</code> mais également le fait que les méthode <code>block()</code> et <code>suspect()</code> n'ont pas été spécifiées dans notre cas d'utilisation.</p>

<h2>La classe Data</h2>

<p>Enfin, la classe <code>Data</code> qui sera utilisée est la suivante (par souci de lisibilité, les méthodes <code>equals()</code> et <code>hashCode()</code> ne sont pas détaillées ici) :</p>

<p>```java
package com.jetoile.jgroups.sample;</p>

<p>public class Data implements Serializable {
 private Address address;
 private String data;</p>

<p> public Data() {
 }</p>

<p> public Address getAddress() {
  return address;
 }</p>

<p> public void setAddress(final Address address) {
  this.address = address;
 }</p>

<p> public String getData() {
  return data;
 }</p>

<p> public void setData(String data) {
  this.data = data;
 }</p>

<p> @Override
 public int hashCode() {
  // cf. gitHub
  return 0;
 }</p>

<p> @Override
 public boolean equals(Object obj) {
  // cf. gitHub
  return true;
 }</p>

<p> @Override
 public String toString() {
  return &ldquo;Data [address=&rdquo; + address + &ldquo;, data=&rdquo; + data + &ldquo;]&rdquo;;
 }
}
```</p>

<p>Cette classe, comme on peut le remarquer, n'a rien de particulier, si ce n'est qu'elle est sérialisable.</p>

<p>Ainsi, on peut voir que l'implémentation est très simple (je ne commenterai donc pas ce qui est fait ici&hellip;).</p>

<h1>Exécution et utilisation</h1>

<p>L'exécution, quant à elle, pourra se faire avec une classe de type :
```java
package com.jetoile.jgroups.sample.sample;</p>

<p>public class JGroupsClientTest {</p>

<p> public static void main(String[] args) throws ChannelException {
  JGroupsClient jgroupsClient = new JGroupsClient(&ldquo;toto&rdquo;);
  jgroupsClient.start();
 }
}
<code>
A noter que si les différentes instances venaient à ne pas se voir, cela peut provenir d'un souci avec la configuration réseau et qu'il est possible de palier à ce problème en forçant l'utilisation d'adresse IPV4 avec l'option JVM suivante :
</code>bash
-Djava.net.preferIPv4Stack=true
```</p>

<h1>Conclusion</h1>

<p>On a vu ici que permettre la communication d'instances d'une application de manière distribuée était aisée avec JGroups. Bien sûr (et comme je l'ai fait remarqué précédemment), la notion de <em>tuning</em> de JGroups (ie. la configuration de la couche protocolaire &ndash; cf. mon <a href="/2010/12/jgroups-tour-d.html#protocoles">article précédent</a>) n'a pas été abordée, mais cela doit être fait en fonction des besoins de l'infrastructure (trafic réseau, firewall, sécurité, &hellip;) et je laisse donc ce point à la convenance de chacun ;&ndash;).</p>

<p>Ici se clôture donc la partie JGroups de notre petit POC jmanager4all qui nous a permis de voir comment JGroups répondait à notre besoin mais également comment il allait être utilisé par la suite.</p>

<p>Le prochain article s'attaquera donc à la partie interopérabilité avec JMX.</p>

<p>A oui&hellip; j'oubliais&hellip; le code de se petit POC se trouve sur GitHub : <a href="https://github.com/jetoile/jgroups-sample">https://github.com/jetoile/jgroups-sample</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pour les gouverner tous - partie 1/3]]></title>
    <link href="http://blog.jetoile.fr/2011/01/pour-les-gouverner-tous-partie-13.html"/>
    <updated>2011-01-31T18:37:27+01:00</updated>
    <id>http://blog.jetoile.fr/2011/01/pour-les-gouverner-tous-partie-13</id>
    <content type="html"><![CDATA[<p><img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/TUcoTratqiI/AAAAAAAAAUQ/Gmc1h0rvA2w/s1600/jmx_jgroups01.png" alt="left-small" /></p>

<p>Pour ceux qui l'auraient manqués (comment ça? Personne ne me suit&hellip; :( ), j'ai annoncé dans un post précédent que j'avais ouvert un compte sur GitHub pour hoster du code. Bien sûr, il y avait une petite idée derrière&hellip; ;&ndash;)</p>

<p>En fait, l'idée est partie d'un constat assez simple : sur différent projet, à chaque fois que j'ai voulu mettre en place JMX, ce qui m'a toujours <em>profondément</em> attristé était de ne pas pouvoir regrouper l'ensemble des informations des MBeans à un même endroit, c'est-à-dire, qu'il me fallait me demander où se trouvait tel ou tel MBean dans mon système alors que j'aurais aimé pouvoir me connecter sur n'importe quelle instance de mon système et y trouver tous les MBeans présents dans mon système. Enfin, pour être plus précis, j'aurais aimé pouvoir me connecter à n'importe quelle JVM qui hébergeait mon application et avoir accès à tous les serveurs JMX.</p>

<!-- more -->


<p>Bien sûr, me direz-vous, il existe des solutions comme Hyperic qui permettent d'agréger toutes les informations et d'offrir une solution à mon problème. Cependant, cela ne répondait pas à une des problématiques que j'ai pu avoir il y a quelques temps : dans le cas où il ne doit pas y avoir de serveurs dans mon système (même passif), une telle solution n'est pas envisageable. En effet, dans l'architecture de cette application, tous les noeuds de mon système étaient au même niveau hiérarchique afin d'éviter d'avoir un single point of failure. Aussi, introduire un manageur pour administrer mon système n'était pas envisageable. En outre, un autre des pré-requis de ce projet était qu'il n'y avait pas de connaissance préalable de où tournait mon application (au sens scalabilité du terme) : tout poste était susceptible de démarrer l'application sans qu'un serveur centralisé n'en ait connaissance.</p>

<p>Aussi, vous l'aurez compris, l'idée est, ici, de proposer une ébauche de solution pour répondre à la problématique précédemment citée : pour n'importe quelle application susceptible d'être exécutée de manière distributée, être capable d'avoir sur chacune la connaissance (connaissance au sens supervision et administration et non au sens applicatif du terme&hellip;) de l'état de mes autres instances.</p>

<p>En outre, cette petite mise en oeuvre était également un bon prétexte pour utiliser JGroups et JMX et montrer comment il était possible de les utiliser.</p>

<p>La problématique étant posée, je vous propose donc une petite boite à outils permettant de faire cela de manière simple : en démarrant son application et en positionnant un agent sur la JVM, elle permet de remonter dans le serveur JMX courant tous les MBeans se trouvant sur les autres serveurs JMX (modulo qu'ils aient été démarrés par une JVM où l'agent aurait été mis).</p>

<p>Pour ce faire, un premier choix a été de m'appuyer sur JGroups pour connaitre et être informé de l'état de mon système : je n'avais pas envie de gérer toutes les problématiques de Heartbeat &amp; co. et j'ai donc décidé de déléguer à JGroups cette problématique. En outre, cela permettait une plus grande configuration de la couche de découverte et de surveillance de mon système puisque JGroups possédait déjà une grande facilité de configuration.</p>

<p>La série d'articles qui suivra expliquera donc comment cela fonctionne et sur quoi je me suis appuyé pour le faire.</p>

<p>Elle sera découpée en deux parties :</p>

<ul>
<li><a href="/2011/02/pour-les-gouverner-tous-partie-23.html">La première partie</a> fournira une sorte de pseudo exemple d'utilisation de JGroups en proposant une solution permettant lors de l'utilisation d'une application distribuée de récupérer et de conserver localement l'état d'un objet distant dans une sorte de cache tout en supprimant cet objet si l'application distante est arrêtée.</li>
<li><a href="/2011/02/pour-les-gouverner-tous-partie-33.html">La deuxième partie</a> (ajoutera l'utilisation de JMX pour permettre la récupération des MBeans distants ainsi que leurs enregistrement dans le MBeanServer courant.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JGroups : tour d'horizon]]></title>
    <link href="http://blog.jetoile.fr/2010/12/jgroups-tour-d.html"/>
    <updated>2010-12-28T17:42:18+01:00</updated>
    <id>http://blog.jetoile.fr/2010/12/jgroups-tour-d</id>
    <content type="html"><![CDATA[<p><img src="http://2.bp.blogspot.com/_XLL8sJPQ97g/TRtn71JxZPI/AAAAAAAAATI/0vNqJjOXKlY/s1600/jgroups_logo_450px.png" alt="left-small" />
Actuellement, le besoin de rendre les systèmes ou les applications interopérables est indéniable. Pour ce faire, de nombreuses technologies ont vues le jour. Il peut s'agir des MOM (<em>Message-Oriented Middleware</em>), des protocoles de communication entre les applications clientes et serveurs (REST, Soap, RMI, &hellip;), de solutions propriétaires utilisées pour permettre la communication entre les serveurs pour des problématiques de réplication ou de synchronisation ou même de solutions basées sur le paradigme NoSQL.</p>

<p>Cependant, il est important de ne pas oublier que nos couches basses restent les protocoles TCP ou UDP et que répondre par un grand concept tel que MOM, réplication de serveurs ou cache distribué sur une problématique ne permet pas de savoir ce qui se trame derrière&hellip;</p>

<p>Un produit souvent méconnu est utilisé en interne pour les problématiques de communication entre serveurs et même si, à ce jour, je ne connais pas d'implémentations de MOM qui l'utilise, il pourrait être un très bon candidat pour ces dernières en interne. Il s'agit de JGroups.</p>

<p>Aussi, cet article va tenter de donner un rapide tour d'horizon sur <a href="http://www.jgroups.org/">JGroups</a> en présentant ses concepts. Il s'appuiera sur sa version stable courante, à savoir la version 2.11.0.</p>

<p>A noter que ce tour d'horizon s'appuie très fortement sur le manuel de référence de JGroups.</p>

<!-- more -->


<p>Cet article suivra le plan suivant :</p>

<ul>
<li><a href="#histoire">Un peu d'histoire</a></li>
<li><a href="#concept">Présentation des concepts</a>

<ul>
<li><a href="#canal">Canal</a></li>
<li><a href="#bloc">Bloc de construction</a></li>
<li><a href="#pile">Pile de protocoles</a></li>
<li><a href="#entete">Entête</a></li>
<li><a href="#evenement">Evénement</a></li>
</ul>
</li>
<li><a href="#api">Présentation des APIs de JGroups</a>

<ul>
<li><a href="#interface">Les interfaces</a>

<ul>
<li><a href="#messageListener">MessageListener</a></li>
<li><a href="#membershipListener">MembershipListener</a></li>
<li><a href="#channelListener">ChannelListener</a></li>
<li><a href="#receiver">Receiver</a></li>
<li><a href="#receiverAdapter">ReceiverAdapter</a></li>
</ul>
</li>
<li><a href="#address">L'interface Address</a></li>
<li><a href="#message">La classe Message</a></li>
<li><a href="#view">La classe View</a>

<ul>
<li><a href="#viewId">La classe ViewId</a></li>
<li><a href="#mergeView">La classe MergeView</a></li>
<li><a href="#jchannel">La classe JChannel</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#construction">Les blocs de construction</a>

<ul>
<li><a href="#messageDispatcher">MessageDispatcher</a></li>
<li><a href="#rpcDispatcher">RpcDispatcher</a></li>
<li><a href="#replicationHashMap">ReplicatedHashMap</a></li>
<li><a href="#notificationBus">NotificationBus</a></li>
</ul>
</li>
<li><a href="#protocole">Liste des protocoles</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>


<p><a name="histoire"></a></p>

<h1>Un peu d'histoire&hellip;</h1>

<p>Créé par Bela Ban, JGroups a vu le jour suite à son travail universitaire dans les équipe de Ken Birman sur le framework <em>Ensemble</em> qui, en 1998-1999, était un prototype pour la troisième génération de communication de groupes. <em>Ensemble</em> faisait suite à <em>Horus</em> (écrit par Robbert VanRenesse) qui faisait lui-même suite à <em>ISIS</em> (écrit par Keb Birman) et était écrit en OCaml. <em>Ensemble</em> proposant une interface pour s'interfacer avec Java mais s'appuyant sur son coeur, cela a été le début de JGroups (enfin pour être plus précis le début de <em>JChannel</em> puis de la partie <em>ProtocolStack</em>) qui avait pour objectif de fournir une solution full Java de Ensemble.</p>

<p>Ainsi, JGroups a pris son essor en 2000 avec le départ de Bela Ban du pôle de recherche de l'université de Cornell pour enfin être utilisé par JBoss dès 2002 avec, entre autre <em>JBossCache</em>.</p>

<p><a name="concept"></a></p>

<h1>Présentation des concepts</h1>

<p>La communication entre groupes utilise les termes de groupes et de membres qui font partis intégrantes des groupes. En fait, un membre peut être vu comme un noeud et un groupe comme un cluster.</p>

<p>En fait, un noeud est un processus qui réside sur une machine hôte et un cluster est constitué d'un ou de plusieurs noeuds, sachant que plusieurs noeuds peuvent résider sur le même hôte et qu'ils peuvent appartenir à un ou plusieurs clusters.</p>

<p>JGroups est un framework permettant la communication fiable entre groupes et permets aux processus :</p>

<ul>
<li>de rejoindre un groupe,</li>
<li>d'envoyer des messages à tout ou partie des membres du groupe,</li>
<li>et de recevoir les messages des membres du groupe.</li>
</ul>


<p>En outre, JGroups permet de garder de notifier les membres de chaque groupe lors de l'arrivé d'un nouveau membre ou d'un départ ou arrêt brutal de l'un d'eux.</p>

<p>Un <strong>groupe</strong> est identifié par son nom et n'a pas besoin d'être créé explicitement puisqu'il est créé automatiquement.</p>

<p>En fait, l'architecture de JGroups s'articule autour de trois points :</p>

<ul>
<li>les canaux (<strong>channel</strong>) utilisés par les applications pour leurs permettre de prendre part au groupe de communication fiable,</li>
<li>les blocs de construction (<strong>building blocks</strong>) qui sont des couches au dessus des canaux qui permettent d'abstraire ces derniers de la pile de protocoles à utiliser,</li>
<li>la pile de protocoles qui implémentent les propriétés d'un canal donné.</li>
</ul>


<p>En fait, un canal est connecté à une pile (<em>stack</em>) de protocoles et lorsqu'une application émet un message, le canal le transmet au travers de cette pile pour effectuer séquentiellement des traitements jusqu'à la couche réseau. De manière similaire, pour qu'une application reçoive un message, ce dernier doit repasser dans cette pile de protocole (dans l'ordre inverse des traitements qu'il a subi lors de son émission) jusqu'à arriver à canal qui gère la file des messages jusqu'à leurs consommations par l'application.</p>

<p>Il est à noter que lorsqu'une application se connecte à un canal, la pile de protocole est démarrée et que lorsqu'elle se déconnecte, cette même pile est arrêtée. Quand le canal est fermé, la pile est détruite permettant ainsi de libérer ses ressources.</p>

<p><a name="canal"></a></p>

<h2>Canal (Channel)</h2>

<p>Pour joindre un groupe et émettre des messages, un processus doit créer un canal et s'y connecter en utilisant le nom du groupe puisque tous les canaux qui possèdent le même nom forment un même groupe.</p>

<p>Une fois connecté, un membre peut émettre (resp. recevoir) des messages aux (resp. des) autres membres du groupe.</p>

<p>Il quitte le groupe en se déconnectant du canal permettant ainsi sa réutilisation. Cependant, un canal ne gère qu'un seul client simultanément.</p>

<p>Le client a également la possibilité de signaler qu'il ne désire plus utiliser un canal en le fermant. Dans ce cas, le canal ne peut plus être utilisé.</p>

<p>Chaque canal dispose d'une adresse unique et est toujours connu des autres membres de son groupe : une liste d'adresse des membres peut être récupérée d'un canal et est appelé vue (<strong>view</strong>).</p>

<p>Un processus peut alors sélectionner une adresse dans cette liste et émettre un message à destination de l'unique membre associé à cette adresse (mais également à lui-même puisqu'il appartient à la vue) ou émettre un message à tous les membre de la vue (et donc au groupe).</p>

<p>Pour gérer les vues :</p>

<ul>
<li>lorsqu'un membre rejoint le groupe ou qu'il s'arrête (déconnexion ou détection de crash), JGroups envoie une nouvelle vue à tous les membres du groupes.</li>
<li>lorsqu'un membre est suspecté comme ayant potentiellement crashé, un message de suspicion est émis à destination de tous les membres non fautif.</li>
</ul>


<p>Ainsi, un canal peut recevoir trois types de messages ;</p>

<ul>
<li>les messages normaux (ie. un message émis par une application),</li>
<li>les messages de vues lors de l'ajout ou du retrait d'un de ses membres,</li>
<li>les messages de suspicion.</li>
</ul>


<p>Bien sûr, un client peut choisir s'il accepte de recevoir les messages de types vue ou suspicion.
En fait, les canaux sont similaires à des sockets BSD ; les messages sont stockés dans le canal jusqu'à temps qu'ils soient consommés par un client (approche <em>pull</em>). Dans le cas où il n'y a pas de messages, le client est bloqué. Cependant, JGroups propose également la notion de push pour recevoir les messages en se basant sur la notion de <em>callback</em> (ou, du point de vue client, de <em>Listener</em>). Il est à noter que le fonctionnement en mode <em>pull</em> tend à être supprimé en version 3 de JGroups : il est donc déconseillé de l'utiliser.</p>

<p>Afin de positionner les propriétés sur un canal, JGroups s'appuie sur une configuration XML.</p>

<p><a name="bloc"></a></p>

<h2>Bloc de construction (Building Blocks)</h2>

<p>Le canal est un concept simple qui permet de fournir la fonctionnalité basique d'un groupe de communication en proposant une douzaine de méthodes qui permettent la communication entre applications via la transmission de messages asynchrones sur le même modèle que UDP. Ainsi, par exemple, le canal de base ne gère pas l'ordonnancement des messages et il est alors à la charge de l'application de réordonnancer les messages. En outre, le fonctionnement en mode <em>pull</em> nécessite généralement au client d'avoir à gérer un thread pour éviter de bloquer l'application lorsqu'il attend un message.</p>

<p>Ainsi, JGroups propose la notion de blocs de construction (<strong>Building Blocks</strong>) qui offre une API plus sophistiquée et qui s'appuie, en interne, sur les canaux.</p>

<p>Cela permet aux applications de communiquer en utilisant ces derniers en offrant une plus grande facilité d'utilisation du groupe de communication (par exemple, certains blocks permettent de gérer nativement les identifiants des corrélations).</p>

<p><a name="pile"></a></p>

<h2>Pile de protocoles (Protocol Stack)</h2>

<p>La pile de protocoles contient de nombreuses couches de protocoles qui sont bidirectionnels. Tous les messages émis et reçus par le canal doivent passer à travers ces protocoles qui peuvent :</p>

<ul>
<li>modifier,</li>
<li>réordonnancer,</li>
<li>supprimer ou laisser passer un message,</li>
<li>ajouter un entête au message,</li>
<li>découper le message en messages plus petit,</li>
<li>réaggréger un ensemble de messages,</li>
<li>&hellip;</li>
</ul>


<p>La composition de la pile de protocoles (ie. ses couches) est déterminée par le créateur du canal via un fichier XML qui définit et paramètres les différentes couches à utiliser en lui associant un nom.
Cette séparation des concepts permet ainsi d'abstraire l'application, qui utilise un canal, de comment le message est émis et reçu.</p>

<p>Si aucune pile de protocoles n'est fournie lors de la création du canal, alors c'est sa configuration par défaut qui est utilisé.</p>

<p><a name="entete"></a></p>

<h2>Entête (Header)</h2>

<p>Un entête (<strong>Header</strong>) est un ensemble d'informations personnalisables qui peut être ajouté à chaque message.</p>

<p>Il est à noter que JGroups utilise cette fonctionnalité dans de nombreux cas de figures comme, par exemple, pour savoir connaitre l'ordonnancement d'envoi des messages (via les entêtes <em>NAKACK</em> et <em>UNICAST</em>).</p>

<p><a name="evenement"></a></p>

<h2>Evénement (Event)</h2>

<p>Les évènements (<strong>Event</strong>) permettent à JGroups de savoir quels protocoles peuvent communiquer avec quel autre. Ainsi, contrairement aux messages qui transitent au travers du réseau entre les membres d'un groupe, les évènements transitent au travers la pile.</p>

<p><a name="api"></a></p>

<h1>Présentation générale des APIs de JGroups</h1>

<p><a name="interface"></a></p>

<h2>Les interfaces</h2>

<p>JGroups propose un certain nombre d'interfaces principales sur lesquelles s'appuient les différentes implémentations :</p>

<ul>
<li><code>MessageListener</code></li>
<li><code>MembershipListener</code></li>
<li><code>ChannelListener</code></li>
<li><code>Receiver</code></li>
<li><code>ReceiverAdapter</code></li>
</ul>


<p><a name="messageListener"></a></p>

<h3>MessageListener</h3>

<p>L'interface <code>MessageListener</code> permet d'être notifier lors de la réception d'un message lorsque le mode de fonctionnement est de type push.</p>

<p>Pour ce faire, la méthode <code>receive(Message msg)</code> est invoquée. Les méthodes <code>getState()</code> et <code>setState()</code> permettent, quant à elles, de récupérer l'état du groupe.
<img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/TQ4yCVvoq6I/AAAAAAAAAQ8/P05famfiSL4/s1600/jgroups01.png" alt="center" /></p>

<p><a name="membershipListener"></a></p>

<h3>MembershipListener</h3>

<p>L'interface <code>MembershipListener</code> permet d'être notifiée lorsqu'une nouvelle vue, un message de suspicion ou un évènement de bloc est reçu.</p>

<p>Dans la plupart des cas, c'est la méthode <code>viewAccepted()</code> qui est invoquée puisqu'elle notifie lorsqu'un nouveau membre a rejoint le groupe ou que l'un d'entre eux s'est déconnecté ou s'est arrêté brutalement. La méthode <code>suspect()</code> permet d'être informé lorsqu'un membre du groupe est suspecté de s'être arrêté brutalement mais qu'il n'a pas encore été exclu. La méthode <code>block()</code> est invoquée pour indiqué que le membre courant est sur le point d'être d'être exclu des membres qui ont le droit d'émettre des messages.</p>

<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/TQ4yKn49KiI/AAAAAAAAARA/w8UlwBfI1lc/s1600/jgroups02.png" alt="center" /></p>

<p><a name="channelListener"></a></p>

<h3>ChannelListener</h3>

<p>L'interface <code>ChannelListener</code> est utilisée comme interface de <em>callback</em> lorsque l'application souhaite recevoir des informations sur les changements d'état du canal (fermeture, déconnexion ou ouverture).</p>

<p><img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/TQ4ydDBkt5I/AAAAAAAAARE/kEWjYvTnDFs/s1600/jgroups03.png" alt="center" /></p>

<p><a name="receiver"></a></p>

<h3>Receiver</h3>

<p>L'interface <code>Receiver</code> peut être utilisée pour recevoir des messages et les changements de vue dans le mode <em>push</em>. A noter que cette interface est marquée comme dépréciée et sera supprimé en version 3. L'utilisation de <code>MessageListener</code> et <code>MembershipListener</code> est préconisée.</p>

<p><img src="http://1.bp.blogspot.com/_XLL8sJPQ97g/TRoGqAZ288I/AAAAAAAAASg/EshWFLsfHjA/s1600/jgroups04.png" alt="center" /></p>

<p><a name="receiverAdapter"></a></p>

<h3>ReceiverAdapter</h3>

<p>Cette classe permet de fournir une implémentation par défaut de l'interface <code>Receiver</code> en ne permettant d'avoir à implémenter que les méthodes nécessaires (dont la méthode <code>receive()</code>).</p>

<p><img src="http://2.bp.blogspot.com/_XLL8sJPQ97g/TRoG6cQ9F5I/AAAAAAAAASk/orJ7pVnADug/s1600/jgroups05.png" alt="center" /></p>

<p><a name="address"></a></p>

<h2>L'interface Address</h2>

<p>Chaque membre d'un groupe dispose d'une adresse qui l'identifie de manière unique. Cette adresse est représentée par l'interface Address qui require une implémentation concrète afin de fournir ses méthodes de comparaison, de trie et afin de permettre de différencier une adresse de type multicast.</p>

<p>Cependant, une implémentation de l'interface <code>Address</code> ne doit jamais être utilisée directement et l'interface <code>Address</code> doit être vue comme une couche d'abstraction lui permettant d'identifier le noeud dans le cluster. Ses implémentations sont généralement générées par la couche la plus basse du protocole (ie. UDP ou TCP).</p>

<p>Puisque l'adresse identifie de manière unique un canal et plus précisément un membre du groupe, elle peut être utilisée pour émettre des message.</p>

<p>Ainsi, par exemple, dans le cas de <code>JChannel</code>, l'adresse, qui est implémentée par la classe <code>IpAddress</code>, correspond à l'IP de l'hôte sur laquelle se trouve le membre et de son port sur lequel sont reçus les messages.
<img src="http://1.bp.blogspot.com/_XLL8sJPQ97g/TRoHFjviIMI/AAAAAAAAASo/nsGhSwGXwzw/s1600/jgroups06.png" alt="medium" /></p>

<p><a name="message"></a></p>

<h2>La classe Message</h2>

<p>Les échanges de données émis entre les membres se fait au travers de messages qui sont représentés par la classe <code>Message</code>. Un message peut être émis, par un membre, aussi bien à un membre ou à tous les membres du groupe du canal.</p>

<p>Il est composé de cinq parties :</p>

<ul>
<li>L'adresse de destination : si elle vaut <code>null</code>, le message est émis à tous les membre du groupe courant.</li>
<li>L'adresse de l'émetteur : ce champ est optionnel mais sera renseigné par le protocole de transport avant que le message n'atteigne la couche réseau.</li>
<li>Les drapeaux (<strong>flags</strong>) qui est codé sur un octet et qui peut valoir l'une des valeurs suivantes : <code>OOB</code>, <code>LOW_PRIO</code> ou <code>HIGH_PRIO</code>.</li>
<li>Le contenu (<strong>payload</strong>) : codé sous forme de buffers d'octets, la classe <code>Message</code> doit contenir les méthodes permettant de sérialiser et désérialiser l'information transmise.</li>
<li>Les entêtes (<strong>headers</strong>) qui représentent les informations additionnelles au contenu.</li>
</ul>


<p><img src="http://1.bp.blogspot.com/_XLL8sJPQ97g/TQ4y5ZcL1RI/AAAAAAAAARU/3ayXiOTHOIY/s1600/jgroups07.png" alt="center" /></p>

<p><a name="view"></a></p>

<h2>La classe View</h2>

<p>Une vue représente la liste des membres d'un groupe à un instant donné. Elle consiste en un objet de type <code>ViewId</code> qui représente de manière unique la vue ainsi que la liste de ses membres.</p>

<p>Les vues sont gérées automatiquement par la couche de protocoles lorsqu'un nouveau membre rejoint le groupe ou qu'un membre le quitte. Tous les membres d'un groupe voient la même séquence de vues qui sont ordonnées.</p>

<p>Ainsi, généralement, le premier membre d'une vue est le coordinateur (son rôle consiste à émettre les nouvelles vues aux autres membres du groupe). Cela permet, si les membres du groupes changent, de déduire le coordinateur facilement sans avoir à contacter les autres membres du groupe.</p>

<p>A noter que lorsqu'une application est notifiée que le groupe a changé (ie. qu'une nouvelle vue a été reçue), la vue est déjà à sa disposition dans le canal.</p>

<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/TRoHVP9nFLI/AAAAAAAAASs/bdb-orAyhxo/s1600/jgroups08.png" alt="medium" /></p>

<p><a name="viewId"></a></p>

<h3>La classe ViewId</h3>

<p>La classe <code>ViewId</code> est utilisée pour numéroter les vues et consiste en l'adresse du créateur de la vue et en son numéro de séquence.</p>

<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/TRoHeWcBzbI/AAAAAAAAASw/aSNJllb0Q3o/s1600/jgroups09.png" alt="medium" /></p>

<p><a name="mergeView"></a></p>

<h3>La classe MergeView</h3>

<p>Lorsqu'un groupe se retrouve découpé en sous-groupe (par exemple, lors d'un partitionnement du réseau puis de son ré-aggrégement), les vues peuvent nécessiter un merge.</p>

<p>Dans ce cas, un objet de type <code>MergeView</code> qui étend la classe <code>View</code> est reçu par l'application. Cette classe contient, en plus de View, la liste des vues qui ont été mergés.</p>

<p>Ainsi, par exemple, si un groupe est décrit par la vue <em>V1:(p,q,r,s,t)</em>, qu'il subit un découpage en deux sous-groupe <em>V2:(p,q,r)</em> et <em>V2:(s,t)</em>, et que sa vue mergée est <em>v3:(p,q,r,s,t)</em>, alors l'objet <code>MergegView</code> contiendra la liste des deux vues suivantes : <em>v2:(p,q,r)</em> et <em>v2:(s,t)</em>.</p>

<p><img src="http://3.bp.blogspot.com/_XLL8sJPQ97g/TQ4zP2h5POI/AAAAAAAAARg/SUrNkuEtuR8/s1600/jgroups10.png" alt="center" /></p>

<p><a name="jchannel"></a></p>

<h3>La classe JChannel</h3>

<p>Afin de pouvoir joindre un groupe et émettre des messages (ou en recevoir), un processus doit créer un canal. Un canal peut s'assimiler à une Socket. Quand le client se connecte à un canal, il doit donner le nom du groupe qu'il veut rejoindre. En effet, un canal est (dans son mode connecté) toujours associé à un groupe donné. La pile de protocoles a alors à sa charge de vérifier que le canal se joint au groupe du même nom, résultant un nouvelle vue à installer sur chaque membre du groupe.</p>

<p>Si aucun membre existe, le groupe est créé.</p>

<p>A noter que lors de sa création, un canal est dans un état déconnecté. Pour qu'il puisse commencer à traiter des opérations, il doit être dans un état connecté.</p>

<p><img src="http://1.bp.blogspot.com/_XLL8sJPQ97g/TQ40li7dxMI/AAAAAAAAARs/0kqgw2nAHfs/s1600/jgroups12.png" alt="center" /></p>

<p><a name="construction"></a></p>

<h1>Les blocs de construction (Building blocks)</h1>

<p>Les blocs de construction sont les couches qui se trouvent au dessus des canaux. La plupart ne nécessite pas d'un canal mais seulement d'implémenter l'interface <code>Transport</code> (qui est également implémentée par la classe <code>Channel</code>). Cela leurs permet de fonctionner pour n'importe quel type de transport qui implémente cette interface. Les blocs de construction peuvent donc être utilisés à la place des canaux si cela est nécessaire. Ainsi, alors que les canaux peuvent être vus comme des sortes de sockets, les blocs de construction peuvent bénéficier d'une interface beaucoup plus sophistiquée.</p>

<p>Dans la suite, seuls les blocs de construction les plus importants seront décrits (à noter que le bloc de construction <code>PushPullAdapter</code> étant déprécié, il ne sera pas non plus décrit).</p>

<p><a name="messageDispatcher"></a></p>

<h2>MessageDispatcher</h2>

<p>Les canaux sont de simple patron pour émettre et recevoir des messages de manière asynchrone. Cependant, il peut être nécessaire de disposer d'un moyen de communiquer de manière synchrone.</p>

<p>Le <code>MessageDispatcher</code> offre cette possibilité en fournissant la possibilité d'émettre un message (ou requête) en positionnant un identifiant de corrélation afin de pouvoir associer la réponse avec la requête.</p>

<p>Il offre également la possibilité de recevoir un message en mode push.</p>

<p>Pour l'utiliser, il doit être créé associé avec un canal et peut être utilisé coté émetteur ou récepteur.
S'il est utilisé du coté serveur, alors à chaque requête reçu, la méthode <code>handle()</code> provenant de l'interface <code>RequestHandler</code> est invoquée.</p>

<p>Cette méthode retourne le message (qui doit être sérialisable) ou lève une exception qui sont transmises au client.</p>

<p><img src="http://1.bp.blogspot.com/_XLL8sJPQ97g/TQ43hC993TI/AAAAAAAAASE/2mgpujE4eL0/s1600/jgroups14.png" alt="medium" /></p>

<p>S'il est utilisé du coté client, il est possible d'utiliser deux méthodes :</p>

<ul>
<li><code>castMessage()</code> qui permet de requêter un ensemble de destinataires (dans ce cas, si le destinataire est positionné sur l'entête du message, il sera écrasé) et qui renvoie un objet de type <code>RspList</code> (qui implémente l'interface <code>Map</code>)</li>
<li><code>sendMessage()</code> qui permet de requêter un seul destinataire (dans ce cas, le destinataire doit être positionné sur l'entête du message)</li>
</ul>


<p>Ces deux méthodes peuvent positionner un certain nombre d'options lors de l'émission du message encapsuler dans un objet de type <code>RequestOptions</code> tels que :</p>

<ul>
<li>un timeout qui permet d'indiquer le temps qu'il faut attendre la réponse.</li>
<li>le type de requête à émettre :

<ul>
<li>dès qu'une réponse arrive, la méthode castMessage() rend la main au programme (<code>GroupRequest.GET_FIRST</code>)</li>
<li>attend la réponse de chaque destinataire avant de rendre la main au programme (<code>GroupRequest.GET_ALL</code>)</li>
<li>attend la majorité des réponses (<code>GroupRequest.GET_MAJORITY</code>)</li>
<li>attend la majorité absolue des réponses (<code>GroupRequest.GET_ABS_MAJORITY</code>)</li>
<li>n'attend aucune réponse (<code>GroupRequest.GET_NONE</code>)</li>
</ul>
</li>
<li>un filtre pour les réponses attendues à l'aide d'un objet de type <code>RspFilter</code></li>
</ul>


<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/TRoHzicdvtI/AAAAAAAAAS0/OjoJmHdwLHU/s1600/jgroups13.png" alt="center" /></p>

<p>A noter que si un membre destinataire se déconnecte du canal (dans le cas d'un arrêt brutal par exemple), alors l'objet RspList retourner par la méthode castMessage() contiendra une réponse indiquée comme en échec.</p>

<p><a name="rpcDispatcher"></a></p>

<h2>RpcDispatcher</h2>

<p>La classe RpcDispatcher est dérivée de <code>MessageDispatcher</code> et permet donc au programmeur d'invoquer des méthodes distantes sur un ou tous les membres du groupe et, optionnellement, attendre leurs réponses. Cependant, contrairement à l'utilisation d'un <code>MessageDispatcher</code>, l'utilisation d'un <code>RpcDispatcher</code> est plus simple pour un besoin de type requête/réponse puisqu'il ne nécessite pas d'avoir à implémenter l'interface <code>RequestHandler</code> (et donc la méthode <code>handle()</code>).</p>

<p><img src="http://2.bp.blogspot.com/_XLL8sJPQ97g/TQ42co-e7II/AAAAAAAAASA/arjovzck9cY/s1600/jgroups15.png" alt="medium" /></p>

<p>En effet, il est possible d'indiquer lors de l'émission des requêtes (qui se fait à l'aide des méthodes <code>callRemoteMethod()</code> et <code>callRemoteMethods()</code>) quelles seront les méthodes (ainsi que leurs paramètres) qui seront invoqués lors de la réception des réponses.</p>

<p>Les autres paramètres de ces méthodes sont similaires à la méthode <code>castMessage()</code> de la classe <code>MessageDispatcher</code>.</p>

<p>De plus, il est à noter qu'il est possible d'utiliser les méthodes <code>callRemoteMethodWithFuture()</code> et <code>callRemoteMethodsWithFuture()</code> qui, comme leur nom l'indique, permettent de ne pas bloquer l'application lors de l'appel à des méthodes.</p>

<p><img src="http://1.bp.blogspot.com/_XLL8sJPQ97g/TQ44DbehK6I/AAAAAAAAASM/SEJXTcIvnZY/s1600/jgroups16.png" alt="center" /></p>

<p><a name="replicatedHashMap"></a></p>

<h2>ReplicatedHashMap</h2>

<p>La classe <code>ReplicatedHashMap</code> a été écrite comme une classe de démonstration afin de montrer comme les états pouvaient être partagés entre les différents noeuds du cluster. Aussi, elle n'a pas été entièrement testée et n'a pas pour objectif d'être utilisée en production.</p>

<p>Une ReplicatedHashMap utilise une HashMap concurrente en interne et permet de créer différentes instances d'objets de type <code>HashMap</code> dans différents processus. Toutes ces instances possèdent exactement le même état. Lorsqu'une instance de <code>ReplicatedHashMap</code> est créée, un nom de groupe permet de déterminer quel groupe de <code>ReplicatedHashMap</code> est rejoint et la nouvelle instance interroge alors les autres membres existants pour connaitre l'état courant, le met à jour et se démarre.</p>

<p>Les modifications de la <code>ReplicatedHashMap</code> (méthodes <code>put()</code>, <code>clear()</code> ou <code>remove()</code>) sont propagées de manière ordonné dans tout le groupe alors que les lectures (méthode <code>get()</code>) sont faites sur la copie locale.</p>

<p><img src="http://2.bp.blogspot.com/_XLL8sJPQ97g/TQ438y8jKhI/AAAAAAAAASI/QUvyWEKXEXY/s1600/jgroups17.png" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/TQ44U-8aDBI/AAAAAAAAASQ/8P6jK1PT8j8/s1600/jgroups18.png" alt="medium" /></p>

<p><a name="notificationBus"></a></p>

<h2>NotificationBus</h2>

<p>La classe <code>NotificationBus</code> permet d'émettre et de recevoir des notifications. Ainsi, cela permet à une application de maintenir un cache local répliqué avec toutes les autres instances. La classe <code>NotificationBus</code> s'appuie sur un canal en interne.</p>

<p>En fait, le bloc de construction NotificationBus s'apparente à JMS dans son mode <em>publish/subscribe</em>. Cependant, il peut également être utilisé pour faire du point à point en précisant l'adresse du destinataire.</p>

<p><img src="http://1.bp.blogspot.com/_XLL8sJPQ97g/TQ44eSOwW3I/AAAAAAAAASU/l8hNwFLTXYU/s1600/jgroups19.png" alt="medium" /></p>

<p><a name="protocole"></a></p>

<h1>Liste des protocoles</h1>

<p>Ce paragraphe fournit à titre indicatif une liste non exhaustive de protocoles fournies par JGroups. Pour plus d'informations sur la configuration de chacun, il est conseillé de se référer à la documentation <a href="http://www.jgroups.org/ug.html">officielle</a> et/ou au <a href="http://community.jboss.org/wiki/JGroups">wiki</a> dont est issu ce paragraphe.</p>

<table>
<thead>
<tr>
<th>Catégorie </th>
<th> Nom </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Transport </td>
<td> UDP </td>
<td> UDP utilise le protocole multicast IP pour émettre des messages à tous les membres du groupe et des datagrams UDP pour les messages unicast (ie. à destination de membres particuliers). Quand il et démarré, il ouvre un socket multicast et unicast : le socket unicast est utilisé pour émettre et recevoir les messages unicast alors que le socket multicast pour les messages multicast. L'adresse du canal est l'adresse et le port du socket unicast.<br/><br/>Une pile de protocoles  utilisant UDP comme protocole de transport est généralement utilisé avec les groupes dont les membres s'exécute sur le même hôte ou de manière distribué sur le LAN. Il est nécessaire de s'assurer que le multicast IP est supporté entre les sous-réseau, ce qui n'est souvent pas le cas. Dans ce dernier cas de figure, il est préférable d'utiliser le protocole de transport TCP.</td>
</tr>
<tr>
<td></td>
<td> TCP </td>
<td> TCP permet d'indiquer à JGroups qu'il doit s'appuyer sur le protocole de transport TCP pour émettre des messages à travers les membres du groupe. Dans ce cas, les membres du groupe créé un réseau de connexions TCP.</td>
</tr>
<tr>
<td></td>
<td>TCP_NIO    </td>
<td> TCP_NIO est une implémentation de TCP ne bloquant pas les I/O. Cependant, il n'est pas conseillé de l'utiliser en production mais d'utiliser plutôt le protocole TCP.</td>
</tr>
<tr>
<td></td>
<td> TUNNEL    </td>
<td> TUNNEL est un protocole de transport qui fonctionne en ouvrant une connexion TCP sur un routeur de message (tel que le Gossip Router). Tous les membres d'un groupe utilisant le protocole TUNNEL doivent être connectés au même routeur qui a pour rôle de transmettre les messages.<br/><br/>Il peut être utilisé dans le cas où des firewalls sont en place.</td>
</tr>
<tr>
<td>Découverte </td>
<td> PING </td>
<td>    Le protocole PING permet de récupérer les membres du groupe. Il est utilisé pour détecter le coordinateur (le membre le plus vieux) soit en utilisant une requête PING multicast à l'adresse IP MCAST, soit en se connectant au GossipRouteur : chaque membre du groupe répond alors avec un paquet {C, A} où C est l'adresse du coordinateur et A est sa propre adresse. Cela permet de déterminer le coordinateur en fonction des réponses, permettant ainsi d'émettre une requête de type JOIN au coordinateur.<br/><br/>Si personne ne répond alors on considère qu'il s'agit du premier membre du groupe.<br/><br/>A noter que, contrairement à TCPPING, PING permet une découverte dynamique et n'a donc pas besoin d'avoir la connaissance des autres membres du groupe.</td>
</tr>
<tr>
<td></td>
<td> TCPPING </td>
<td> Le protocole TCPPING permet de récupérer les membres initiaux du groupe en contactant directement (ie. en point-à-point) les autres membres du groupe suite à la réception d'un message de type FIND_INITIAL_MBRS émit par le protocole GSM. Les réponses permettent de déterminer qui est le coordinateur du groupe.<br/><br/>A noter que, si le noeud courant est le serveur (ie. après avoir reçu un message de type BECOME_SERVER), alors il répondra aux requêtes de type TCPPING avec un message de type TCPPING.<br/><br/>TCPPING requière une configuration statique qui permet de savoir à l'avance où trouver les autres membre du groupe.<br/><br/>Pour permettre une découverte dynamique des autres membres avec une pile de protocole qui s'appuie sur TCP, il est possible d'utiliser soit le protocole MPING (qui utilise un découverte multicast), soit le protocole TCPGOSSIP (qui contacte le GossipRouteur pour obtenir les membres initiaux).</td>
</tr>
<tr>
<td></td>
<td> TCPGOSSIP </td>
<td>   Le protocole TCPGOSSIP permet de récupérer les membres initiaux du groupe (utilisé par le protocole GMS et initié lors de la réception d'un message de type FIND_INITIAL_MBRS).<br/><br/>Cela s'effectue en contactant le ou les GossipRouteur qui doivent se trouver à des adresses/ports connus. Les réponses reçues doivent permettre de déterminer le coordinateur qui doit être contacté dans le cas où le noeud courant souhaite rejoindre le groupe.<br/><br/>A noter que, si le noeud courant est le serveur (ie. après avoir reçu un message de type BECOME_SERVER), alors il répondra aux requêtes de type TCPGOSSIP avec un message de type TCPGOSSIP.</td>
</tr>
<tr>
<td></td>
<td> MPING </td>
<td>   MPING (pour Multicast PING) utilise les IP multicast pour déterminer les membres initiaux du groupe. Il peut être utilisé avec tous les types de transport mais il s'applique plus généralement avec le protocole TCP.<br/><br/></td>
</tr>
<tr>
<td></td>
<td> S3_PING </td>
<td> S3_PING utilise le protocole S3 d'Amazon pour déterminer les membres du groupe. Il a été conçu spécialement pour les membres qui s'exécute sur Amazon EC2 qui ne supporte pas les échanges multicast.</td>
</tr>
<tr>
<td>Merge </td>
<td> MERGE2 </td>
<td>    Les protocoles MERGE et MERGE2 permettent, dans le cas d'une scission du groupe (par exemple dans le cas d'un partitionnement réseau), de fusionner les sous-groupes en un seul. Il est seulement exécuté par le coordinateur du groupe (ie. le membre le plus ancien du groupe) qui rappelle périodiquement sa présence par un message muticast. Si un autre coordinateur du même groupe reçoit le message émis par un autre coordinateur, cela signifie qu'il doit engager un processus de fusion.<br/><br/>A noter que si une fusion des sous-groupe {A, B} et {C, D, E} a lieu et donne {A, B, C, D, E}, l'état n'est pas fusionner mais laisse à l'application le soin de le faire.</td>
</tr>
<tr>
<td>Détection d'échec </td>
<td>   FD  </td>
<td> Le protocole FD (pour Failure Detection) s'appuie sur des messages de heartbeat. Si aucune réponse n'est reçu dans un délai imparti, le membre est déclaré comme suspect et sera exclu par le protocole GSM.<br/><br/>Si le protocole FD_SOCK est utilisé, alors aucun message de heartbeat n'est émis mais un socket TCP est créé et un membre est déclaré mort quand le socket est fermé.</td>
</tr>
<tr>
<td></td>
<td> FD_ALL </td>
<td>  FD_ALL permet la détection d'échec en s'appuyant sur un simple protocole de heartbeat : chaque membre diffuse (multicast) périodiquement un message de type heartbeat. Chaque membre devant maintenir la table de tous les membres, dès qu'un message n'est pas reçu d'un des membres dans un délai imparti, il est considéré comme suspect.</td>
</tr>
<tr>
<td></td>
<td> FD_PING </td>
<td> FD_PING utilise un script ou une commande qui reçoit comme paramètre l'hôte à pinger et qui doit renvoyer l'entier 0 en cas de succès et 1 sinon.<br/><br/>A noter que la commande par défaut est /sbin/ping (resp. ping.exe).</td>
</tr>
<tr>
<td></td>
<td> FD_ICMPL </td>
<td>    FD_ICMPL utilise en interne la méthode InetAddress.isReachable() afin de déterminer si l'hôte donné est présent ou pas.<br/><br/>A noter qu'il est préférable, avant d'utiliser ce protocole, de s'assurer au préalable du mode de fonctionnement de cette méthode pour le système d'exploitation cible.</td>
</tr>
<tr>
<td></td>
<td> FD_SOCK </td>
<td> Le protocole FD_SOCK s'appuie sur une topologie en anneau au niveau des sockets TCP créé entre les membres du groupe.<br/><br/>Ainsi, par exemple, le membre B est suspecté par son voisin A s'il observe une fermeture du socket TCP. Par contre, c'est au membre B de prévenir son voisin dans le cas d'un départ du groupe volontaire.<br/><br/>Cependant, dans le cas de l'interruption d'un serveur et/ou arrêt brutal d'un switch (et donc une non fermeture du socket TCP), ce protocole est inefficace. Aussi, il est conseillé de l'utiliser conjointement avec le protocole de FD (qui s'appuie sur un fonctionnement en heartbeat). </td>
</tr>
<tr>
<td></td>
<td> VERIFY_SUSPECT </td>
<td>  Le protocole VERIFY_SUSPECT vérifie l'état d'un membre suspect en lui envoyant un ping.<br/><br/>A noter qu'il doit être utilisé entre les couches FD et GMS sur la pile de protocole. </td>
</tr>
<tr>
<td>Messages fiables </td>
<td>  pbcast.NAKACK </td>
<td> Le protocole pbcast.NAKACK permet de s'assurer de la fiabilité de réception des messages en utilisant une file de message de type FIFO conjointement à des ack.<br/><br/>Ainsi, par exemple, si le noeud a reçu les messages P:1, P:3, P:4, alors il demandera une retransmission du message 2.</td>
</tr>
<tr>
<td></td>
<td> pbcast.STABLE </td>
<td>   Le protocole pbcast.STABLE permet de calculer les messages émis qui sont dans un état stable, c'est-à-dire qui ont été reçus par tous les membres. Cela permet au protocole NAKACK de supprimer les messages qui sont considérés comme ayant été reçu par tous les membres du groupe. </td>
</tr>
<tr>
<td></td>
<td> UNICAST </td>
<td> Le protocole UNICAST fournit un protocole unicast fiable d'émission en mode FIFO. </td>
</tr>
<tr>
<td>Fragmentation </td>
<td>     FRAG </td>
<td>  Le protocole FRAG permet de fragmenter les messages trop gros lors de l'émission et de les ré-assembler lors de la réception.<br/><br/>Ce protocole fonctionne aussi bien pour les messages émis en multicast ou en unicast.<br/><br/>Il sérialise chaque message afin de le morceler, et cela, quel que soit son type (même s'il s'agit d'octets) afin de pouvoir prendre en compte avec précision la taille de l'entête et les propriétés du message.</td>
</tr>
<tr>
<td></td>
<td> FRAG2 </td>
<td>   Le protocole FRAG2 permet, tout comme le protocole FRAG, de fragmenter les messages.<br/><br/>Cependant, il offre un autre algorithme lui permettant de ne pas avoir à sérialiser les messages pour les découper.<br/><br/>A noter que le protocole FRAG2 est préférable au protocole FRAG. </td>
</tr>
<tr>
<td>Gestion des membres du groupe </td>
<td>     pbcast.GMS  </td>
<td> Le protocole pbcast.GMS permet de gérer le départ ou l'enregistrement des membres dans le groupe. Il a également à sa charge de gérer les membres suspects et de les exclure du groupe. En fait, c'est lui qui émet les vues à tous les autres membres du groupe quand un changement se produit.</td>
</tr>
<tr>
<td></td>
<td> VIEW_SYNC </td>
<td>   Le protocole VIEW_SYNC permet aux membres du groupe de s'échanger périodiquement leurs vues et, si une incohérence entre vue est constatée, alors cela permet au protocole pbcast.GMS de mettre à jour la vue &ldquo;officielle&rdquo;. En fait, ce protocole est le pendant du coordinateur mais au niveau des noeuds et garanti, en cas d'anomalie sur le coordinateur pendant une dissémination des vues, une consistance des vues.</td>
</tr>
<tr>
<td>Contrôle de flux </td>
<td> FC </td>
<td>    Le protocole FC (Flow Control) permet de gérer le flux des messages. En effet, si l'émetteur émet plus vite que les destinataires ne peuvent consommer les messages, alors il y a risque de contension et c'est pourquoi les émetteurs ne doivent pas émettre les messages plus vite que leur capacité à être absorbés par le système.<br/><br/>Pour ce faire, un émetteur possède N crédits pour chaque membres. Quand il émet un message, il décrémente le nombre d'octets émis au crédit du récepteur. Quand le crédit d'un récepteur est inférieur que ce que requière le message à émettre, l"émetteur se bloque et attend que l'émetteur dispose de plus de crédits.<br/><br/>Le récepteur décrémente également le nombre d'octets reçu et émet son nombre de crédit à l'émetteur quand il est en dessous d'un certain seuil.</td>
</tr>
<tr>
<td></td>
<td> SFC </td>
<td> Le protocole SFC correspond à une version simplifiée du protocole FC qui peut entraîner une surconsommation chez le récepteur lorsqu'il existe de la latence dans la couche de transport.<br/><br/>En fait, ce protocole s'appuie sur un nombre d'octet maximal de crédits (configurable) qui est vérifié coté émetteur et récepteur. Il se marrie très bien avec le protocole pbcast.STABLE qui permet de &ldquo;nettoyer&rdquo; les messages déjà traités.</td>
</tr>
<tr>
<td>Transfert d'état </td>
<td> pbcast.STATE_TRANSFER    </td>
<td> Le protocole pbcast.STATE_TRANSFER permet à un nouveau membre de récupérer l'état du groupe du coordinateur.<br/><br/>Il fonctionne comme suit :<br/><ul><li>le nouveau membre demande au coordinateur l'état</li><li>Le coordinateur vérifie deux choses : un digest et l'état de l'application, le digest étant un vecteur contenant le plus haut et le plus bas numéro de séquence des messages reçu pour chaque membre</li><li>Les messages dans le digest font déjà parti de l'état du groupe et ne doivent pas être reçus</li><li>Le coordinateur émet l'état et le digest au membre arrivant</li><li>Le membre arrivant positionne son état et positionne son digest avec celui reçu permettant ainsi de savoir les messages qui n'ont pas encore été reçu</li></ul></td>
</tr>
<tr>
<td></td>
<td> pbcast.STREAMING_STATE_TRANSFER </td>
<td> Le protocole pbcast.STREAMING_STATE_TRANSFER permet de pallier aux problèmes de gros messages non traités par le protocole pbcast.STATE_TRANSFER.<br/><br/>Il permet de gérer des états de plus d'un gigaoctet.</td>
</tr>
<tr>
<td>Synchronisation virtuelle   </td>
<td> pbcast.FLUSH </td>
<td>    Le protocole FLUSH, comme son nom l'indique, force les membres du groupe à flusher leurs messages en cours plutôt que de les bloquer.<br/><br/>Il peut être utilisé dans les cas suivants :<br/><ul><li>Transfert d'état ; quand un membre demande l'état, le coordinateur indique à tous les membres d'arrêter d'émettre des message et attends leur réponse. Lorsque le nouveau membre a reçu toutes les informations requises, le coordinateur indique alors à tous les membres qu'ils peuvent reprendre leurs activités</li><li>Changement du vue (c'est-à-dire opération de join) : avant d'installer une nouvelle vue, l'opération de flush permet de s'assurer que tous les messages émis dans la vue précédente ont été traités</li></ul></td>
</tr>
<tr>
<td>Authentification et cryptage </td>
<td>  AUTH </td>
<td>  Le protocole AUTH est utilisé pour le couche d'authentification de JGroups en permettant de déterminer si un noeud est autorisé à rejoindre un groupe. AUTH s'appuie sur le protocole GMS et écoute les messages de type JOIN REQUEST : quand un message de type JOIN REQUEST est reçu, il cherche l'objet AuthHeader dans lequel doit se trouver une implémentation de la classe AuthToken.<br/><br/>AuthToken est une classe abstraite dont les implémentations doivent fournir le mécanisme d'authentification. JGroups fournit des implémentations basiques telles que :<br/><ul><li>SimpleToken,</li><li>MD5Token</li><li>et X50Token.</li></ul><br/><br/>Ces implémentations encrypte un chaîne de caractère se trouvant dans la configuration de JGroups et la passe au message JOIN REQUEST.<br/><br/>Quand l'authentification est réussie, le message est passé à la pile qui s'occupe du protocole GMS, sinon, un message de type JOIN RESPONSE contenant un message d'erreur est renvoyé au noeud. Le client lève alors une exception de type SecurityException.</td>
</tr>
<tr>
<td></td>
<td> ENCRYPT </td>
<td> Le protocole ENCRYPT permet de crypter les messages. Par défaut, il n'encrypte que le corps du message (ie. que tous les entêtes, les adresses des destinataires et de la source ne sont pas cryptés par défaut).</td>
</tr>
<tr>
<td>Synchronisation </td>
<td>   BARRIER </td>
<td>   Le protocole BARRIER peut être utilisé pour suspendre les messages à émettre. </td>
</tr>
</tbody>
</table>


<p><a name="conclusion"></a></p>

<h1>Conclusion</h1>

<p>Comme nous avons pu le voir, JGroups présente une API pour le développeur qui est très agréable à utiliser.
Cependant, la configuration des canaux peut s'avérer très ardue car elle est demande une bonne connaissance de la couche réseau mais aussi de ce qui est ciblé :</p>

<ul>
<li>Est-il acceptable de faire du multicast IP sur notre réseau? A défaut, l'utilisation de TCP est-elle suffisante?</li>
<li>Faut-il crypter les messages?</li>
<li>Faut-il que les messages émis sur le canal X soient ordonnancés?</li>
<li>Comment veut-on s'assurer que les messages soient bien transmis?</li>
<li>&hellip;</li>
</ul>


<p>Pour moi, c'est ce type de questions qu'il est important de se poser afin de configurer les différents canaux de JGroups. En outre, par défaut, JGroups peut s'avérer très bavard (notion de ping, signalisation en interne sur un merge, &hellip;) et, là encore, plutôt que de faire hurler votre administrateur réseau, essayer de voir avec lui ce qui est acceptable.</p>

<p>Ainsi JGroups s'adresse aux personnes qui veulent avoir la main sur les couches basses (contrairement à JMS qui a tendance à être plus abstrait sur les couches basses puisque cela dépend du provider choisi).</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li>Site officiel de JGroups : <a href="http://www.jgroups.org/">http://www.jgroups.org/</a></li>
<li>Wiki de JGroups : <a href="http://community.jboss.org/wiki/JGroups">http://community.jboss.org/wiki/JGroups</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
