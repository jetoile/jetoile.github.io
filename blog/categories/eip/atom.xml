<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: eip | Jetoile]]></title>
  <link href="https://blog.jetoile.fr/blog/categories/eip/atom.xml" rel="self"/>
  <link href="https://blog.jetoile.fr/"/>
  <updated>2018-10-28T17:58:30+01:00</updated>
  <id>https://blog.jetoile.fr/</id>
  <author>
    <name><![CDATA[Khanh Maudoux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lecture et traitement de fichiers : comment faire simple?]]></title>
    <link href="https://blog.jetoile.fr/2014/04/lecture-et-traitement-de-fichiers-comment-faire-simple.html"/>
    <updated>2014-04-10T14:15:44+02:00</updated>
    <id>https://blog.jetoile.fr/2014/04/lecture-et-traitement-de-fichiers-comment-faire-simple</id>
    <content type="html"><![CDATA[<p><img src="/images/batch/logo.png" alt="left-small" /></p>

<p>De nombreuses applications ou systèmes d'informations nécessitent le chargement de données issues de fichiers.</p>

<p>Bien souvent, cet import est exécuté par <em>batch</em>, mais il peut aussi être intéressant de faire cet import au fil de l'eau.</p>

<p>En outre, bien souvent, les fichiers à importer sont, soient nombreux, soient volumineux. Du coup, écrire un code simple et fiable peut devenir plus ardu que ce qu'il n'y parait. Si, de plus, on veut ajouter des logs parlant (c'est à dire avec, au minimum, le temps de traitement d'un fichier et son nom), cela a tendance a rajouter du bruit au code. Sans oublier que lire un fichier est bien mais que, souvent, un traitement est effectué dessus&hellip;</p>

<p>Enfin, lors d'une forte volumétrie, une scalabilité horizontale peut être intéressante surtout dans le contexte actuel où la quantité d'information vient à exploser.</p>

<p>Cet article parlera donc de la problématique d'import de fichiers dans une application en s'appuyant sur des framework comme <a href="http://projects.spring.io/spring-batch/">Spring Batch</a> ou <a href="http://projects.spring.io/spring-integration/">Spring Integration</a>. Le mot d'ordre sera de le faire le plus simplement possible en s'appuyant au maximum sur ces framework.</p>

<!-- more -->


<h1>Solution à base de <em>batch</em></h1>

<p>Ecrire un batch permettant de traiter des fichiers peut sembler simple mais lorsque le nombre de ces derniers vient à augmenter ou lorsque la taille des fichiers est volumineux, il arrive souvent que des bugs apparaissent. En outre, il convient alors de gérer manuellement les logs ainsi que la partie supervision.</p>

<p>Pour répondre à ce besoin, il est peut être avantageux d'utiliser <a href="http://projects.spring.io/spring-batch/">Spring Batch</a> (ou une autre implémentation de la <a href="https://jcp.org/en/jsr/detail?id=352">JSR 352</a>).</p>

<p><em>ndlr</em> : je ne présenterai pas le fonctionnement de Spring Batch à base de <strong>Job</strong> et <strong>Step</strong> puisque cela se trouve très facilement dans les documents officiels, livres ou articles de blog et je mettrai plutôt l'accent sur la faisabilité de tel ou tel chose.</p>

<p><img src="/images/batch/spring-batch-reference-model.png" title="crédit photo : http://docs.spring.io/spring-batch/trunk/reference/html-single/index.html" alt="center" /></p>

<p>Spring Batch offre nativement la possibilité de traiter les fichiers par <em>chunk</em> via :</p>

<ul>
<li><code>FlatFileItemReader</code> qui permet de lire un fichier plat ligne par ligne et où chaque ligne dispose de la même information (il est également possible de traiter des types de lignes différentes issues du même fichier avec <code>PatternMatchingCompositeLineMapper</code>).</li>
<li><code>StaxEventItemReader</code> pour lire fichiers xml composés de format de <em>fragments</em> identiques :
<img src="/images/batch/xmlinput.png" title="crédit photo : http://docs.spring.io/spring-batch/trunk/reference/html-single/index.html" alt="center" /></li>
</ul>


<p>avec :</p>

<p>```xml
<bean id="itemReader" class="org.springframework.batch.item.xml.StaxEventItemReader"></p>

<pre><code>&lt;property name="fragmentRootElementName" value="trade" /&gt;
&lt;property name="resource" value="data/iosample/input/input.xml" /&gt;
&lt;property name="unmarshaller" ref="tradeMarshaller" /&gt;
</code></pre>

<p></bean></p>

<p>&lt;bean id=&ldquo;tradeMarshaller&rdquo;</p>

<pre><code>  class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
&lt;property name="aliases"&gt;
    &lt;util:map id="aliases"&gt;
        &lt;entry key="trade"
               value="org.springframework.batch.sample.domain.Trade" /&gt;
        &lt;entry key="price" value="java.math.BigDecimal" /&gt;
        &lt;entry key="name" value="java.lang.String" /&gt;
    &lt;/util:map&gt;
&lt;/property&gt;
</code></pre>

<p></bean>
```</p>

<p>Généralement, il est nécessaire de préciser le nom du fichier à traiter mais il est également possible d'en traiter plusieurs de même type dans la même <em>Step</em> via la classe <code>MultiResourceItemReader</code>.</p>

<p>```xml
<bean id="multiResourceReader" class="org.springframework.batch.item.file.MultiResourceItemReader"></p>

<pre><code>&lt;property name="resources" value="classpath:data/input/file-*.txt" /&gt;
&lt;property name="delegate" ref="flatFileItemReader" /&gt;
</code></pre>

<p></bean>
```</p>

<p>Spring Batch supporte également la scalabilité horizontale en permettant de préciser un <code>taskExecutor</code> au niveau de la <em>Step</em>.</p>

<p>```xml
<step id="loading"></p>

<pre><code>&lt;tasklet task-executor="taskExecutor"&gt;...&lt;/tasklet&gt;
</code></pre>

<p></step>
```</p>

<p>Ainsi, on constate que Spring Batch offre nativement la possibilité de traiter des fichiers volumineux en les découpant par <em>chunk</em>.</p>

<p>De même, il offre nativement la possibilité de passer sur du traitement parallèle.</p>

<p>Concernant la partie supervision, vu que l'on est dans un environnement Spring, on bénéficie, bien sûr, de toute la partie JMX.</p>

<p>Pour la partie gestion des erreurs, Spring Batch permet de les gérer de manière très simple.</p>

<p>Cependant, on perd un grand intérêt si, par fichier, il n'y a qu'une seule donnée. En effet, le mécanisme de <em>chunk</em> devient alors inutile. Il reste cependant possible d'utiliser la scalabilité horizontale.</p>

<p>Concernant la partie log, j'avoue ne pas avoir creuser, je ne dirai donc rien sur ce point&hellip;</p>

<h1>Solution à base d'EIP</h1>

<p>Dans le cas où la volonté serait de traiter les fichiers au fil de l'eau, Spring Batch n'est pas la solution la plus adaptée&hellip;</p>

<p>Cependant, Spring Integration répond à ce besoin de manière très simple.</p>

<p>En effet, en utilisant un simple <strong>Service Activator</strong> (au sens EIP) de type <code>inbound-channel-adapter</code>, il devient alors possible de <em>poller</em> un répertoire et d'envoyer le contenu du fichier vers un <em>filter</em> (au sens EIP).</p>

<p>```xml
&lt;file:inbound-channel-adapter id=&ldquo;fileAdapter&rdquo; auto-startup=&ldquo;true&rdquo; auto-create-directory=&ldquo;true&rdquo;</p>

<pre><code>                          filename-pattern="*.xml"
                          directory="file:/tmp"
                          scanner="recursiveScanner"
                          prevent-duplicates="true"
                          channel="inputChannel"&gt;
&lt;int:poller fixed-delay="30000" max-messages-per-poll="500"/&gt;
</code></pre>

<p>&lt;/file:inbound-channel-adapter></p>

<p>&lt;file:file-to-string-transformer charset=&ldquo;UTF-8&rdquo; delete-files=&ldquo;true&rdquo; input-channel=&ldquo;inputChannel&rdquo;</p>

<pre><code>                                 output-channel="toLogger"/&gt;
</code></pre>

<p>&lt;int:logging-channel-adapter auto-startup=&ldquo;true&rdquo; channel=&ldquo;toLogger&rdquo; level=&ldquo;DEBUG&rdquo; log-full-message=&ldquo;true&rdquo;/></p>

<p>&lt;int:channel id=&ldquo;inputChannel&rdquo;/>
&lt;int:channel id=&ldquo;toLogger&rdquo;/>
```</p>

<p>D'un point de vue scalabilité horizontale, il suffit de renseigner (tout comme pour Spring Batch) un <code>taskExecutor</code> au niveau du <em>Channel</em> et&hellip; c'est tout!</p>

<p>```xml
&lt;task:executor id=&ldquo;someExecutor&rdquo;</p>

<pre><code>               pool-size="20"
               keep-alive="2400"/&gt;
</code></pre>

<p>&lt;int:channel id=&ldquo;toLogger&rdquo;></p>

<pre><code>&lt;int:dispatcher task-executor="someExecutor"/&gt;
</code></pre>

<p>&lt;/int:channel>
```</p>

<p>Enfin, disposer d'une supervision est des plus aisé puisqu'il suffit de rajouter l'élément <code>message-history</code> :</p>

<p><code>xml
&lt;int:message-history/&gt;
</code></p>

<p>L'ajout de cet élément indique à Spring Integration qui doit ajouter automatiquement dans le <em>header</em> du message le temps d'exécution de chaque <em>Filter</em>. Concernant le nom du fichier et son chemin, il se trouve renseigner automatiquement dans le header par l'<em>adapter</em> <code>file:inbound-channel-adapter</code>.</p>

<p>Coté gestion des erreurs, Spring Integration permet de les gérer très simplement sur le principe du canal d'erreur qui peut récupérer tous les messages en erreur.</p>

<p>Cependant, avec Spring Integration, si le fichier est volumineux, il n'est plus possible de le traiter en <em>chunk</em> et un risque de contention mémoire existe.</p>

<h1>Solution à base d'EIP et de batch</h1>

<p>On a vu dans les deux paragraphe précédent que Spring Integration était une très bonne solution pour traiter des fichiers au fil de l'eau alors que Spring Batch était plutôt orienté traitement par batch.</p>

<p>Cependant, il est très facile de composer les 2 modes. Cela permet, par exemple, de déclencher un traitement d'un fichier volumineux dès sa réception (via Spring Integration) et de bénéficier du mode <em>chunk</em> de Spring Batch pour le traitement.</p>

<p>Dans ce cas, bien sûr, il n'est pas question de faire de traitement sur le contenu du fichier dans la partie Spring Integration (seul l'objet <code>File</code> est transmis dans le corps du message) et c'est le jobs Spring Batch qui s'occupera du traitement à proprement parler.</p>

<p>Cela engendre peut être un <em>overhead</em> conséquent mais on est, au moins sûr, d'éviter le <em>Out Of Memory</em> dans le cas de fichiers volumineux. En outre, cela permet de bénéficier de la puissance des EIP (routage ou filtrage sur le nom du fichier par exemple) tant que le fichier n'a pas à être chargé.</p>

<p><img src="/images/batch/archi_combo.png" alt="large" /></p>

<h1>Conclusion</h1>

<p>On a vu dans cet article comment il pouvait être trivial de traiter l'import de fichiers sans avoir à gérer manuellement des pools de thread ou des logs d'audit.</p>

<p>Je ne suis pas rentré dans les détails mais mon objectif était surtout de montrer qu'en utilisant les bons outils/framework, il était possible de produire du code minimaliste et donc moins propice aux erreurs.</p>

<p>Pour avoir mis en oeuvre ces solutions, je peux vous assurer que le code écrit (ainsi que le temps passé) était minimaliste sinon nul (si on considère qu'écrire du xml n'est pas du code&hellip;). Bien sûr, je ne parle pas du code de traitement qui doit être écrit quoiqu'il arrive mais, encore une fois, le fait d'expédier la partie plomberie a permis de se concentrer sur le réel besoin métier.</p>

<p>Enfin, il est important de préciser que dans certains cas, une telle approche ne fonctionnera pas (si un fichier contient, par exemple, des dépendances à des données issues d'autres fichiers) et qu'il peut même être dangereux de vouloir absoluement utiliser ce type de framework au risque de leur faire faire des choses pour lesquelles ils ne sont pas prévus&hellip; Par exemple, il ne faut pas oublier que dans <strong>EIP</strong>, le <strong>I</strong> signifie Intégration!! Si le besoin est autre, il est fortement recommandé d'utiliser autre chose ou de le faire manuellement mais, par pitié, ne tordez pas le coup aux outils&hellip;! (si si, je l'ai vu&hellip; d'où mon désarroi&hellip;).</p>

<p><em>ndlr</em> : bon, j'admets que la partie qui a dû être la plus longue a sûrement été le <em>tuning</em> du pool de thread afin de tirer le meilleur partie de la machine mais, même si cela avait été fait de manière programmatique, cela aurait été nécessaire&hellip;</p>

<p><em>ndlr</em> : j'ai parlé, dans cet article, de Spring Integration pour la partie EIP mais il est tout aussi simple d'utiliser Apache Camel.</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li><strong>Spring Integration in Action</strong> de Mark Fisher, Jonas Partner, Marius Bogoevici et Iwein Fuld chez Manning</li>
<li><strong>Camel in Action</strong> de Claus Ibsen et Jonathan Anstey chez Manning</li>
<li><strong>Spring Batch in Action</strong> de Arnaud Cogoluegnes, Thierry Templier, Gary Gregory et Olivier Bazoud chez Manning</li>
<li><strong>Enterprise Integration Patterns</strong> de G. Hohpe et B. Woolf chez Addisson Wesley</li>
<li><a href="http://www.eaipatterns.com/">http://www.eaipatterns.com/</a></li>
<li><a href="http://projects.spring.io/spring-integration/">http://projects.spring.io/spring-integration/</a></li>
<li><a href="http://projects.spring.io/spring-batch">http://projects.spring.io/spring-batch</a></li>
<li><a href="http://www.technologies-ebusiness.com/langages/spring-batch-spring-integration-une-usine-de-batchs-a-moindre-cout">http://www.technologies-ebusiness.com/langages/spring-batch-spring-integration-une-usine-de-batchs-a-moindre-cout</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Devoxx 2012 : Versionner son service dans une architecture SOA et/ou Cloud]]></title>
    <link href="https://blog.jetoile.fr/2012/11/devoxx-2012-versionner-son-service-dans.html"/>
    <updated>2012-11-21T15:12:51+01:00</updated>
    <id>https://blog.jetoile.fr/2012/11/devoxx-2012-versionner-son-service-dans</id>
    <content type="html"><![CDATA[<p><img src="http://1.bp.blogspot.com/-TdkQLPVtGoU/UKkTTw9Zn7I/AAAAAAAAAwM/kdDLDr0zwDw/s1600/devoxxLogo.png" alt="left-small" /></p>

<p>Ça y est&hellip; <a href="http://devoxx.com/">Devoxx</a> est fini&hellip; :&lsquo;(
Comme je l'ai dit dans un article précédent, je ne ferai pas de compte-rendu exhaustif de présentations auxquelles j'ai pu assisté à Devoxx.</p>

<p>Cependant, je tenais à revenir sur la présentation &ldquo;<em>Service Versioning in SOA and Cloud</em>&rdquo; par <strong>Ignaz Wanders</strong> (<a href="https://twitter.com/ignazw">@ignazw</a>) dont le synopsis était :</p>

<blockquote><p>Keeping versioning under control is essential in the success of a SOA. However, there are no industry standards for service versioning, thus leaving the responsibility of implementing a service versioning system up to the architects and developers within the IT enterprise.</p></blockquote>

<br/>


<blockquote><p>We often see design-type versioning, resulting in Big Bang governance strategies. A runtime versioning strategy may be, in fact, be preferable.</p></blockquote>

<br/>


<blockquote><p>Every change must be built, and every change must be governed. A &ldquo;cheap&rdquo; build may lead to a large governance impact. But conversely, a small governance cost may lead to a large build impact. Both build and governance costs need to be taken into account and carefully balanced when choosing and implementing a service versioning strategy.</p></blockquote>

<p>Dans cet article, je me contenterai de montrer quelques-uns des slides de la présentation de Ignaz Wanders qui définissent et synthétisent très bien les différentes stratégies possibles en partant de comment numéroter ses services pour arriver à une proposition qu'il aimerait avoir du coté du consortium OASIS avec un WS-Versioning. Les slides étant suffisant en eux-mêmes et n'ayant pas envie de répéter/déformer leur contenu, je ne mettrai donc que les photos prises pendant la conférence&hellip;</p>

<!-- more -->


<p><img src="http://3.bp.blogspot.com/-jQmsfBODkbk/UKwAQe5_3hI/AAAAAAAAAyI/U2o6JrWPC0A/s1600/_IMG_20121114_183004.jpg" alt="small" /></p>

<p>D'ailleurs, une version pdf dont le contenu est similaire (identique?) est accessible <a href="http://www.servicetechsymposium.com/dl/presentations/the_service_versioning_balancing_act.pdf">ici</a>.</p>

<p>Enjoy! ;&ndash;)</p>

<p><img src="http://4.bp.blogspot.com/-V3A7YsME1qc/UKv_rdwByZI/AAAAAAAAAww/dAFqcrxg9No/s1600/_IMG_20121114_180323.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-xbCED_gA8FI/UKv_u5wLLtI/AAAAAAAAAw4/ftroF40s15k/s1600/_IMG_20121114_180329.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-XgRKL4EkTAM/UKv_x_SQ17I/AAAAAAAAAxA/xFxPFfhuMvY/s1600/_IMG_20121114_180536.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-HVdfl4dxTkM/UKv_1JlCcsI/AAAAAAAAAxI/yc4CU7WU_64/s1600/_IMG_20121114_180815.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-EHMmEnybKBo/UKv_4XJenuI/AAAAAAAAAxQ/dIsguCfMjhw/s1600/_IMG_20121114_181020.jpg" alt="medium" /></p>

<p><img src="http://3.bp.blogspot.com/-Y4wEcftNOD8/UKv_8kw0TqI/AAAAAAAAAxY/w92mR9tPBoU/s1600/_IMG_20121114_181306.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-39pTw8YZvf0/UKv__6d0rNI/AAAAAAAAAxg/XFBaryDXQ5U/s1600/_IMG_20121114_181445.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-deIWO4ytlUU/UKwADCvsYGI/AAAAAAAAAxo/tWO4VBEzI6g/s1600/_IMG_20121114_182310.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-q8PAIg75_mU/UKwAFVcDg4I/AAAAAAAAAxw/ylFPvFhCyJM/s1600/_IMG_20121114_182732.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-6SCvJCOB0_A/UKwAI8wOZ1I/AAAAAAAAAx4/ffn8uhngv9A/s1600/_IMG_20121114_182754.jpg" alt="medium" /></p>

<p><img src="http://2.bp.blogspot.com/-LwnYPf2AUek/UKwAMZaiUKI/AAAAAAAAAyA/8VI-LkSn0Mg/s1600/_IMG_20121114_182903.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-nHjSNerL9nc/UKwAS7CkIhI/AAAAAAAAAyQ/8tXgU50Ohv0/s1600/_IMG_20121114_183054.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-aKBOUmyQc3g/UKwBv2ke-BI/AAAAAAAAAy4/-mtm_ERfCUk/s1600/_IMG_20121114_183135.jpg" alt="medium" /></p>

<p><img src="http://4.bp.blogspot.com/-7tcZYwkXHCY/UKwAZ-ouTlI/AAAAAAAAAyg/PqGdkqlXY_k/s1600/_IMG_20121114_183326.jpg" alt="medium" /></p>

<p><img src="http://1.bp.blogspot.com/-afWGOsx4Es4/UKwAcX7W76I/AAAAAAAAAyo/4g4lXp3N5JA/s1600/_IMG_20121114_183509.jpg" alt="medium" /></p>

<p><img src="http://3.bp.blogspot.com/-4i4O9yO_nSg/UKwAeejTZqI/AAAAAAAAAyw/9oa_EsrStMI/s1600/_IMG_20121114_183710.jpg" alt="medium" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Orchestration ou Routage?]]></title>
    <link href="https://blog.jetoile.fr/2010/04/orchestration-ou-routage.html"/>
    <updated>2010-04-07T11:55:20+02:00</updated>
    <id>https://blog.jetoile.fr/2010/04/orchestration-ou-routage</id>
    <content type="html"><![CDATA[<p><img src="http://petals.ow2.org/img/petals_logo.png" alt="left-small" /></p>

<p>Orchestration ou routage? Telle est la question qui se pose souvent&hellip; En effet, il est important de se poser la question sur la solution à adopter pour gérer, par exemple, des transformations ou du routage de messages dans un système asynchrone : s'agit-il de médiation technique ou de quelque chose de plus complexe (ie. de logique métier)?</p>

<p><a href="http://petals.ow2.org/">PEtALS Link</a> vient de mettre à disposition un <a href="http://www.petalslink.com/sites/default/files/rsc/docs/whitepapers/White_paper_Orchestration_0.2_122009.pdf">livre blanc</a> traitant du sujet en proposant différentes pistes pour choisir la solution d'implémentation.</p>

<p>D'ailleurs, j'en profite également pour mettre le <a href="http://parleys.com/#id=1892&amp;st=5&amp;sl=40">lien</a> vers la présentation de PEtALS ESB qui a eu lieu au <a href="http://www.poitoucharentesjug.org/">JUG de Poitou Charentes</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Integration vs. Apache Camel]]></title>
    <link href="https://blog.jetoile.fr/2010/03/spring-integration-vs-apache-camel.html"/>
    <updated>2010-03-15T23:29:48+01:00</updated>
    <id>https://blog.jetoile.fr/2010/03/spring-integration-vs-apache-camel</id>
    <content type="html"><![CDATA[<p><img src="http://4.bp.blogspot.com/_XLL8sJPQ97g/S56PashF4SI/AAAAAAAAAJA/OVagPG4D-g0/s320/apache_spring.png" alt="left-small" />
Lors d'un <a href="/2009/12/eip-quest-ce-que-cest.html">post précédent</a>, j'avais parlé des <a href="/blog/2009/12/13/eip-quest-ce-que-cest/">EIPs</a> (<strong>Enterprise Integration Patterns</strong>) en expliquant qu'il s'agissait de Patterns permettant de normaliser les échanges de messages dans un système asynchrone.</p>

<p>Dans cet article, je vais tenter de présenter succinctement deux de ses implémentations : <a href="http://projects.spring.io/spring-integration/">Spring Integration</a> et [Apache Camel](<a href="https://camel.apache.org/.">https://camel.apache.org/.</a></p>

<p>En fait, pour être plus précis, je vais plutôt tenter de présenter la vision que j'en ai ainsi que la façon dont je les ai compris.</p>

<p>Ainsi, ce post n'a pas pour objectif de les détailler de manière exhaustive car ils sont trop complets pour cela et qu'un seul post ne pourrait suffire à les aborder tous les deux (leurs documentations font d'ailleurs, pour Spring Integration, plus de 130 pages, et pour Apache Camel, plus de 580 pages&hellip; cqfd&hellip; ;&ndash;) ) mais juste, comme je l'ai dit précédemment dit, d'aider à comprendre leurs différences (quelles soient conceptuelles ou structurelles).</p>

<p>Je ne reviendrai pas sur les concepts des EIPs ni de JBI que j'utiliserai dans la suite et pour cela, je vous renvoie sur internet ou sur mes posts précédents (<a href="/2009/12/eip-quest-ce-que-cest.html">ici</a> et <a href="/2009/12/jbi-une-solution-enterree.html">là</a>).</p>

<p>Concernant les versions utilisées, cela n'a pas vraiment son importance ici car je m'intéresserai surtout aux principes de ces deux frameworks mais à titre indicatif, il s'agit des versions 2.0 pour Apache Camel et 1.3.0 pour Spring Integration (il me semble qu'il n'y a pas de modifications flagrantes dans les versions courantes qui sont 2.2.0 pour Camel et 2.0.0.M2 pour Spring Integration).</p>

<!-- more -->


<h1>Les concepts</h1>

<h2>Apache Camel</h2>

<p>Apache Camel est un framework open-source qui est une implémentation des EIPs et qui propose pour sa configuration d'utiliser indifféremment :</p>

<ul>
<li>un fichier de configuration Spring (Spring DSL),</li>
<li>un DSL interne (Java DSL),</li>
<li>ou un DSL externe (Scala DSL).</li>
</ul>


<p>Cependant, il définit ses propres concepts qui diffèrent de ceux des EIPs mais qui restent assez similaires.</p>

<p>Ainsi, Apache Camel s'appuie sur la notion de routes (<strong>Route</strong>) qui relient deux points d'accès (<strong>Endpoint</strong>). Sur cette route transite des messages (<strong>Message</strong>) au travers d'échanges (<strong>Exchange</strong>). En fait un Exchange est le conteneur du message durant la phase de routage.</p>

<p>Ces points d'accès peuvent être de différents types et peuvent supporter différentes technologies telles que :</p>

<ul>
<li>une destination (Topic ou Queue) JMS,</li>
<li>un service web,</li>
<li>un fichier se trouvant sur le système de fichier,</li>
<li>un serveur FTP,</li>
<li>une adresse mail,</li>
<li>ou encore un POJO (<em>Plain Old Java Object</em>).</li>
</ul>


<p>Si l'on fait un parallèle avec JBI (<em>Java Business Integration</em>) (cf. <a href="/2009/12/jbi-une-solution-enterree.html">ici</a>), un <strong>Endpoint</strong> peut être vu comme une instance d'un <strong>Binding Component</strong>.</p>

<p>Une <strong>Route</strong> peut, quant à elle, être vue comme le chemin qu'emprunte le message d'un bout à l'autre de la chaîne de médiation. Ce chemin pouvant être entrecoupé par ce qu'on appelle des processeurs (<strong>Processor</strong>).</p>

<p>Apache Camel introduit également la notion de Composants (<strong>Component</strong>) à partir desquels les <strong>Endpoint</strong> sont issus (toujours pour faire un parallèle avec JBI, un <strong>Component</strong> peut être vu comme un <strong>Composant JBI</strong> en mode fournisseur ou consommateur).</p>

<p>Enfin, par composition à un <strong>Endpoint</strong>, Apache Camel utilise également les notions de <strong>Producer</strong> et <strong>Consumer</strong> qui permettent d'émettre (respectivement, recevoir) un message vers (resp. d') une application extérieure et qui peuvent être vu comme des <strong>Binding Component</strong> en mode fournisseur (resp. consommateur).</p>

<h1>Spring Integration</h1>

<p>Spring Integration appartient au portfolio de Spring Framework et étend le modèle de programmation de Spring mais dans le domaine de la messagerie. Il supporte l'architecture basée sur les messages (<em>Message-Driven Architecture</em>) où l'inversion de contrôle est utilisée pour les problématiques d'exécution comme, par exemple, quand doivent être appelés les composants métiers ou encore où doivent être envoyées les réponses. En outre, il offre des mécanismes de routage et de transformation de messages afin de permettre aisément l'utilisation de protocoles de transport et des types de messages hétérogènes. Il propose pour sa configuration d'utiliser soit un fichier de configuration Spring soit le mécanisme d'annotations.</p>

<p>Concernant ses concepts, ils collent parfaitement à ceux des EIPs puisque Spring Integration utilise la notion de :</p>

<ul>
<li><strong>Message</strong> dont la définition est identique à celle des EIPs,</li>
<li><strong>Message Channel</strong> dont la définition est identique à celle des EIPs,</li>
<li>et de <strong>Message Endpoint</strong> qui regroupe :

<ul>
<li>les Message Routing dont la définition est identique à celle de Routing des EIPs</li>
<li>les Message Transformation dont la définition est identique à celle de Transformation des EIPs</li>
<li>et les Message Endpoint dont la définition est identique à celle des EIPs</li>
</ul>
</li>
</ul>


<h1>Mon avis avant utilisation</h1>

<h2>Apache Camel</h2>

<p>Apache Camel est un framework issu de l'implémentation JBI Apache ServiceMix et qui est également utilisé dans OpenESB. Cela peut expliquer pourquoi ses concepts sont si proches de ceux de JBI (ou du moins que les modèles sont si facilement transposables). Cependant, à mon sens, même si ses concepts sont proches de ceux de JBI, les termes utilisés sont différents et, pour ceux qui connaissent JBI, un effort d'apprentissage supplémentaire doit être fait. En outre, la documentation d'Apache Camel est loin d'être aisée à lire et retrouver de l'information dans le wiki qui lui sert de documentation s'achèvent généralement avec des cheveux en moins, une souris torturée ou un écran ébréché&hellip; le tout accompagné par une flopée d'injures&hellip;</p>

<p>Ainsi, à mon avis, pour un produit qui se veut être une implémentation des EIPs, il faut :</p>

<ul>
<li>d'une part, lire ou se familiariser avec les EIPs</li>
<li>et d'autre part, connaitre JBI ou, au moins, se familiarisé avec les concepts d'Apache Camel (comprendre la différence entre un composant, un endpoint qui est lui-même un processeur, les éléments pipeline et multicast qui sont eux-même des processeurs, etc, etc, etc&hellip;). Rien d'insurmontable mais il est quand même nécessaire de se faire quelques nœuds au cerveau&hellip;</li>
</ul>


<p>Par contre, par rapports aux EIPs, Apache Camel masque la notion de Channel, ce qui peut s'avérer plaisant.</p>

<h2>Spring Integration</h2>

<p>Spring Integration est un projet du portfolio Spring donc très propre, avec une documentation très bien faite et pas trop longue&hellip; En outre, pour quelqu'un qui est déjà familiarisé avec les EIPs, la prise en main de Spring Integration est immédiate. Le fait qu'il s'appuie sur Spring (tout comme Apache Camel d'ailleurs) permet une courbe d'apprentissage rapide.</p>

<h1>Mon avis après utilisation</h1>

<h2>Apache Camel</h2>

<p>Apache Camel s'avère ardu à prendre en main malgré un forum actif. Cela en raison de sa documentation un peu (complètement?) fouillis mais également parce qu'il est possible de faire la même chose de multiples manières, ces manières ayant chacunes ses limitations. Si on utilise le framework simplement avec une description XML et des POJOs (qui sont, parfois, fortement couplé au framework Apache Camel au travers de son API (Exchange, Endpoint, &hellip;) &hellip; pas très propre tous ça&hellip; :( ), on peut arriver sans trop de douleur à faire ce que l'on veut. Par contre, si on se lance dans les DSLs internes ou externes (et même si j'aime bien le principe des DSLs&hellip;), cela n'exclue pas l'adhérence des POJOs à l'API d'Apache Camel et il est souvent nécessaire de faire intervenir la notion d'Exchange dans les signatures des méthodes.</p>

<p>En outre, on se rend rapidement compte que la majorité des classes de l'API héritent de l'interface <code>Processor</code>. Pourquoi cela me pose problème? et bien parce que j'estime qu'il est bizarre et peu naturel que certaines classes comme Pipeline ou MulticastProcessor implémente (directement ou indirectement) Processor ou alors il aurait, au moins, été préférable de mettre ce type de classes dans un autre package que celui où se trouvent des classes comme Aggregator, FileProcessor, Resequencer ou encore RecipientList. Bon, je comprends qu'Apache Camel a été pensé dès le départ pour offrir une configuration simple à base de DSL et que, du coup, il a été nécessaire de faire certaines concessions mais lorsque l'on rentre dans le code du framework, ce n'est pas (et cela ne concerne que moi) une impression de propreté qui en ressort&hellip;</p>

<p>Un autre point qui m'interpelle est le fait que lors de l'écriture des règles de médiations, il n'y a pas de différences sémantiques entre les différentes notions qu'offrent les EIPs : les Message Transformation, Message Routing ou Service Activator se représentent tous comme des Processor ou des Bean. Je trouve cela dommage de perdre la classification (qu'on aime ou pas) fournit par les EIPs et qui, à mon sens, permettait justement de clarifier toutes les notions utiles pour gérer les échanges de messages dans un système asynchrone.</p>

<p>Par contre, comme je l'ai dit précédemment, il est vraiment appréciable de ne pas à avoir à déclarer ses propres Channels qui sont masqués par la notion de Route.</p>

<h2>Spring Integration</h2>

<p>Spring Integration est extrèmement simple à prendre en main et son forum est très actif. La documentation est claire et c'est vrai qu'il est appréciable de pouvoir utiliser les notions des EIPs directement.</p>

<p>Les annotations sont parlantes et les éléments (service-activator, splitter, filter, resequencer, aggregator, transformer, router, &hellip;) à utiliser dans le fichier de configuration Spring permettent de classifier rapidement les différents éléments se trouvant dans la chaine de médiations.</p>

<p>En outre, le code interne du framework est propre et permet de masquer la complexité des différents Message Endpoint.</p>

<h1>Conclusion</h1>

<p>Vous l'aurez compris, j'ai une petite préférence pour Spring Integration&hellip;</p>

<p>Cependant, je dirai que le choix dépend aussi grandement de l'utilisation qu'on veut en faire (bon ok, je ne me mouille pas trop&hellip; ;&ndash;) ) :</p>

<ul>
<li>dans un ESB type ServiceMix ou OpenESB, il peut être préférable d'utiliser Apache Camel en raison de sa capacité à être configurée via un DSL qui peut être plus aisé que de manipuler des Channels et des fichiers XML,</li>
<li>par contre, pour les autres cas, je conseillerai plutôt Spring
Integration pour son modèle de programmation et ses concepts plus
simple&hellip;</li>
</ul>


<p>mais là, je conseillerai à chacun de se faire sa propre idée&hellip;</p>

<p>Un petit mot en plus sur les points non abordés ci-dessus :</p>

<ul>
<li>les mécaniques offertes pour manipuler des messages au format XML (XPath, &hellip;),</li>
<li>la gestion des erreurs,</li>
<li>le nombre de connecteurs fournis par ces derniers.</li>
</ul>


<p>Sur ces deux derniers points, l'avantage va indéniablement à Apache Camel même s'il est aisé (modulo la connaissance du protocole utilisé) d'en redéfinir avec Spring Integration en utilisant un Service Activator mais, dans ce cas, il faut le faire à la main.</p>

<p>Pour le premier point, je ne dirai rien car je n'ai pas eu l'occasion de l'utiliser&hellip;</p>

<p>Enfin, il ne faut pas oublier que ces frameworks ont pour but principal d'offrir un moyen de faire de la médiation technique et non de gérer une orchestration de processus métier et que pour cette raison, ils doivent être utilisés à bon escient.</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li><strong>SOA : le guide de l’architecte</strong> de X. Fourner-Morel, P. Grojean, G. Plouin et C. Rognon chez Dunod</li>
<li><strong>Enterprise Integration Patterns</strong> de G. Hohpe et B. Woolf chez Addisson Wesley</li>
<li>Site de Spring Integration : <a href="http://www.springsource.org/spring-integration">http://www.springsource.org/spring-integration</a></li>
<li>API de Spring Integration : <a href="http://static.springframework.org/spring-integration/apidocs/">http://static.springframework.org/spring-integration/apidocs/</a></li>
<li>Manuel de référence de Spring Integration : <a href="http://docs.spring.io/spring-integration/docs/4.0.0.M3/reference/html/">http://docs.spring.io/spring-integration/docs/4.0.0.M3/reference/html/</a></li>
<li>Site d'Apache Camel : <a href="http://camel.apache.org/">http://camel.apache.org/</a></li>
<li>API d'Apache Camel : <a href="http://camel.apache.org/javadoc.html">http://camel.apache.org/javadoc.html</a></li>
<li>Manuel de référence d'Apache Camel : <a href="http://camel.apache.org/manual.html">http://camel.apache.org/manual.html</a></li>
<li>Spécification de JBI : <a href="http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html">http://jcp.org/aboutJava/communityprocess/edr/jsr208/index.html</a></li>
<li>Blog de Xebia sur les ESB légers : <a href="http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/">http://blog.xebia.fr/2007/12/17/spring-integration-lavenement-des-lightweight-esb/</a></li>
<li>Blog de Xebia sur une revue de presse d'un article sur Spring Integration et Apache Camel : <a href="http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel">http://blog.xebia.fr/2010/01/04/revue-de-presse-xebia-141/#SpringIntegrationetApacheCamel</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EIP : Qu'est ce que c'est]]></title>
    <link href="https://blog.jetoile.fr/2009/12/eip-quest-ce-que-cest.html"/>
    <updated>2009-12-13T12:15:29+01:00</updated>
    <id>https://blog.jetoile.fr/2009/12/eip-quest-ce-que-cest</id>
    <content type="html"><![CDATA[<p><img src="http://rcm-images.amazon.com/images/I/51tVn4YqQUL._SL110_.jpg" alt="left" />
Dans l'article sur <a href="/2009/12/jbi-une-solution-enterree.html">JBI</a>, j'ai mentionné à de nombreuses reprises le terme EIP. Cet article revient sur cette notion que je considère comme étant très importante surtout lorsque l'on doit jongler avec des messages asynchrones.</p>

<p>En fait, les EIP (<em>Enterprise Integration Patterns</em>) sont issus de l'excellent livre éponyme de G. Hohpe et B. Woolf chez Addisson Wesley. Ne pouvant que vous recommandez sa lecture si vous trempez dans cette problématique, cet article ne sera qu'une brève introduction à son contenu (il fait quand même plus de 600 pages, donc je ne vais pas prétendre le résumer&hellip; ;&ndash;)). Cet article se voudra très théorique et d'autres articles ultérieurs couvriront quelques implémentations d'EIP comme Apache Camel ou Spring Integration (et peut être, un jour, iBeans). En outre, il suivra le plan du livre dont il est tiré.</p>

<!-- more -->


<p></p>

<h1>EIP? Pour quoi faire?</h1>

<p>La notion de couplage faible, que ce soit au niveau applicatif ou entre applications, a toujours été primordiale pour, entre autre, permettre une meilleure évolutivité (et tous ce qui va avec) qui est une des bêtes noires pour tout DSI et même pour tous développeurs.</p>

<p>Pour cela, plusieurs solutions existent :</p>

<ul>
<li>utilisation d'un répertoire tampon sur le système de fichiers,</li>
<li>base de données partagées,</li>
<li>RPC (<em>Remote Procedure Call</em>),</li>
<li>envoie de messages via un MOM (<em>Middleware Oriented Message</em>),</li>
<li>&hellip;</li>
</ul>


<p>En fait, les EIP sont des patterns qui permettent de normaliser les échanges de messages dans un système asynchrone. Comme beaucoup de patterns, ces notions sont généralement connues et les EIP ne font que récapituler, normaliser et nommer de nombreux concepts comme ce que doit contenir les messages qui transitent ou ce qu'il faut faire pour router un message. En outre, il formalise graphiquement la représentation de ses concepts, ce qui permet avec un schéma de se faire comprendre par tous.</p>

<p>Ses applications sont multiples : cela peut aussi bien être dans un middleware que dans un contrôleur (au sens MVC du terme), et ils sont d'ailleurs souvent présent dans les EAI (généralement au travers d'un outil graphique). Aussi, les EIP trouvent parfaitement leurs places dans une infrastructure SOA comme un ESB que ce soit de manière transparente ou apparente.</p>

<h1>Concepts des EIP</h1>

<p>Les EIP s'appuient sur une architecture <strong>Pipes and Filters</strong> : un <strong>Pipe</strong> étant&hellip; un pipe et un <strong>Filter</strong> pouvant être vu comme un composant qui fait quelque chose (dans certaines implémentations, ce Filter est aussi appelé <strong>Processor</strong>).</p>

<p>En outre, les EIP décrivent :</p>

<ul>
<li>ce qui transite dans le Pipe entre les Filter : il s'agit des <strong>Messages</strong> (logique non?) et quel peut et doit être son contenu en fonction de son cas d'utilisation</li>
<li>sur le type de <strong>Pipe</strong> sur lequel les messages peuvent transiter : il s'agit des <strong>Channel</strong> (canaux)</li>
<li>et introduisent les notions de <strong>Routing</strong>, <strong>Transformation</strong> et de <strong>Message Endpoint</strong> qui permettent de classifier les Filters.</li>
</ul>


<h2>Notion de Channel</h2>

<p>Un Channel correspond au Pipe dans l'architecture Pipes and Filters et est le canal où transitent tous les messages.</p>

<p>Les EIP décrivent les différents types de canaux qu'il est possible d'avoir (liste non exhaustive) :</p>

<ul>
<li>Le <strong>Point-to-Point Channel</strong> qui est un canal où un message n'est consommé que par un et un seul consommateur (ou Filter). Le message, une fois consommé, n'est plus présent sur ce dernier. Ce canal est souvent utilisé pour faire du requête/réponse ou du load-balancing.
<img border="0" height="14" alt="center" src="http://2.bp.blogspot.com/_XLL8sJPQ97g/SyaAHSfE-1I/AAAAAAAAAFY/qwgCB-y4yjg/s200/Image1.png" width="98" /></a><br /></li>
<li>Le <strong>Publish-Subscribe Channel</strong> qui est un canal où un message est consommé par tous les consommateurs qui se sont inscrits comme étant intéressés par les messages du canal. Il est à noter qu'une fois que le message a été consommé par tous les Filter, il n'est plus accessible (même fonctionnement que le Design Pattern Observer du GoF). Ce canal est souvent utilisé pour faire de la notification.
<img border="0" height="60" alt="center" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SyaAbkFIlSI/AAAAAAAAAFg/aL3HbhSdObo/s200/Image2.png" width="98" /></a><br /></li>
<li>Le <strong>Datatype Channel</strong> qui est un canal où tous les messages qui y transitent sont de même type.
<img border="0" height="46" alt="center" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SyaApPYOGaI/AAAAAAAAAFo/xaLAftWvRkc/s200/Image3.png" width="138" /></li>
<li>Le <strong>Message Invalid Channel</strong> est un canal qui permet de véhiculer les messages non valides (au sens applicatif du terme : manque d'information, mauvais format, &hellip;) et qui ont besoin d'un traitement particulier. Ces messages sont considérés comme invalide par les Filter qui, plutôt que de les ignorer ou de les réémettre sur un canal &ldquo;normal&rdquo; ont alors la possibilité d'utiliser ce canal particulier pour, par exemple, pour le logger ou faire un traitement sur erreur.
<img border="0" height="41" src="http://1.bp.blogspot.com/_XLL8sJPQ97g/SyaA1C5gx3I/AAAAAAAAAFw/o_rvD0NbEeo/s200/Image4.png" width="92" alt="center"/></li>
<li>Le <strong>Dead Letter Channel</strong> est un canal qui permet de rerouter des messages non valides, au sens technique du terme (canal d'émission mal configuré, canal supprimé avant réception du message, message expiré, &hellip;). Ces le système de messagerie qui doit prendre en compte ce type de problème et qui doit gérer, s'il existe, ce Dead Letter Channel.
<img border="0" height="44" src="http://4.bp.blogspot.com/_XLL8sJPQ97g/SyaBOr-9_2I/AAAAAAAAAF4/mvecgUh_4NY/s200/Image5.png" width="97" alt="center"/></li>
<li>Le <strong>Garanteed Delivery Channel</strong> qui est un canal qui conserve les messages dans un espace de stockage persistant (base de données, système de fichiers, &hellip;) tant qu'il n'a pas été transmis ou tant qu'il n'a pas été stocké dans un autre espace de stockage. Ce canal permet de s'assurer de la non perte de données dans le système en cas d'anomalie de ce dernier (arrêt, &hellip;).
<img border="0" height="52" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SyaBcLHKdCI/AAAAAAAAAGA/cozenqpx-sY/s200/Image6.png" width="117" alt="center"/></li>
</ul>


<p>En outre, les EIP décrivent également dans cette section des notions transverses aux canaux qui permettent leur interaction (liste non exhaustive) :</p>

<ul>
<li>Le <strong>Channel Adapter</strong> qui permet à une ou des applications quelconques de recevoir ou d'émettre des messages de ou vers le système de messagerie.</li>
<li>Le <strong>Messaging Bridge</strong> qui permet d'interfacer plusieurs systèmes de messagerie.</li>
</ul>


<p>On peut constater que, généralement, ces différents points ne sont pas nouveaux et qu'ils sont présent dans de nombreux produits, technologies et spécification sous des noms différents (JMS pour les Point-to-Point &ndash; <em>Queue</em> &ndash; ou les Publish-Subscribe &ndash; <em>Topic</em> &ndash;, PABX dans le monde des télécoms pour le Messaging Bridge, &hellip;).</p>

<h2>Notion de Message</h2>

<p>Les EIP décrivent les messages qui peuvent transiter dans les canaux au niveau structurel et fonctionnel.</p>

<p>Aussi, au niveau structurel, ils définissent un message comme pouvant être constitué de :</p>

<ul>
<li>un entête</li>
<li>des propriétés</li>
<li>un corps (body)</li>
<li>une pièce jointe</li>
</ul>


<p><img border="0" height="148" src="http://4.bp.blogspot.com/_XLL8sJPQ97g/SyaBnNvb74I/AAAAAAAAAGI/Eq8XUk2Rz3Q/s200/Image7.png" width="126" alt="center"/></p>

<p>Ils décrivent également ce que peut ou devrait contenir l'entête ou les propriétés du message en fonction de son cas d'utilisation :</p>

<ul>
<li><strong>Return Address</strong> qui permet lorsque le message est utilisé comme requête dans le mécanisme de requête/réponse de connaître à qui (c'est à dire le canal) la réponse doit être renvoyé (ndlr : s'il connait le canal alors le ou les destinataires sont connus au travers des Filter consommateurs ou en écoute du canal). Cette information est généralement mise dans l'entête du message.</li>
<li><strong>Correlation Identifier</strong> qui permet d'associer un identifiant au message afin de, par exemple, l'associer la réponse à sa requête lors d'un échange asynchrone.</li>
<li><strong>Message Sequence</strong> qui permet de reséquencer des messages pouvant être issus d'un même message découpé en raison de sa taille ou en raison de la nécessité d'en émettre des parties à des Filter différents puis de les réagréger. Ce type d'information est généralement mise dans l'entête du message et doit dans la plupart des cas disposer de 3 choses : l'identifiant de la séquence, l'identifiant de position et le nombre de fraction ou un identifiant de fin (flag).</li>
<li><strong>Message Expiration</strong> qui permet de spécifier une durée de validité (en temps absolue ou relative) du message. S'il est expiré, il peut, par être exemple, être rerouté vers un Dead Letter Channel par le système de messagerie ou vers un Invalid Message Channel s'il a été reçu par un Filter. Cette information est généralement mise dans l'entête du message.</li>
<li><strong>Format Indicator</strong> qui permet de spécifier le format de la donnée (numéro de version, clé d'identification, format de la donnée comme son schéma xsd, &hellip;). Cette information peut être mise soir dans l'entête du message, soir dans le corps de ce dernier.</li>
</ul>


<p>Enfin, les EIP classifient les messages (qui peuvent être utilisés dans des échanges synchrone ou asynchrone) par type d'utilisation :</p>

<ul>
<li><strong>Command Message</strong> qui sont des messages utilisés pour invoquer une méthode ou une procédure.
Document Message qui sont des messages utilisés pour transmettre des données en laissant aux consommateurs de ces derniers le soin de décider de leur traitement.</li>
<li><strong>Event Message</strong> qui sont des messages utilisés pour émettre un événement et qui peut se décliner en deux modèles :

<ul>
<li><strong>Push Model</strong>  : le message est une combinaison du contenu du nouvel élément et de l’événement.</li>
<li><strong>Pull Model</strong> : le message est juste une notification devant être suivie d’une demande du nouvel élément par le consommateur via un Command Message qui reçoit alors un Document Message de l’émetteur.</li>
</ul>
</li>
</ul>


<p><img border="0" height="53" src="http://1.bp.blogspot.com/_XLL8sJPQ97g/SyaC-t6iMxI/AAAAAAAAAGQ/wG2Vj6ffxh0/s200/Image8.png" width="149" alt="center"/></p>

<h2>Notion de Message Routing</h2>

<p>Un <strong>Message Routing</strong> correspond à une catégorie de Filter dans l'architecture Pipes and Filters. Ce type de Filter permet de gérer les problématiques de routage en offrant des composants de&hellip; routage (et oui&hellip; ;&ndash;) ) mais aussi de filtrage (qui peut être considérer un peu comme un routeur), de découpage (un routage de 1 vers n), d'agrégation ou de reséquencement. En outre, on peut les classifier en deux catégories : les basiques et les composés qui composent les Message Routing basiques pour offrir un patron plus complet.</p>

<p>Les EIP décrivent les Message Routing &ldquo;simple&rdquo; suivants :</p>

<ul>
<li><p>De 1 vers 1 :</p>

<ul>
<li><strong>Content-Based Routing</strong> qui permet de router les messages en fonction du contenu de ces derniers en fonction de règles prédéfinies.
<img border="0" height="62" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SyaDQR61EcI/AAAAAAAAAGY/AzMf-1jAW4U/s200/Image9.png" width="98" alt="center"/></li>
<li><strong>Message Filter</strong> qui permet de filtrer les messages en fonction de règles prédéfinies. Il est à noter qu'il peut être sans état ou avec état (par exemple dans le cas où il est nécessaire de supprimer les messages en doublons).
<img border="0" height="67" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SyaDyGdyMCI/AAAAAAAAAGw/AtX-knuh1ZA/s200/Image11.png" width="106" alt="center"/></li>
<li><strong>Dynamic Router</strong> qui permet de router les messages en fonction de critères fournis par un composant tierce pouvant être renseigné dynamiquement.
<img border="0" height="78" src="http://4.bp.blogspot.com/_XLL8sJPQ97g/SyaDrLkbfSI/AAAAAAAAAGo/1kdMD9IXq24/s200/Image10.png" width="141" alt="center"/></li>
<li><strong>Splitter</strong> qui permet de découper un message en fonction de règles pouvant être définies statiquement ou dynamiquement. Il est à noter qu'il peut également adjoindre au message des propriétés comme Message Sequence et Correlation Identifier en prévision d'une éventuelle réagrégation du message découpé.
<img border="0" height="71" src="http://1.bp.blogspot.com/_XLL8sJPQ97g/SyaEpD_IwzI/AAAAAAAAAHA/TS1ldrpLZTg/s200/Image13.png" width="111" alt="center"/></li>
<li><strong>Resequencer</strong> qui permet de réordonnancer une série de message. C'est un Filter à état qui nécessite, généralement le Message Sequence et qui peut soit émettre les messages au fils de l'eau (dès qu'il reçoit le message n+1, il l'émet) soit attendre d'avoir reçu tous les messages à réordonner. Il doit pouvoir :

<ul>
<li>stocker les messages ne correspondant pas au suivant,</li>
<li>gérer l’arrivée d’un nouveau message même si un ré-ordonnancement est en cours,</li>
<li>gérer l’arrivée d’un message ayant déjà été pris en compte dans un processus de ré-ordonnancement,</li>
<li>gérer son buffer afin d’éviter un dépassement de capacité.
<img border="0" height="74" src="http://2.bp.blogspot.com/_XLL8sJPQ97g/SyaE5HQxmjI/AAAAAAAAAHI/eIvUUvfXJjQ/s200/Image15.png" width="117" alt="center"/></li>
</ul>
</li>
</ul>
</li>
<li><p>De 1 vers n :</p>

<ul>
<li><strong>Recipient List</strong>  qui permet de multiplexer un message vers un ensemble de consommateurs en fonction de règles pouvant être basées sur le message ou pouvant être fourni par un composant tierce. Il est à noter que le Recipient List est responsable de l'émission des messages et qu'il doit donc être garant que le message a bien été reçu par tous les destinataires.     <br/>
<img border="0" height="65" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SyaEaEsuo4I/AAAAAAAAAG4/B7LutTEsYY8/s200/Image12.png" width="103" alt="center"/></li>
</ul>
</li>
<li>De n vers 1 :

<ul>
<li><strong>Aggregator</strong> qui permet de ré-agréger des message en un seul. C'est un Filter à état et il peut disposer des stratégies suivantes :

<ul>
<li>Wait for All : attente de tous les messages,</li>
<li>Timeout : attente pendant un laps de temps donné,</li>
<li>First Best : transmission de la première fraction de message reçu et ignorance des autres,</li>
<li>Timeout with Override : attente pendant un laps de temps donné et transmission de la meilleure fraction de message,</li>
<li>External Event : attente jusqu’à réception d’un événement extérieur.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>et qu'il doit pouvoir :</p>

<ul><li><ul><li>
     <ul>
        <li>décider du moment où un message est entièrement reçu, et de ce qu’il doit faire sinon,</li>
        <li>décider de la manière dont il doit agréger les messages reçus,</li>
        <li>gérer l’arrivée d’une fraction d’un nouveau message même si une agrégation est en cours,</li>
        <li>gérer l’arrivée d’une fraction d’un message ayant déjà été agrégé et émis.</li>
    </ul>
</li></ul></li></ul>


<p><img border="0" height="84" src="http://1.bp.blogspot.com/_XLL8sJPQ97g/SyaFFcSzivI/AAAAAAAAAHQ/RpkepGPHzWw/s320/Image14.png" width="131" alt="center"/></p>

<p>En outre, les EIP décrivent les Message Routing &ldquo;composite&rdquo; suivants :</p>

<ul>
<li><strong>Composed Message Processor</strong> qui permet successivement de recevoir un message, de le découper, de l’émettre à différents composants puis d’agréger le résultat de ces derniers dans un unique message.
<img border="0" height="76" src="http://1.bp.blogspot.com/_XLL8sJPQ97g/SyaFW3jJKjI/AAAAAAAAAHY/DDi7TEiJs-I/s320/Image16.png" width="125" alt="center"/></li>
<li><strong>Scatter-Gather</strong> qui permet successivement de recevoir un message, de l’émettre à différents composants puis d’agréger le résultat de ces derniers dans un unique message.</li>
<li><strong>Routing Slip</strong> qui permet d’utiliser l’architecture du Pipes and Filters dans un unique composant, c'est-à-dire chaîner linéairement les appels vers différents filters en masquant les composants appelés et en minimisant les points de contrôle.</li>
<li><strong>Process Manager</strong> qui permet d’invoquer, dans un unique composant, un ensemble d’opérations s’exécutant de manière non linéaire en minimisant les points de contrôle. Il s’agit d’un composant à état qui doit connaître l’étape du processus et qui est être capable de gérer plusieurs instances de processus (utilisation d’un identifiant de corrélation). Il est à noter que pour répondre à ces besoins, certains langages ont émergés tels que :

<ul>
<li>XLANG,</li>
<li>WSFL (<em>Web Services Flow Language</em>),</li>
<li>BPEL (<em>Business Process Execution Language</em>).</li>
</ul>
</li>
<li><strong>Message Broker</strong> qui permet de découpler les destinataires d’un message de l’émetteur en utilisant un unique point de contrôle qui permet de déterminer le consommateur d’un message.</li>
</ul>


<p>Il est à noter que beaucoup des fonctionnalités des Message Routing décrits précédemment peuvent également être traitées en utilisant différents types de Message Channel, en spécialisant le consommateur ou en combinant d’autres Messages Routing (par exemple, le Content-Based Router peut être remplacé en utilisant un Publish/Subscribe Channel en combinaison de Message Filter) : les critères de choix sont donc à étudier avec attention car cela peut impacter la maintenabilité du système ainsi que ses performances. En outre, donner connaissance de la logique aux composants peut entraîner un couplage plus fort.</p>

<h2>Notion de Message Transformer</h2>

<p>Un <strong>Message Transformer</strong> correspond à une catégorie de Filter dans l'architecture Pipes and Filters. Ce type de Filter permet de gérer les problématiques de transformation et d'encapsulation.</p>

<p>Les EIP décrivent les Message Transformer suivants :</p>

<ul>
<li><strong>Envelope Wrapper</strong> qui permet d’encapsuler un message ou un objet dans un message compatible avec le système de messagerie.
<img border="0" height="59" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SyaFoVY9E2I/AAAAAAAAAHg/2ViEhtBdJnA/s200/Image17.png" width="97" alt="center"/></li>
<li><strong>Content Enricher</strong> qui permet d’ajouter des informations au message transmis. Ces informations peuvent provenir :

<ul>
<li>du Content Enricher lui-même,</li>
<li>de l’environnement système,</li>
<li>d’une entité tierce.
<img border="0" height="64" src="http://2.bp.blogspot.com/_XLL8sJPQ97g/SyaF1aBUKFI/AAAAAAAAAHo/ibPijgNSlm4/s320/Image18.png" width="104" alt="center"/></li>
</ul>
</li>
<li><strong>Content Filter</strong> qui permet d’élaguer le contenu d’un message (confidentialité, …) ou de simplifier sa structure. <br/>
<img border="0" height="61" src="http://3.bp.blogspot.com/_XLL8sJPQ97g/SyaGDhigd1I/AAAAAAAAAHw/f7dl2L3Izyk/s320/Image19.png" width="100" alt="center"/></li>
<li><strong>Claim Check</strong> qui permet de diminuer temporairement la taille d’un message en stockant les informations (système de fichiers, base de données) qui peuvent alors être récupérées ultérieurement. Il nécessite, généralement, la génération d’un identifiant permettant de récupérer l’information stockée.
<img border="0" height="81" src="http://1.bp.blogspot.com/_XLL8sJPQ97g/SyaGRMZsSxI/AAAAAAAAAH4/ElWtLODHBQY/s320/Image20.png" width="134" alt="center"/></li>
<li><strong>Normalizer</strong> qui permet de modifier le format d’un message.
<img border="0" height="81" src="http://2.bp.blogspot.com/_XLL8sJPQ97g/SyaGeyIOrNI/AAAAAAAAAIA/FtrTr12I1wY/s320/Image21.png" width="132" alt="center"/></li>
</ul>


<h2>Notion de Message Endpoint</h2>

<p>Un <strong>Message Endpoint</strong> correspond à une catégorie de Filter dans l'architecture Pipes and Filters. Ce type de Filter permet de gérer les problématiques d'interconnexion avec l'extérieur du système de messagerie.</p>

<p>Les Message Endpoint se décomposent en 2 catégories :</p>

<ul>
<li><strong>Send and Receive Patterns</strong> qui s’appliquent aux émetteurs et récepteurs et qui permet au code de l’application de s’interfacer, via une couche de code permettant également de transformer les données afin qu’elles soient compatibles, avec le système de messagerie. Cette couche peut également gérer le coté transactionnelle.</li>
<li><strong>Message Consumer Patterns</strong> qui s’appliquent aux consommateurs de messages et qui peuvent différer sur des critères comme la manière de lire un message dans le canal ou la possibilité de recevoir tous les messages.</li>
</ul>


<p>Il est à noter que le <strong>Message Producer Patterns</strong> n'est pas défini car la procédure d’émission est simple et ne nécessite pas de mécanisme particulier.</p>

<p>Les EIP décrivent les Message Endpoint suivants :</p>

<ul>
<li><strong>Messaging Gateway</strong> qui permet d’encapsuler l’accès au système de messagerie du reste de l’application en fournissant, généralement une API permettant d’émettre et de recevoir des messages de manière synchrone ou asynchrone et positionnant automatiquement, au besoin, les propriétés utiles aux messages. En outre, généralement, c’est à cette couche de gérer les exceptions pouvant être levées par le système de messagerie.</li>
<li><strong>Messaging Mapper</strong> qui permet de lier des objets et des messages compatibles avec le système de messagerie. Cette opération peut s’avérer complexe car, si la donnée est transmise sous forme d’objet, alors les composants du système deviennent dépendants du format (il est à noter que le Messaging Mapper peut être comparé au design pattern Mediator et utiliser les mécanismes de réflexion).</li>
<li><strong>Transactional Client</strong> qui permet de gérer les transactions dans le système de messagerie (dans le cas où il existe plusieurs consommateurs, …).</li>
<li><strong>Polling Consumer</strong> qui permet, pour un consommateur, de récupérer un message du canal en scrutant ce dernier périodiquement ou lorsqu’il est disponible. Il est aussi dénommé Synchronhous receiver et permet de ne consommer qu’un seul thread.</li>
<li><strong>Event-Driven Consumer</strong> qui permet, pour un consommateur, de récupérer un message dès qu’il est disponible sur le canal. Il est aussi dénommé Asynchronous receiver et fonctionne sur le mécanisme de callback.</li>
<li><strong>Competing Consumers</strong> qui permet, lorsque le système nécessite une grande réactivité, en dispatchant les messages d’un Point-to-Point Channel, de les consommer de manière concurrente en associant un thread à chacun de consommateurs.</li>
<li><strong>Message Dispatcher</strong> qui permet de dispatcher les messages d’un canal pour les consommer par différents consommateurs en leur associant un thread à chacun. Le Message Dispatcher peut utiliser des propriétés pour sélectionner le consommateur adéquat. Généralement, les consommateurs sont dans le même processus que le Message Dispatcher contrairement, au Competing Consumers.</li>
<li><strong>Selective Consumer</strong> qui permet de ne consommer que certains messages en provenance d’un canal.</li>
<li><strong>Durable Subscriber</strong> qui permet de recevoir tous les messages d’un Publish/Subscribe Channel même lorsqu’il n’est pas connecté (on utilise alors le terme d’inactif puisqu’il nécessite quand même un abonnement).</li>
<li><strong>Indempotent Receiver</strong> qui permet de ne recevoir qu’une seule instance d’un même message. Il doit être à état et doit donc gérer la purge de l’historique.</li>
<li><strong>Service Activator</strong> qui permet d’invoquer une application prévue pour s’interfacer ou pas avec le système de messagerie. Un Service Activator peut être unidirectionnel (requêtes seules) ou bidirectionnel (requête/réponse) et peut, soit invoquer toujours le même service (application), soit utiliser des mécanismes de réflexion. Il permet d’invoquer, suite à la réception d’un message, l’application comme un client de manière à masquer complètement à l’application le système de messagerie.</li>
</ul>


<h1>Conclusion sur les EIP</h1>

<p>Comme il a été vu, les EIP ne réinventent pas la roue mais permettent de donner un nom à des fonctionnalités ainsi qu'une représentation graphique. Cela peut être utile pour être compris de tous si tout le monde partage le même langage (un peu comme les Design Patterns).</p>

<p>Ils ne proposent pas de solutions clé en main mais mettent en avant des notions qu'il est nécessaire d'avoir dans certains cas d'usage (comme l'identifiant de corrélation pour l'agrégation ou le reséquencement).
Aussi de mon point de vue, il est essentiel de connaitre ces concepts lorsque l'on manipule des messages dans un système asynchrone et que des notions de médiation apparaissent. Je ne saurais donc que vous conseiller la lecture de cet excellent ouvrage.</p>

<p>Les EIP trouvent donc parfaitement leurs places dans une architecture SOA et plus précisément dans les ESB.
Au niveau de ses implémentations, on trouve l'excellent Spring Integration ainsi que Apache Camel (que je trouve beaucoup moins bon de par son modèle de programmation que par ses concepts) et le petit dernier iBeans de Mule : une attention toute particulière doit être apportée quand à la mise en œuvre de ces concepts (et je dirais pour ma part qu'il n'est pas nécessaire (mais alors pas du tout) de rajouter une couche de concepts par dessus comme le fait Apache Camel</p>

<h1>Pour aller plus loin&hellip;</h1>

<ul>
<li><strong>Enterprise Integration Patterns</strong> de G. Hohpe et B. Woolf chez Addisson Wesley</li>
<li>Site de référence sur les EIP : <a href="http://www.eaipatterns.com/">http://www.eaipatterns.com/</a></li>
<li>Article d’IBM sur les EIP : <a href="http://www.ibm.com/developerworks/library/ws-intpatterns/index.html?S_TACT=105AGX20&amp;S_CMP=EDU">http://www.ibm.com/developerworks/library/ws-intpatterns/index.html?S_TACT=105AGX20&amp;S_CMP=EDU</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
