---
layout: post
title: "JMX ou comment administrer et superviser son système..."
date: 2010-05-05
comments: false
categories:
 - java
 - jmx
 - réflexion
---

<div class='post'>
<div style="text-align: justify;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_XLL8sJPQ97g/S-HXgq4HI7I/AAAAAAAAAJ4/LzJKs3wTNZM/s1600/jmx4.png"><img style="float: left; margin: 0pt 10px 10px 0pt; cursor: pointer; width: 200px; height: 57px;" src="http://1.bp.blogspot.com/_XLL8sJPQ97g/S-HXgq4HI7I/AAAAAAAAAJ4/LzJKs3wTNZM/s200/jmx4.png" alt="" id="BLOGGER_PHOTO_ID_5467888378869916594" border="0" /></a>Je n'ai encore fait aucun article sur JMX (Java Management eXtension). Pourtant, je pense qu'il s'agit d'une technologie indispensable pour toute application qui se veut un minimum sérieuse et industrialisable. Dans ce post, je ne parlerai pas de "comment ça marche" ou je ne fournirai pas de tutoriaux. Il s'agit juste d'un petit coup de gueule parce que j'en ai marre d'entendre toujours les mêmes inepties sur JMX...<br /></div><div style="text-align: justify;"><br />Bon, pourquoi JMX me direz-vous? Encore une technologie? Encore un nouveau truc dans mon architecture à mettre en œuvre sur lequel il va falloir faire monter des gens en compétence et qu'il va falloir maintenir?<!-- more --><br /><br />Ben, en fait, non... quoique, en fait, si... il est vrai qu'il s'agit d'une "nouvelle technologie" (au sens encore une nouvelle technologie dans le projet) à mettre en place sur le projet, qu'il va falloir faire monter des gens dessus et qu'il va falloir maintenir.<br />Cependant, elle correspond parfaitement aux besoins de supervision et d'administration de l'application  (en plus d'être un standard et une spécification)... je m'explique : si votre application est en production et qu'une anomalie a lieu (ben oui, une application a toujours des anomalies ;-) ), le développeur, qui va devoir traiter le problème, a besoin de connaitre le contexte du problème, l'état de la mémoire et du CPU Java, l'état de l'application, etc, etc, etc...<br />Bon, vous allez me répondre qu'il y a les logs! Ah, les logs... parlons-en! Des méga et des méga de logs qui, avec un peu de chance, sont un minimum classés dans des fichiers. Par contre, quid de la recherche de l'information dans toute ce bruit, ou quid des architectures distribués où la synchronisation horloge est dans les choux?<br />En fait, JMX permet la supervision de votre application en permettant, par exemple, de positionner des indicateurs (nombre de hits d'un web service, nombre de requêtes, ...) dans l'application et de les interroger. Il permet également de voir leur évolution et même d'émettre des notifications afin de remonter en temps réel ces valeurs.<br /><br />En outre, JMX permet d'administrer le système. Comment? En mettant à disposition un ensemble d'opérations (défini - via les différents types de MBeans - par l'application ou le framework) avec lesquels il est possible d'interagir. Cela permet, par exemple de changer le niveau de logs de l'application à chaud ou de récupérer l'état du cache applicatif.<br /><br />A la question : encore une nouvelle technologie à mettre en place? En fait, si vous utilisez déjà un serveur d'application, un conteneur de servlet, un JMS Provider, un framework de logs ou une pile SOAP tel qu'Axis ou CXF, il est fort à parier que JMX est déjà présent dans votre application puisqu'il est déjà offert par ces derniers afin de permettre leur administration et supervision...<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_XLL8sJPQ97g/S-HWn0wnVAI/AAAAAAAAAJo/rllVP2RIP_s/s1600/jmx.png"><img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 200px; height: 179px;" src="http://2.bp.blogspot.com/_XLL8sJPQ97g/S-HWn0wnVAI/AAAAAAAAAJo/rllVP2RIP_s/s200/jmx.png" alt="" id="BLOGGER_PHOTO_ID_5467887402270282754" border="0" /></a><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_XLL8sJPQ97g/S-HW5MyQV5I/AAAAAAAAAJw/xosMzejwZHs/s1600/jmx2.png"><img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 200px; height: 166px;" src="http://4.bp.blogspot.com/_XLL8sJPQ97g/S-HW5MyQV5I/AAAAAAAAAJw/xosMzejwZHs/s200/jmx2.png" alt="" id="BLOGGER_PHOTO_ID_5467887700777392018" border="0" /></a><br />Par contre, j'avoue que niveau mise en œuvre, JMX souffre de quelques lacunes... En effet, du point de vue de l'équipe de production ou de l'exploitation, qui utilise souvent SNMP pour administrer et superviser l'infrastructure matérielle, il sera sûrement nécessaire d'utiliser des solutions Java pour agréger les différentes métriques et centraliser l'administration (surtout si les applications tournent sur des JVM différentes). Des ponts existent vers SNMP (en l'occurrence en générant des MIB) mais cela s'avère généralement ardue (et j'avoue avoir lamentablement échoué... :( ). Aussi, je préconiserai plutôt d'utiliser des outils autres que ceux dédier aux infrastructures matérielles pour superviser et administrer les couches applicatives (de plus, il s'agira généralement d'équipes différentes puisque la problématique est quand même différente! ... ouf, je m'en sors bien... ;-) ). Des outils comme <a href="http://www.hyperic.com/">Hyperic</a> peuvent être de très bon candidat pour faire cela. Sinon, il reste toujours la bonne vieille jConsole nativement présente dans le JDK qui permet toujours de s'en sortir ou alors, il est toujours possible de développer son propre outils (application web ou application lourde) pour faire le boulot...<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_XLL8sJPQ97g/S-HWRCOOSBI/AAAAAAAAAJg/DUEhO7O-hkI/s1600/logo-hyperic.gif"><img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 158px; height: 74px;" src="http://2.bp.blogspot.com/_XLL8sJPQ97g/S-HWRCOOSBI/AAAAAAAAAJg/DUEhO7O-hkI/s200/logo-hyperic.gif" alt="" id="BLOGGER_PHOTO_ID_5467887010747140114" border="0" /></a><br />Enfin, le dernier point que je voulais aborder est que même si JMX n'est pas très compliqué (du moins pour des utilisations simples), il est, à mon sens, indispensable d'y penser en début du projet (d'un autre coté, une application un minimum industrielle est censée couvrir ce type de problématique dès le début... non?). Sa mise en œuvre peut être faite, par exemple, via le développement d'une petite API simple qui peut aller introspecter les interfaces de l'application à administrer et qui peut aller enregistrer des Dynamics MBeans dans l'agent JMX adéquate.<br /><br />En espérant vous avoir convaincu sur l'intérêt de JMX qui permet de rendre beaucoup de services pour pas trop d'effort!<br /><br />Voilà, fin de ce petit post... il est à noter que d'origine, je voulais juste parler de comment s'en sortir avec JMX et les Firewall... ;-)<br /></div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
Salut François,<br /><br />Tout à fait d&#39;accord avec ton commentaire. Pour apporter de l&#39;eau au moulin, concernant les perfs, j&#39;ai récemment utilisé beet (http://beet.sourceforge.net/) pour récupérer certaines métriques comme le temps passé dans chaque méthode (fonctionnement sur le principe d&#39;AOP). Il n&#39;a rien d&#39;exceptionnel mais ça peut toujours être utile... <br /><br />A+</div>
</div>
<div class='comment'>
<div class='author'>François OSTYN</div>
<div class='content'>
Salut Khanh,<br /><br />Très bon article, je suis totalement d&#39;accord avec toi. JMX est indispensable pour le changement de comportement d&#39;une application/framework à chaud, cela évite bien des arrêts/relances... ;)<br /><br />Mais encore plus important à mes yeux, c&#39;est la récolte de métriques &quot;métier&quot; qui peut être fait par ce biais (nombre d&#39;erreurs, temps d&#39;invocation moyen, nombre d&#39;appels,...).<br /><br />Une chose intéressante aussi c&#39;est la notion de TimerMBean qui permet de lancer des tâches spécifiques périodiquement, quand on a pas besoin de quartz...<br /><br />Pour information, lors de ma dernière mission pour un client, nous avons mis en place un outil de reporting. Chaque JVM envoie ses métriques par HTTP à un serveur spécifique stocke tout en base et ensuit Birt prend le relais pour le reporting des &quot;chefs&quot;. On peut ensuite voir si les mises en prod on un effet bénéfique ou déplorable sur les perfs/erreurs.<br /><br />Par contre, une chose m&#39;énerve pas mal dans JMX, ce n&#39;est pas dans le JDK1.4 et il faut télécharger l&#39;implémentation de référence... Ensuite, persister les MBeans n&#39;est pas toujours chose simple, mais bon, je suis certain qu&#39;une solution simple doit exister. <br /><br />A bientôt<br />François</div>
</div>
<div class='comment'>
<div class='author'>Khanh</div>
<div class='content'>
Merci pour le commentaire.<br />En effet, je ne connaissais pas le fonctionnement des plugins sur visualVM. C&#39;est vrai que c&#39;est plus joli que la jConsole ;-)<br />Cool pour rss : ça me fait un nouveau copain ;-) !</div>
</div>
<div class='comment'>
<div class='author'>n!co</div>
<div class='content'>
Intéressant et entièrement d&#39;accord. Jmx ne remplace pas des logs, des fichiers de conf ou autre, mais pour intervenir a chaud pour certaines opérations de maintenance il n&#39;y a pas plus adapté.<br /><br />A noter deux détails supplémentaires :<br />- Il existe la visual vm de sun. Autrement plus évoluer que la jconsole pour la supervision de vos applis java.<br />https://visualvm.dev.java.net/<br /><br />- Et pas besoin de compétence jmx coté développeur sur un projet utilisant spring, n&#39;importe quel bean peut être exposé via jmx en deux lignes dans un applicationConfig.xml<br />http://static.springsource.org/spring/docs/2.5.x/reference/jmx.html<br /><br />Ca y est, t&#39;es dans mon agregateur rss ;-)<br />nico (Tryane)</div>
</div>
</div>
